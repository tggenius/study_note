# 操作系统-王道：

# 什么是操作系统？

~~~
这节不重要，用图片做笔记，知道即可；
~~~

![image-20230630000110632](D:\typora笔记\操作系统笔记图片\image-20230630000110632.png)	

~~~
·管理整个计算机系统的硬件资源；
·合理调度计算机工作和资源；
·最基本的系统软件；
·屏蔽硬件，向上层提供方便易用的服务；
~~~

## ·bat文件：

~~~
批处理命令==脚本
~~~

![image-20230630000704094](D:\typora笔记\操作系统笔记图片\image-20230630000704094.png)	

## ·向上层提供的服务

![image-20230630001006286](D:\typora笔记\操作系统笔记图片\image-20230630001006286.png)	

![image-20230630001055446](D:\typora笔记\操作系统笔记图片\image-20230630001055446.png)	

# 操作系统四个特征：

## 并发：

~~~c
两个事件在同一个/*时间间隔*/内发生 【注意这里是说"时间间隔"】，微观上是交替发生，宏观同时发生。    
~~~

## 并行：

~~~c
两个事件或多个事件'同一时刻'发生
~~~

## 两者区别：

![image-20230630001606966](D:\typora笔记\操作系统笔记图片\image-20230630001606966.png)	

## 共享：

### 两种方式：

![image-20230630001845259](D:\typora笔记\操作系统笔记图片\image-20230630001845259.png)	

~~~c
'并发共享：互为存在条件'
~~~

![image-20230630002002485](D:\typora笔记\操作系统笔记图片\image-20230630002002485.png)	

## 虚拟：

~~~c
'把一个物理上的实体变成若干个逻辑对应物'
~~~

![image-20230630002115450](D:\typora笔记\操作系统笔记图片\image-20230630002115450.png)	

## 异步：

![image-20230630002225055](D:\typora笔记\操作系统笔记图片\image-20230630002225055.png)	

## ·两个最基本的特征：

~~~c
'并发和共享'
~~~

![image-20230630002319571](D:\typora笔记\操作系统笔记图片\image-20230630002319571.png)	

# 操作系统的各个发展阶段：

## 手工操作阶段：

![image-20230630002544102](D:\typora笔记\操作系统笔记图片\image-20230630002544102.png)	

## 单道批处理系统：

~~~
程序串行执行，但是能批处理多个任务
~~~

![image-20230630002706496](D:\typora笔记\操作系统笔记图片\image-20230630002706496.png)	

## 多道批处理系统：

![image-20230630002813053](D:\typora笔记\操作系统笔记图片\image-20230630002813053.png)	

## 分时操作系统：

~~~
多个用户操作一台主机，主机为各个用户的任务分别分出时间，来回切换处理；
~~~

------

**以上不是重点；**

## 总结：

![image-20230630003038943](D:\typora笔记\操作系统笔记图片\image-20230630003038943.png)	

------



# 操作系统运行机制：

~~~
运行机制即执行指令的过程
~~~

![image-20230630003251389](D:\typora笔记\操作系统笔记图片\image-20230630003251389.png)	

## 用户态，内核态：

![image-20230630003511550](D:\typora笔记\操作系统笔记图片\image-20230630003511550.png)	

## 两个状态的切换：

~~~
需要操作系统介入的地方，都会出发中断信号；；
用户态内核态之间的切换，通过标志位PSW的 【0，1】两个状态表示；
~~~

![image-20230630003734780](D:\typora笔记\操作系统笔记图片\image-20230630003734780.png)	

## 总结：

![image-20230630004043487](D:\typora笔记\操作系统笔记图片\image-20230630004043487.png)	

------



# 中断：

## ·作用：

~~~
让操作系统内核夺回CPU使用权的唯一方式；
~~~

![image-20230702192055558](D:\typora笔记\操作系统笔记图片\image-20230702192055558.png)

## 中断的类型：

![image-20230702193234515](D:\typora笔记\操作系统笔记图片\image-20230702193234515.png)		

~~~
内中断一般叫做异常，外中断才一般称作中断；
【异常】：程序执行发生错误，爆出异常，通知cpu中断，停止执行当前的程序；
~~~

​	

## ·中断的原理：

![image-20230702193355469](D:\typora笔记\操作系统笔记图片\image-20230702193355469.png)	

~~~
更深的内容需要学习【计算机组成原理】；
~~~

## ·小结：

![image-20230702193500917](D:\typora笔记\操作系统笔记图片\image-20230702193500917.png)	

------



# 系统调用：

~~~
应用程序通过【系统调用】请求获得内核的服务；
~~~

## 系统调用和库函数的区别：

![image-20230702193657328](D:\typora笔记\操作系统笔记图片\image-20230702193657328.png)	

## 系统调用的应用方面：

~~~
涉及共享资源的基本都需要使用系统调用请求内核服务；
~~~

![image-20230702193913698](D:\typora笔记\操作系统笔记图片\image-20230702193913698.png)	

## 系统调用过程：

~~~
主要依靠【陷入指令】，通过陷入指令引发中断，进入内核态执行 应用程序请求的内核服务；
~~~



![image-20230702194154928](D:\typora笔记\操作系统笔记图片\image-20230702194154928.png)	

## 小结：

![image-20230702194347698](D:\typora笔记\操作系统笔记图片\image-20230702194347698.png)	

------



# 操作系统的内核：

~~~
这一节不是很重要；
~~~

![image-20230702195318711](D:\typora笔记\操作系统笔记图片\image-20230702195318711.png)	

## ·内核：

~~~
和硬件联系紧密的位于内核态；
~~~

### 大内核和微内核的区别：

![image-20230702195459808](D:\typora笔记\操作系统笔记图片\image-20230702195459808.png)	

~~~
大内核代码杂乱不宜维护，微内核相反；
大内核节省系统资源，状态切换次数少；
~~~

## ·系统结构：

![image-20230702195730355](D:\typora笔记\操作系统笔记图片\image-20230702195730355.png)	

~~~
对图进行讲解；
~~~

## 分层结构：

![image-20230702200016827](D:\typora笔记\操作系统笔记图片\image-20230702200016827.png)	

~~~
优点：
1.易于维护：上下两层的参数都已经固定式，此时想要往中间插入一层，只需要考虑上层能否合理的调用下层服务，以及新插入的层需要与下一层的参数做好协调；
2.便于调试，如图所示；

缺点：
1.跨层调用不行，需要一层层传递；
2.边界定义：只能高层调用底层，这一点很大的限制了各层之间功能的边界划分；（相当于微服务拆分分配，需要根据业务边界划分，十分困难）
~~~

## 模块化：

![image-20230702200710277](D:\typora笔记\操作系统笔记图片\image-20230702200710277.png)	

~~~
优点：
1.当一个模块需要对外暴露的接口定义好后，其他需要调用这些接口的模块就可以同时进行开发；
2.易于拓宽，当需要增加功能是，可以额外的增加驱动程序作为一个模块，不影响其他模块的情况下，这个驱动可以调用其他模块已有的接口，不需要时直接移除（例如主机的驱动程序安装，没有蓝牙就不需要蓝牙驱动，增加蓝牙设备时，直接打驱动就好）
3.模块之间直接通过调用函数使用其他模块功能，不需要通过消息通知传递，影响效率；

缺点：
1.在一开始定义一个模块时，其他模块可能要使用这个模块的其他功能，此时就需要重新修改，导致定义的不合理；
2.模块之间依赖，出现问题难以判断哪个模块出现问题，可能自己，也可能另一个模块；
~~~

## 大内核，微内核：

~~~
大内核所有的功能都耦合在一个module中，各个模块之间可以直接调用；

微内核相当于微服务，模块之间位于不同区域，区域通过传递消息来通知；
~~~

------



# 操作系统的引导：

~~~
即boot，引导电脑开机；
~~~

## 开机过程：

![image-20230702203153990](D:\typora笔记\操作系统笔记图片\image-20230702203153990.png)	ram指的是内存；rom是集成在主板上的，断电不会消失；

![image-20230702203437615](D:\typora笔记\操作系统笔记图片\image-20230702203437615.png)	

![image-20230702203445734](D:\typora笔记\操作系统笔记图片\image-20230702203445734.png)开机时执行的程序;；

​	

------

# 虚拟机：

![image-20230704004854318](D:\typora笔记\操作系统笔记图片\image-20230704004854318.png)

## 第一类VMM：

![image-20230704004215633](D:\typora笔记\操作系统笔记图片\image-20230704004215633.png)	

~~~
直接将硬件资源分配给各个虚拟操作系统；
虚拟的操作系统运行在用户态，但系统本身不知道自己运行在用户态，以为自己在内核态，因此会使用一些特权指令；虚拟系统使用特权指令时，会被虚拟机管理程序拦截，并且对这个特权指令进行模拟，给出一个模拟执行的结果；
~~~

## 第二类VMM：

![image-20230704004638366](D:\typora笔记\操作系统笔记图片\image-20230704004638366.png)	

~~~
直接在宿主机上运行虚拟软件，由虚拟软件执行操作系统模拟程序；
例如使用VM ware等软件；

和第一类不同的是：
第一类直接分配硬件资源给操作系统；第二类的硬件资源由宿主机管理；
~~~

## 两类区别：

![image-20230704005418625](D:\typora笔记\操作系统笔记图片\image-20230704005418625.png)

### 性能：

~~~
·第二类分配资源给虚拟机时，是由宿主机分配虚拟资源，虚拟资源通过映射到宿主机，宿主机在映射到硬件；例如分配内存，第二类分配给虚拟机的肯定都是虚拟内存；
·而第一类直接操作硬件，不需要与宿主机争夺资源；
~~~

### 运行模式：

~~~
第一类需要进行写入操作时，可直接执行；
第二类要执行写入操作，会被vmm拦截，转化为宿主机执行这条命令；
~~~

------

# ========第二章开始=========

# 进程管理：

~~~
程序是静态的可执行文件，一系列指令；
进程是动态的；是程序的一次执行过程；
~~~

**一个程序会对应多个进程；**

~~~
操作系统对每个进程分配PID，表示各个不同进程；
~~~

![image-20230704010313997](D:\typora笔记\操作系统笔记图片\image-20230704010313997.png)

~~~
进程的所有信息被存放在【进程控制块】PCB；
~~~

## 进程实体：

![image-20230704010601363](D:\typora笔记\操作系统笔记图片\image-20230704010601363.png)	

~~~
·进程实体由【程序段】【数据段】【PCB】三个部分组成；
·进程反映了进程实体某一时刻的状态；
~~~

### 小结：

![image-20230704010852140](D:\typora笔记\操作系统笔记图片\image-20230704010852140.png)	

~~~c
进程是"进程实体"的运行过程；是系统资源分配和调度的"独立单位"；
~~~



## 进程特征：

![image-20230704011052250](D:\typora笔记\操作系统笔记图片\image-20230704011052250.png)	

## 总结：

![image-20230704011138330](D:\typora笔记\操作系统笔记图片\image-20230704011138330.png)	

~~~
在线程出现后，进程不再是接受调度的基本单位，但还是分配资源的基本单位；
~~~

------



# 进程状态，状态的转换：

![image-20230704011730239](D:\typora笔记\操作系统笔记图片\image-20230704011730239.png)	

~~~
·阻塞态---就绪态，不是进程自身能控制的，是被动行为；当资源被分配后，才能变成就绪态，因此需要被动等待资源分配；
·阻塞态不能直接转为运行态，因为因此进入阻塞需要主动发请求，能够发请求那必然是在运行中；
~~~

![image-20230704012036742](D:\typora笔记\操作系统笔记图片\image-20230704012036742.png)	

~~~c
'不同状态的进程，会被统一组织起来管理；'
~~~

## 组织方式：

### 链表：

![image-20230704012135223](D:\typora笔记\操作系统笔记图片\image-20230704012135223.png)	

### 索引：

![image-20230704012223358](D:\typora笔记\操作系统笔记图片\image-20230704012223358.png)	

### 小结：

![image-20230704012244579](D:\typora笔记\操作系统笔记图片\image-20230704012244579.png)	

## 总结：

![image-20230704012313463](D:\typora笔记\操作系统笔记图片\image-20230704012313463.png)红色框细看；

​	

------

# 进程控制：

~~~c
进程控制由原语完成；
原语：原子性，能够一次从头到尾不间断完成的指令；    
进程之间的的状态转换必须一气呵成；    
~~~

![image-20230704012657800](D:\typora笔记\操作系统笔记图片\image-20230704012657800.png)	

## 原语的原子性：

~~~
依赖关中断，开中断指令；
~~~

![image-20230704012856393](D:\typora笔记\操作系统笔记图片\image-20230704012856393.png)	

## 进程控制相关原语：

### 进程创建：

![image-20230704013024061](D:\typora笔记\操作系统笔记图片\image-20230704013024061.png)	

### 进程撤销：

![image-20230704013112130](D:\typora笔记\操作系统笔记图片\image-20230704013112130.png)	

### 进程唤醒阻塞：

~~~
唤醒原语和阻塞原语需要成对使用，因什么阻塞，就被什么唤醒；
~~~

![image-20230704013309536](D:\typora笔记\操作系统笔记图片\image-20230704013309536.png)	

### 进程切换：

![image-20230704013554595](D:\typora笔记\操作系统笔记图片\image-20230704013554595.png)	

## 寄存器：

~~~c
程序在运行时，需要把指令存放到寄存器中；
~~~

![image-20230704013815517](D:\typora笔记\操作系统笔记图片\image-20230704013815517.png)	

~~~
如果当前执行这个程序的进程要被切换为其他进程，但是寄存器是各个进程共用的，之前计算的结果会被覆盖；
此时就需要保存当前进程的状态【进程上下文】存放到当前进程自己的PCB中，以便下次切换回来时快速恢复；
~~~

## 小结：

![image-20230704014057157](D:\typora笔记\操作系统笔记图片\image-20230704014057157.png)	

​	

------

# 进程通信：

## 进程资源：

![image-20230704014329042](D:\typora笔记\操作系统笔记图片\image-20230704014329042.png)	

## 共享存储：

~~~
各个进程对于共享的存储区的使用应该是互斥的
~~~

![image-20230704014525491](D:\typora笔记\操作系统笔记图片\image-20230704014525491.png)	

~~~
分为两种方式：
	基于数据结构；分配一块区域，限制使用方式和结构；
	基于存储区；一块内存块完全由进程自己操作；
~~~

![image-20230704014722007](D:\typora笔记\操作系统笔记图片\image-20230704014722007.png)	

## 消息传递：

### 直接通信：

~~~
明确发给谁，谁来收；
~~~

![image-20230704015102788](D:\typora笔记\操作系统笔记图片\image-20230704015102788.png)	

### 间接通信：

~~~
指定一个“信箱”，作为中介；
~~~

![image-20230704015214375](D:\typora笔记\操作系统笔记图片\image-20230704015214375.png)	

## 管道通信：

~~~
开辟一个大小固定的内存缓冲区；
~~~

~~~
和共享内存的区别：
	·管道符合先进先出的队列结构，不像共享内存，想往哪写都行；
	·单向通信，无法双向通信；【半双工通信】
~~~

![image-20230704015731483](D:\typora笔记\操作系统笔记图片\image-20230704015731483.png)	

~~~
允许多个写进程，多个读进程；操作系统控制；
多个写，一个读进程；
~~~

## 总结：

![image-20230704015830940](D:\typora笔记\操作系统笔记图片\image-20230704015830940.png)	

![image-20230704015919939](D:\typora笔记\操作系统笔记图片\image-20230704015919939.png)	

------



# 线程：

~~~
·引入线程，增加并发度；
·qq是一个进程，这个进程中可以包含视频聊天，窗口文字聊天等线程；
·线程是目前程序执行流中的最小单位；cpu最小执行单元；
·进程是系统资源分配的单元；（引入了线程之后）
~~~

![image-20230704234944478](D:\typora笔记\操作系统笔记图片\image-20230704234944478.png)舍友就好比线程，可以坐在一张桌子上；

## 线程的属性：

![image-20230704235126176](D:\typora笔记\操作系统笔记图片\image-20230704235126176.png)	

​	

------

# 线程的实现方式：

最早的线程库：

![image-20230704235412186](D:\typora笔记\操作系统笔记图片\image-20230704235412186.png)	

![image-20230705005327722](D:\typora笔记\操作系统笔记图片\image-20230705005327722.png)	缺点：程序的顺序执行，一定会从上往下走，不管需不需要；

## 内核级线程：

![image-20230705005530999](D:\typora笔记\操作系统笔记图片\image-20230705005530999.png)	

![image-20230705005613196](D:\typora笔记\操作系统笔记图片\image-20230705005613196.png)	

## 多线程模型：

![image-20230705005816007](D:\typora笔记\操作系统笔记图片\image-20230705005816007.png)

~~~
此时操作系统只看得见【内核级线程】；
~~~

### 多对多模型：

![image-20230705010003709](D:\typora笔记\操作系统笔记图片\image-20230705010003709.png)	

~~~c
用户级线程：代码逻辑；
内核级线程：运行机会；分配【处理机】资源的单位    
~~~

------

# 线程状态与转换：

状态与进程相同；

![image-20230705010448238](D:\typora笔记\操作系统笔记图片\image-20230705010448238.png)	

## 组织与控制：

![image-20230705010432190](D:\typora笔记\操作系统笔记图片\image-20230705010432190.png)	

------

# 处理机的调度，概念，层次：

## 高级调度：

![image-20230705010657115](D:\typora笔记\操作系统笔记图片\image-20230705010657115.png)每个作业只【调入一次，调出一次】	

## 低级调度：

![image-20230705010759247](D:\typora笔记\操作系统笔记图片\image-20230705010759247.png)	

## 中级调度：

![image-20230705010851989](D:\typora笔记\操作系统笔记图片\image-20230705010851989.png)根据策略将挂起的线程调入内存；	

## 挂起状态：七状态模型

![image-20230705011008427](D:\typora笔记\操作系统笔记图片\image-20230705011008427.png)	

~~~
挂起--调入外存忠；
阻塞--还在内存中；
~~~

## 三个调度对比：

![image-20230705011106927](D:\typora笔记\操作系统笔记图片\image-20230705011106927.png)	

~~~
高级调度--会多一个撤销PCB的操作；只会调入内存一次，调出一次；和中级不一样；
~~~

------

# 进程通信（详细版-复习：

![image-20230708164733775](D:\typora笔记\操作系统笔记图片\image-20230708164733775.png)	

## 进程通信概念：

![image-20230708165029971](D:\typora笔记\操作系统笔记图片\image-20230708165029971.png)	

~~~
例如微博分享到微信，这就是微博进程与微信进程的通信；
~~~

~~~
进程是分配资源的基本单位，各个进程的内存地址空间相互独立；
~~~

![image-20230708165226804](D:\typora笔记\操作系统笔记图片\image-20230708165226804.png)	

## 共享存储：

![image-20230708165347523](D:\typora笔记\操作系统笔记图片\image-20230708165347523.png)	

~~~
通过增加【页表项，段表项】，共享一片内存；
对共享区域的访问，各个进程是互斥进行的；
基于存储区=是一种高级通信方式=存放位置和数据的形式由进程决定；

基于数据结构=例如下方定义三个int共享=意味着每次只能读写int类型的数据，其他形式的不行；
~~~

![image-20230708165634744](D:\typora笔记\操作系统笔记图片\image-20230708165634744.png)	



## 消息传递：

### 直接通信方式：

~~~
进程之间的数据交换以【格式化消息】为单位；使用两个【原语】进行数据交换（发送/接收消息）
~~~

![image-20230708170217359](D:\typora笔记\操作系统笔记图片\image-20230708170217359.png)	

~~~
当进程P发送消息给Q，进程P则指明要发的消息对象是Q；
操作系统内核在消息队列中找到是否有发给Q的消息，找到后，就将消息复制到【用户区】的进程Q；

重点：需要指名道姓；
~~~

### 间接（信箱）通信方式：

~~~
进程向操作系统内核申请信箱；
进程发送消息时，指明发送到哪个信箱；
允许多个进程向一个信箱发送消息，也允许多个进程接收一个信箱的消息；
~~~

![image-20230708170640151](D:\typora笔记\操作系统笔记图片\image-20230708170640151.png)	

## 管带通信：

![image-20230708170816786](D:\typora笔记\操作系统笔记图片\image-20230708170816786.png)	

~~~
管道通信的消息是先进先出的；
Q需要读消息时，需要先读取管道前面的，才能读后面的；
半双工通信，一段时间内只能单向传输；
在部分操作系统允许一个读进程，多个写进程；在linux中，允许多个写进程，多个读进程（多个读进程是轮流的方式读的）；

写满时会堵塞（写进程），读完时会堵塞（读进程）；
~~~

![image-20230708171253521](D:\typora笔记\操作系统笔记图片\image-20230708171253521.png)	

## 小结：

![image-20230708171513323](D:\typora笔记\操作系统笔记图片\image-20230708171513323.png)	

------



# 进程调度时机，切换和过程：

## 调度时机：

![image-20230708171809976](D:\typora笔记\操作系统笔记图片\image-20230708171809976.png)	

### 临界区：

![image-20230708172025076](D:\typora笔记\操作系统笔记图片\image-20230708172025076.png)	

~~~
分为普通临界区，内核临界区；
普通临界区例如打印机，在打印任务未完成的情况下，进程一直占有资源，直到打印机工作完成；
~~~

## 方式:

![image-20230708172157086](D:\typora笔记\操作系统笔记图片\image-20230708172157086.png)

![image-20230708172351916](D:\typora笔记\操作系统笔记图片\image-20230708172351916.png)	

~~~
狭义与广义不用深究，没意义；
~~~

## 小结：

![image-20230708172508839](D:\typora笔记\操作系统笔记图片\image-20230708172508839.png)	

------

# 调度器/调度程序：

~~~
调度器是处理机中负责管理进程调度的重要程序；
~~~

**调度程序的触发时机：**

![image-20230708172730287](D:\typora笔记\操作系统笔记图片\image-20230708172730287.png)	

![image-20230708172919599](D:\typora笔记\操作系统笔记图片\image-20230708172919599.png)	

~~~
如果支持线程，调度程序管理的就是线程了，进程作为资源分配的基本单位；
~~~

## 闲逛程序：

~~~
当cpu空闲时，就会执行闲逛进程；
~~~

![image-20230708173041907](D:\typora笔记\操作系统笔记图片\image-20230708173041907.png)	

------



# 调度算法的评价指标：

## cpu利用率：

看图例子即可；

![image-20230708173231859](D:\typora笔记\操作系统笔记图片\image-20230708173231859.png)	

## 系统吞吐量：

![image-20230708173306064](D:\typora笔记\操作系统笔记图片\image-20230708173306064.png)	

## 周转时间：

![image-20230708173429669](D:\typora笔记\操作系统笔记图片\image-20230708173429669.png)	

~~~
各个作业执行时间有短有长；
如果短作业的周转时间长，用户体验感差；（上厕所只需要一会，却需要排队）
~~~

### 带权周转时间：

~~~
作业的实际执行时间短，如果带权周转时间小，则作业的周转时间短；
~~~

![image-20230708173656483](D:\typora笔记\操作系统笔记图片\image-20230708173656483.png)

## 等待时间：

## ![image-20230708173919117](D:\typora笔记\操作系统笔记图片\image-20230708173919117.png)	

~~~
【调度算法】影响的是【等待时间】；
进程等待时间和作业等待时间不一样；
~~~

## 小结：

![image-20230708174000023](D:\typora笔记\操作系统笔记图片\image-20230708174000023.png)	

------



# 调度算法（概念-无代码）：

## 先来先服务：

![image-20230709172302502](D:\typora笔记\操作系统笔记图片\image-20230709172302502.png)	

![image-20230709172510482](D:\typora笔记\操作系统笔记图片\image-20230709172510482.png)	

## 短作业优先：

![image-20230709172757323](D:\typora笔记\操作系统笔记图片\image-20230709172757323.png)	

### 抢占式：

![image-20230709173049954](D:\typora笔记\操作系统笔记图片\image-20230709173049954.png)	

#### 计算：

![image-20230709173103343](D:\typora笔记\操作系统笔记图片\image-20230709173103343.png)	

#### 对比非抢占式：

![image-20230709173136429](D:\typora笔记\操作系统笔记图片\image-20230709173136429.png)	

![image-20230709173318272](D:\typora笔记\操作系统笔记图片\image-20230709173318272.png)	

### 小结：

![image-20230709173424752](D:\typora笔记\操作系统笔记图片\image-20230709173424752.png)	

## 高响应优先算法：

![image-20230710232652590](D:\typora笔记\操作系统笔记图片\image-20230710232652590.png)	

![image-20230710232741159](D:\typora笔记\操作系统笔记图片\image-20230710232741159.png)	

## 小结：

~~~
交互性差，适用于早期批处理系统；
~~~

![image-20230710232834850](D:\typora笔记\操作系统笔记图片\image-20230710232834850.png)	

## 时间片轮转调度算法：

![image-20230718000419849](D:\typora笔记\操作系统笔记图片\image-20230718000419849.png)	

![image-20230718000514112](D:\typora笔记\操作系统笔记图片\image-20230718000514112.png)	

![image-20230718000532299](D:\typora笔记\操作系统笔记图片\image-20230718000532299.png)	

### 使用先来先服务算法执行的情况：

时间片过大，算法效果退化；

![image-20230718000834341](D:\typora笔记\操作系统笔记图片\image-20230718000834341.png)	

时间片过小也不行：

![image-20230718000924373](D:\typora笔记\操作系统笔记图片\image-20230718000924373.png)	

### 小结：

![image-20230718001008164](D:\typora笔记\操作系统笔记图片\image-20230718001008164.png)	

## 优先级调度算法：

![image-20230718001326864](D:\typora笔记\操作系统笔记图片\image-20230718001326864.png)	

![image-20230718001430835](D:\typora笔记\操作系统笔记图片\image-20230718001430835.png)	

### 小结：

![image-20230718001613754](D:\typora笔记\操作系统笔记图片\image-20230718001613754.png)	

## 多级反馈队列调度算法：

~~~
第一次先进入一级队列，优先级最高，时间片最小；
~~~

![image-20230718001923249](D:\typora笔记\操作系统笔记图片\image-20230718001923249.png)	

### 系统中的理论实践：

![image-20230718002423069](D:\typora笔记\操作系统笔记图片\image-20230718002423069.png)	

### 小结：

![image-20230718002205731](D:\typora笔记\操作系统笔记图片\image-20230718002205731.png)	

## 小结：

![image-20230718002238573](D:\typora笔记\操作系统笔记图片\image-20230718002238573.png)	

------

# 进程同步，互斥：

## 进程同步问题：

~~~
同步==直接制约关系
~~~

![image-20230718002700346](D:\typora笔记\操作系统笔记图片\image-20230718002700346.png)	

![image-20230718002711795](D:\typora笔记\操作系统笔记图片\image-20230718002711795.png)	

## 进程互斥：

![image-20230718002931065](D:\typora笔记\操作系统笔记图片\image-20230718002931065.png)	

### 临界资源的四个区域：

![image-20230718003111371](D:\typora笔记\操作系统笔记图片\image-20230718003111371.png)	

### 临界资源的规则：

![image-20230718003227293](D:\typora笔记\操作系统笔记图片\image-20230718003227293.png)	

## 小结：

![image-20230718003244613](D:\typora笔记\操作系统笔记图片\image-20230718003244613.png)		

# 进程互斥的软件实现方案：

![image-20230718003321506](D:\typora笔记\操作系统笔记图片\image-20230718003321506.png)	

## 单标志法：

![image-20230718003603958](D:\typora笔记\操作系统笔记图片\image-20230718003603958.png)	

## 双标志先检查法：

如果两个进程是并发执行，会出现变量的并发问题；

![image-20230718003740419](D:\typora笔记\操作系统笔记图片\image-20230718003740419.png)	

## 双标志后检查法：

![image-20230718004030915](D:\typora笔记\操作系统笔记图片\image-20230718004030915.png)	

**原子性问题，导致死锁：**

![image-20230718004101100](D:\typora笔记\操作系统笔记图片\image-20230718004101100.png)	

## Peterson算法：

![image-20230718004600531](D:\typora笔记\操作系统笔记图片\image-20230718004600531.png)	

![image-20230718004608714](D:\typora笔记\操作系统笔记图片\image-20230718004608714.png)	让权等待：如果此时不使用临界区，应该先将cpu资源让权给其他进程；

## 小结：

![image-20230718004716410](D:\typora笔记\操作系统笔记图片\image-20230718004716410.png)	

------

# 进程互斥的硬件实现方法：

## 中断屏蔽方法：

![image-20230718235753163](D:\typora笔记\操作系统笔记图片\image-20230718235753163.png)	

## Test And Set指令：

~~~
优点：一气呵成的原子指令；
缺点：会造成忙等；
~~~

![image-20230719000156910](D:\typora笔记\操作系统笔记图片\image-20230719000156910.png)	

## Swap指令：

和TS做的事基本一样，优缺点也一样；

![image-20230719000319553](D:\typora笔记\操作系统笔记图片\image-20230719000319553.png)	

## 小结：

![image-20230719000352797](D:\typora笔记\操作系统笔记图片\image-20230719000352797.png)	

------

# 互斥锁：

造成忙等情况的都可以被叫做“自旋锁”；

![image-20230719000608626](D:\typora笔记\操作系统笔记图片\image-20230719000608626.png)	

![image-20230719000651686](D:\typora笔记\操作系统笔记图片\image-20230719000651686.png)	

------

# 信号量机制：

~~~
·解决进程互斥，同步的问题；
·是一种变量；
·可以是整数，或记录型变量；
~~~

![image-20230719001058544](D:\typora笔记\操作系统笔记图片\image-20230719001058544.png)	

~~~
·原语由关中断，开中断实现的。
·信号量=变量=系统中资源的数量。
~~~

## 整形信号量：

~~~
两个原语，一个等待资源，一个释放资源，仅此而已；
~~~

![image-20230719001501876](D:\typora笔记\操作系统笔记图片\image-20230719001501876.png)	

## 记录型信号量：

~~~
·与整形相比，多了一个等待队列记录；
·相同点：都是对一个变量加减；
~~~

![image-20230719001644041](D:\typora笔记\操作系统笔记图片\image-20230719001644041.png)	

### 案例：

~~~
四个进程抢两台打印机，前两个抢到，后两个等待；
~~~

![image-20230719001904215](D:\typora笔记\操作系统笔记图片\image-20230719001904215.png)	

![image-20230719002019413](D:\typora笔记\操作系统笔记图片\image-20230719002019413.png)	

~~~c
//由于存在等待队列记录，因此使其能够让权等待；
~~~

## 小结：

![image-20230719002055362](D:\typora笔记\操作系统笔记图片\image-20230719002055362.png)	

------

# 信号量实现进程互斥，同步，前驱关系：

## 互斥：

~~~
将信号量作为临界资源的申请名额；
~~~

![image-20230720011916732](D:\typora笔记\操作系统笔记图片\image-20230720011916732.png)	

## 同步：

~~~
目前有两个进程P1和P2，使用信号量限制两个进程的执行顺序；

进程1执行V操作后，进程2才可以进行后续的操作，否则会一直卡在P操作；

P V 操作必须保证一前一后，从而达到限制各个并发进程 在执行时，形成前后顺序关系
~~~

![image-20230720012438686](D:\typora笔记\操作系统笔记图片\image-20230720012438686.png)	

## 前驱关系：

![image-20230720012907339](D:\typora笔记\操作系统笔记图片\image-20230720012907339.png)	每一对进程都需要实现  一前一后的操作  

![image-20230720013015141](D:\typora笔记\操作系统笔记图片\image-20230720013015141.png)	

~~~
关键在于使用信号量，实现  前操作，后操作，使前后形成顺序的依赖关系；
~~~

## 小结：

![image-20230720013224425](D:\typora笔记\操作系统笔记图片\image-20230720013224425.png)	

------

# 生产者-消费者问题：

![image-20230720020337829](D:\typora笔记\操作系统笔记图片\image-20230720020337829.png)	

![image-20230720020531045](D:\typora笔记\操作系统笔记图片\image-20230720020531045.png)	

![image-20230720020809843](D:\typora笔记\操作系统笔记图片\image-20230720020809843.png)		

~~~
上面这个代码会造成死锁，如果资源区没有资源的情况下，会造成堵塞，有资源则不会；
~~~

## 多消费者：

使用互斥信号量实现盘子消费问题：

![image-20230720021517977](D:\typora笔记\操作系统笔记图片\image-20230720021517977.png)	

### 不使用互斥：

![image-20230720021647669](D:\typora笔记\操作系统笔记图片\image-20230720021647669.png)	

~~~
同样可以实现互斥操作；

原因：盘中资源最大数为1，不管怎样，其他消费者要操作，就只能等待那一个资源；
~~~

![image-20230720021832116](D:\typora笔记\操作系统笔记图片\image-20230720021832116.png)

------



# 吸烟者问题：

![image-20230726005725137](D:\typora笔记\操作系统笔记图片\image-20230726005725137.png)	

### 问题分析：

![image-20230726005938443](D:\typora笔记\操作系统笔记图片\image-20230726005938443.png)	

![image-20230726010115790](D:\typora笔记\操作系统笔记图片\image-20230726010115790.png)	

## 代码实现：

![image-20230726010341362](D:\typora笔记\操作系统笔记图片\image-20230726010341362.png)	

## 需要学习的思路：

![image-20230726010450869](D:\typora笔记\操作系统笔记图片\image-20230726010450869.png)	

------



# 读者，写者问题：

![image-20230726010828221](D:\typora笔记\操作系统笔记图片\image-20230726010828221.png)	

## 使用PV操作解决：

~~~
第一个读进程加锁，最后一个读进程解锁，实现读进程共享；中间的读进程跳过加锁的过程
~~~

~~~
这个方法会造成写进程饥饿，因此可以设置写进程优先的情况，避免这个问题；
~~~

![image-20230726011255215](D:\typora笔记\操作系统笔记图片\image-20230726011255215.png)	

------



# 哲学家问题：

## 问题分析：

~~~
解决死锁问题
~~~

![image-20230726011950227](D:\typora笔记\操作系统笔记图片\image-20230726011950227.png)	

## 造成死锁：

~~~
都在等待其他哲学家放下筷子；
~~~

![image-20230726012051811](D:\typora笔记\操作系统笔记图片\image-20230726012051811.png)	

## 解决方案之一：

![image-20230726012403341](D:\typora笔记\操作系统笔记图片\image-20230726012403341.png)	使用一个互斥信号量；

------

# 管程

~~~
高级同步机制，使用信号量机制写代码易出错；

有点类似于“类”
~~~

![image-20230802012745539](D:\typora笔记\操作系统笔记图片\image-20230802012745539.png)	

## 特征：

![image-20230802012813106](D:\typora笔记\操作系统笔记图片\image-20230802012813106.png)	

## 管程解决消费者问题：

~~~
消费者不用再关心信号量问题，由管程处理：
~~~

![image-20230802013004474](D:\typora笔记\操作系统笔记图片\image-20230802013004474.png)	

## 管程的作用：

![image-20230802013449297](D:\typora笔记\操作系统笔记图片\image-20230802013449297.png)	

![image-20230802013512049](D:\typora笔记\操作系统笔记图片\image-20230802013512049.png)	

## java中的管程：

~~~
此时使用synchronize中就是一个管程；
~~~

![image-20230802013548623](D:\typora笔记\操作系统笔记图片\image-20230802013548623.png)	

## 小结：

![image-20230802013634132](D:\typora笔记\操作系统笔记图片\image-20230802013634132.png)

​	

------



# 死锁：

## 死锁概念：

~~~
死锁就是两个或两个以上的对象，各自都占有对方或其他对象所需要的资源，互相僵持，导致资源陷入循环等待的情况
~~~

## 三个概念的区别：

![image-20230804153440177](D:\typora笔记\操作系统笔记图片\image-20230804153440177.png)	

![image-20230804153504019](D:\typora笔记\操作系统笔记图片\image-20230804153504019.png)死锁和饥饿，是操作系统需要关心的；死循环是程序员要关心的；

## 死锁产生的四个条件：

~~~
资源必须是互斥的，不是共享的；
~~~

![image-20230804153745075](D:\typora笔记\操作系统笔记图片\image-20230804153745075.png)		

~~~
不能被抢夺，只能主动释放
~~~

![image-20230804153825904](D:\typora笔记\操作系统笔记图片\image-20230804153825904.png)	

~~~
请求新的资源，同时手里又占有其他资源
~~~

![image-20230804153856794](D:\typora笔记\操作系统笔记图片\image-20230804153856794.png)	

~~~
所需的资源之间，存在循环等待链【即形成了环】
~~~

![image-20230804153936886](D:\typora笔记\操作系统笔记图片\image-20230804153936886.png)	

## 死锁的解决方案：

![image-20230804154150229](D:\typora笔记\操作系统笔记图片\image-20230804154150229.png)	

## 小结：

![image-20230804154207522](D:\typora笔记\操作系统笔记图片\image-20230804154207522.png)	

~~~c
//循环等待不一定产生死锁，死锁一定存在循环等待；
~~~

------



## 死锁处理策略-预防：

![image-20230804154323100](D:\typora笔记\操作系统笔记图片\image-20230804154323100.png)	

### 破坏互斥条件：

~~~
SPOOLing技术：让互斥资源收到请求后，马上响应，让进程不用等待去做其他事。  

【类似于异步处理】
~~~

![image-20230804154503044](D:\typora笔记\操作系统笔记图片\image-20230804154503044.png)	

### 不剥夺条件：

![image-20230804154642039](D:\typora笔记\操作系统笔记图片\image-20230804154642039.png)	

![image-20230804154657157](D:\typora笔记\操作系统笔记图片\image-20230804154657157.png)	

~~~
CPU资源被强制剥夺后，之前工作的进程状态会被保存到PCB；
~~~



### 请求和保持条件的破坏：

~~~
一次必须拿到自己需要的所有资源
~~~

![image-20230804154828347](D:\typora笔记\操作系统笔记图片\image-20230804154828347.png)	

~~~
容易导致其他进程饥饿，运行效率慢；【一段时间内，这个资源必须专属于一个进程】
~~~

![image-20230804154918797](D:\typora笔记\操作系统笔记图片\image-20230804154918797.png)	

### 循环等待--破坏：

~~~
对资源进行编号分级，使不同级别的资源形成上下限制关系；
~~~

![image-20230804155107738](D:\typora笔记\操作系统笔记图片\image-20230804155107738.png)	

#### 缺点：

~~~c
1 加入新的资源就要全部重新编号；
2 用户编写程序麻烦；
3 进程实际使用资源的编号顺序可能和编号递增的顺序不一致，//容易导致中间编号资源的浪费；
~~~

------



## 避免死锁：

![image-20230804155522623](D:\typora笔记\操作系统笔记图片\image-20230804155522623.png)	

### 安全序列+银行家算法：

~~~
借了B之后就不安全了
~~~

![image-20230804155750347](D:\typora笔记\操作系统笔记图片\image-20230804155750347.png)	

~~~
安全序列：
~~~

![image-20230804155928439](D:\typora笔记\操作系统笔记图片\image-20230804155928439.png)	

### 安全序列，不安全状态，死锁：

![image-20230804160153229](D:\typora笔记\操作系统笔记图片\image-20230804160153229.png)	

### 银行家算法核心：

~~~
在分配资源之前，判断是否会进入不安全状态；
~~~

### 寻找安全序列：

~~~
只需要不断循环对比，判断手头上的资源分配出去之后，能否满足其他对象的资源，并且保证资源数量状态 是安全的（富裕的），不行则不分配。
~~~

#### 不安全状态举例：

![image-20230804160653166](D:\typora笔记\操作系统笔记图片\image-20230804160653166.png)	

### 代码实现：

![image-20230804161010349](D:\typora笔记\操作系统笔记图片\image-20230804161010349.png)	

![image-20230804161126292](D:\typora笔记\操作系统笔记图片\image-20230804161126292.png)	

~~~c++
//代码实现 c++
~~~

~~~java
//代码实现 java
~~~

------



## 死锁检测，解除：

![image-20230804161359339](D:\typora笔记\操作系统笔记图片\image-20230804161359339.png)	

~~~
使用图 数据结构，分析死锁状态：
~~~

![image-20230804161611888](D:\typora笔记\操作系统笔记图片\image-20230804161611888.png)	

### 死锁案例：

![image-20230804161915993](D:\typora笔记\操作系统笔记图片\image-20230804161915993.png)	

~~~
P2进程已经被【绿线】分配了一个R1资源，有发起【蓝线】请求一个R1；

而R1剩余的两个资源全都给了P1，因此P2进入等待；
~~~

### 检测死锁的算法：

![image-20230804162337058](D:\typora笔记\操作系统笔记图片\image-20230804162337058.png)	

### 死锁解除：

![image-20230804162435542](D:\typora笔记\操作系统笔记图片\image-20230804162435542.png)	

![image-20230804162545209](D:\typora笔记\操作系统笔记图片\image-20230804162545209.png)	

#### 如何决定对哪个进程进行解除操作：

![image-20230804162616459](D:\typora笔记\操作系统笔记图片\image-20230804162616459.png)	

### 小结：

![image-20230804162654286](D:\typora笔记\操作系统笔记图片\image-20230804162654286.png)	

------



# 内存：

## 基础概念：

![image-20230804163100136](D:\typora笔记\操作系统笔记图片\image-20230804163100136.png)	

![image-20230804163437049](D:\typora笔记\操作系统笔记图片\image-20230804163437049.png)	

~~~c
这个意思就是说cpu一次最多能够处理 32 位的数据，而2^32能够表示的内存大小为4G，因此内存最大支持4G

CPU的"位数"指的是它的寻址能力和数据处理能力。32位和64位是两种常见的CPU位数。

32位CPU能够使用32位的寻址空间，即它可以识别和管理的内存地址数量为2^32（因为存在 0 1 两个，所以是2的次方），约为4GB（Gigabytes）。这意味着32位CPU在理论上最多只能支持4GB的内存。实际上，由于一些地址空间需要用于其他系统资源，例如显存、IO端口等，所以32位CPU实际可用的内存会略低于4GB。

64位CPU则具有更大的寻址空间，能够使用64位的内存地址，即可以识别和管理的内存地址数量为2^64，这是一个极其巨大的数字。理论上，64位CPU可以支持的最大内存容量极高，远超目前的实际需求。这使得64位系统在处理大量内存需求的应用程序，如大型数据库、科学计算和虚拟化环境中表现更为出色。

总结起来：

- 32位CPU支持最多约4GB的内存。
- 64位CPU理论上可以支持非常大的内存容量，超出目前的实际需求。

//为什么支持的内存大小是2的次方？
例如，一个8位二进制数可以表示256个不同的值（2^8），所以一个8位地址总线可以寻址256个内存位置。同样，32位地址总线可以寻址2^32（约为40亿）个内存位置，而64位地址总线可以寻址2^64个内存位置，这是一个极大的数量。
~~~

### CPU执行指令的过程：

~~~
汇编语言：获取地址对应的数据，进行+1操作，存放计算完成后的结果；
~~~

![image-20230804164213880](D:\typora笔记\操作系统笔记图片\image-20230804164213880.png)	

### 逻辑地址，物理地址：

~~~
逻辑地址：相对于当前进程起始地址的位置；

物理地址：逻辑地址+偏移量（例如这里的进程，起始地址100，偏移量就是100，物理地址就是100+79）
~~~

![image-20230804164554356](D:\typora笔记\操作系统笔记图片\image-20230804164554356.png)	

### 逻辑地址装入物理地址的方式：

### 绝对装入：

~~~
编译时就知道要放到哪个物理地址
~~~

![image-20230804164845475](D:\typora笔记\操作系统笔记图片\image-20230804164845475.png)	

### 静态重定位：

~~~
运行作业时，一开始就分配 所需要的所有空间
~~~

![image-20230804164939680](D:\typora笔记\操作系统笔记图片\image-20230804164939680.png)	

### 动态重定位：

~~~
在程序将要运行时，才计算物理地址
~~~

![image-20230804165144790](D:\typora笔记\操作系统笔记图片\image-20230804165144790.png)	

![image-20230804165212825](D:\typora笔记\操作系统笔记图片\image-20230804165212825.png)	为什么可以不连续？

### 程序运行流程：（简略，看小林的详细

![image-20230804165357169](D:\typora笔记\操作系统笔记图片\image-20230804165357169.png)	

### 小结：

![image-20230804165429987](D:\typora笔记\操作系统笔记图片\image-20230804165429987.png)	

## 内存管理（要做的事：

![image-20230805194044836](D:\typora笔记\操作系统笔记图片\image-20230805194044836.png)	

### 内存保护：

#### 上下限寄存器：

![image-20230805193821986](D:\typora笔记\操作系统笔记图片\image-20230805193821986.png)	

#### 重定位寄存器限制：

![image-20230805193939214](D:\typora笔记\操作系统笔记图片\image-20230805193939214.png)	

### 小结：

![image-20230805194002283](D:\typora笔记\操作系统笔记图片\image-20230805194002283.png)	

------

## 覆盖与交换：

### 覆盖：

![image-20230805194830524](D:\typora笔记\操作系统笔记图片\image-20230805194830524.png)	

### 案例：

![image-20230805195004496](D:\typora笔记\操作系统笔记图片\image-20230805195004496.png)	

缺点：

![image-20230805195034453](D:\typora笔记\操作系统笔记图片\image-20230805195034453.png)	

### 交换：

![image-20230806191323053](D:\typora笔记\操作系统笔记图片\image-20230806191323053.png)	

#### 外存的哪个位置保存换出的进程？【对换区的速度比文件区快   未解答】

![image-20230806191528562](D:\typora笔记\操作系统笔记图片\image-20230806191528562.png)	**对换区的速度比文件区快：**

![image-20230806191452926](D:\typora笔记\操作系统笔记图片\image-20230806191452926.png)	

#### 啥时候换出？换出哪些进程？

![image-20230806191635443](D:\typora笔记\操作系统笔记图片\image-20230806191635443.png)	

### 小结：

![image-20230806191651097](D:\typora笔记\操作系统笔记图片\image-20230806191651097.png)	

------



## 连续分配管理方式：

![image-20230806191815458](D:\typora笔记\操作系统笔记图片\image-20230806191815458.png)	

### 单一连续分配：（古董

![image-20230806192038971](D:\typora笔记\操作系统笔记图片\image-20230806192038971.png)	

### 固定分区分配：（古董

![image-20230806192214090](D:\typora笔记\操作系统笔记图片\image-20230806192214090.png)	

![image-20230806192240324](D:\typora笔记\操作系统笔记图片\image-20230806192240324.png)	



### 动态分区分配：（现代

![image-20230806192443403](D:\typora笔记\操作系统笔记图片\image-20230806192443403.png)	

#### 内存使用情况记录 【两种方式】：

![image-20230806192618706](D:\typora笔记\操作系统笔记图片\image-20230806192618706.png)	

#### 应该使用哪个分区？

~~~
根据动态分区算法
~~~

#### 如何分配和回收？

分配情况一：使用了一部分

![image-20230806192834502](D:\typora笔记\操作系统笔记图片\image-20230806192834502.png)	

分配情况二：刚好使用了一块

![image-20230806192910814](D:\typora笔记\操作系统笔记图片\image-20230806192910814.png)	

**回收情况一：**

![image-20230806193202421](D:\typora笔记\操作系统笔记图片\image-20230806193202421.png)	回收4m空间，且相邻

![image-20230806193003606](D:\typora笔记\操作系统笔记图片\image-20230806193003606.png)	

回收情况二：合并三块内存分区

![image-20230806193318528](D:\typora笔记\操作系统笔记图片\image-20230806193318528.png)	

### 内部，外部碎片：

![image-20230806193436530](D:\typora笔记\操作系统笔记图片\image-20230806193436530.png)	

### 小结：

![image-20230806193449486](D:\typora笔记\操作系统笔记图片\image-20230806193449486.png)	

------

## 动态分区分配算法：

![image-20230806193535015](D:\typora笔记\操作系统笔记图片\image-20230806193535015.png)	

### 首次适应算法：

![image-20230806193708401](D:\typora笔记\操作系统笔记图片\image-20230806193708401.png)	



### 最佳适应算法：

![image-20230806193746904](D:\typora笔记\操作系统笔记图片\image-20230806193746904.png)	

![image-20230806193806653](D:\typora笔记\操作系统笔记图片\image-20230806193806653.png)	



### 最坏适应算法：

![image-20230806193843160](D:\typora笔记\操作系统笔记图片\image-20230806193843160.png)	

![image-20230806193857502](D:\typora笔记\操作系统笔记图片\image-20230806193857502.png)	



### 邻近适应算法：

![image-20230806194012589](D:\typora笔记\操作系统笔记图片\image-20230806194012589.png)	

![image-20230806194033940](D:\typora笔记\操作系统笔记图片\image-20230806194033940.png)	

### 小结：

![image-20230806194050806](D:\typora笔记\操作系统笔记图片\image-20230806194050806.png)	

------

## 分页存储管理：

![image-20230806194406839](D:\typora笔记\操作系统笔记图片\image-20230806194406839.png)

### 块号所占的大小示例：	

![image-20230806194555059](D:\typora笔记\操作系统笔记图片\image-20230806194555059.png)	

![image-20230806194831734](D:\typora笔记\操作系统笔记图片\image-20230806194831734.png)	

![image-20230806194958393](D:\typora笔记\操作系统笔记图片\image-20230806194958393.png)	

### 页号所占的空间：

~~~
页号是作为隐含的数据，没有实际存储在内存中  【就像数组的下标，也是没存储的】
~~~

![image-20230806194619007](D:\typora笔记\操作系统笔记图片\image-20230806194619007.png)	

### 地址转换：

![image-20230806195113498](D:\typora笔记\操作系统笔记图片\image-20230806195113498.png)	

### 分页存放：

![image-20230806195159506](D:\typora笔记\操作系统笔记图片\image-20230806195159506.png)	

### 确定页号，页内偏移量：

![image-20230806195409881](D:\typora笔记\操作系统笔记图片\image-20230806195409881.png)	

#### 计算机内部，二进制计算：

~~~
页号就收前20位，页内偏移量就是后12位；
~~~

![image-20230806195536578](D:\typora笔记\操作系统笔记图片\image-20230806195536578.png)	

![image-20230806195622211](D:\typora笔记\操作系统笔记图片\image-20230806195622211.png)	因此计算机硬件直接取位数，不需要做额外操作提取信息

------

### 以计算4097的物理地址为例：

如果页面大小刚好是2的整数次幂，则可以使用结论的算法；

反之如果不是2的整数次幂，就需要使用【J * 起始地址】的方式；

![image-20230806195818880](D:\typora笔记\操作系统笔记图片\image-20230806195818880.png)	

------

### 逻辑地址结构：

![image-20230806200656577](D:\typora笔记\操作系统笔记图片\image-20230806200656577.png)	

------

### 小结：

![image-20230806200811261](D:\typora笔记\操作系统笔记图片\image-20230806200811261.png)	

------

## 基本地址变换机构：

![image-20230806201414989](D:\typora笔记\操作系统笔记图片\image-20230806201414989.png)	

![image-20230806201555727](D:\typora笔记\操作系统笔记图片\image-20230806201555727.png)	

### 易混淆的概念：

![image-20230806201648725](D:\typora笔记\操作系统笔记图片\image-20230806201648725.png)	

~~~
如果是二的整数幂，计算机直接拼接就可以了  [像上一节提过的]
~~~

### 题目举例：

![image-20230806201830277](D:\typora笔记\操作系统笔记图片\image-20230806201830277.png)	

### 页表项长度：

![image-20230806202101724](D:\typora笔记\操作系统笔记图片\image-20230806202101724.png)	

![image-20230806202241410](D:\typora笔记\操作系统笔记图片\image-20230806202241410.png)	

~~~c
//内存按页分块，页表中的页表项，自然也是存放在按页分块的  内存页  中的，
~~~

### 页表的存储：【看小林的文章】

~~~
在一个 4GB 的内存空间中，如果使用固定大小的页面（页），比如常见的 4KB 大小的页面，那么总共有 4GB / 4KB = 1M 个页。因此，需要 1M 个页表项来映射这些页面。每个页表项存储一个虚拟页号和对应的物理页号的映射关系。

在 Linux 系统中，页表是在进程运行时由操作系统内核创建和维护的。当一个新的进程被创建，或者进程切换发生时，操作系统会为该进程创建页表。具体创建页表的过程如下：

1. 进程创建：当一个新的进程被创建时，操作系统会为该进程分配一个独立的虚拟地址空间。这个虚拟地址空间是 4GB 大小的，但实际上进程并没有真正占用这么多内存。

2. 初始化页表：在进程创建时，操作系统会为该进程初始化一个空的页表。这个页表暂时不包含任何有效的映射关系，所有的页表项都被设置为无效状态。

3. 内存分配：当进程开始运行，并申请内存时（比如使用 malloc() 或 new 进行内存分配），操作系统会根据申请的大小，分配相应数量的页面，并在页表中添加映射关系，将虚拟地址映射到物理内存地址。

4. 换页：当进程访问一个虚拟地址，并且对应的物理页面不在内存中（页缺失），操作系统会进行换页操作，将缺失的页面从磁盘加载到内存，并更新页表中的映射关系。

5. 进程切换：当操作系统进行进程切换，将 CPU 的控制权从一个进程切换到另一个进程时，操作系统会切换页表，加载新进程的页表，以便新进程可以继续运行。

总结起来，Linux 系统中的页表是在进程运行时根据进程的需求动态创建和维护的。页表中的映射关系随着进程的运行和内存分配动态变化。操作系统通过页表实现了虚拟内存的管理，使得每个进程都拥有独立的虚拟地址空间，同时可以共享实际的物理内存。这样，操作系统可以更高效地管理内存，并实现了虚拟内存的抽象。
~~~

### 【看小林的文章】

~~~
在 Linux 系统中，页表是用来管理虚拟内存和物理内存映射关系的数据结构，它们是操作系统内核维护的重要数据。在 x86 架构的处理器上，Linux 采用多级页表（也称为分层页表）的方式来组织和存储页表信息。每级页表的数据结构和存储方式如下：

1. 第一级页表（页目录）：在 x86 架构中，第一级页表通常称为页目录。页目录是一个由 1024 个页目录项组成的数组，每个页目录项占用 4 字节。每个页目录项指向一个第二级页表（或者称为页表），并提供了物理内存地址。

2. 第二级页表（页表）：第二级页表是由 1024 个页表项组成的数组，每个页表项也占用 4 字节。每个页表项指向实际的物理页面，同时包含了一些控制位来标识页面的属性，例如是否可读、是否可写、是否已加载等。

当一个程序运行时，操作系统会为该程序创建一个页表来管理其虚拟内存地址到物理内存地址的映射关系。这些页表信息存储在操作系统内核的内存空间中，通常位于操作系统的内核区域。

需要注意的是，由于虚拟内存空间可能很大，每个进程都有独立的页表，直接存储所有的页表项会占用大量内存。为了减小页表的大小和内存开销，Linux 采用了一种称为“全局页表”和“分区页表”的混合方式。在全局页表中，操作系统只创建一个全局的一级页表，用来管理整个内存空间的大部分映射关系。而在分区页表中，操作系统为每个进程创建独立的第二级页表，用来管理各个进程的虚拟内存映射。

这种混合的页表管理方式，使得操作系统能够有效地管理虚拟内存和物理内存的映射关系，同时减小了内存开销。不过，具体的页表结构和管理方式可能会因操作系统版本、处理器架构等而有所不同。
~~~



### 小结：

![image-20230806202322076](D:\typora笔记\操作系统笔记图片\image-20230806202322076.png)	

------

## 具有快表的地址变换机构：

![image-20230806205303203](D:\typora笔记\操作系统笔记图片\image-20230806205303203.png)	

### 快表：

![image-20230806205333958](D:\typora笔记\操作系统笔记图片\image-20230806205333958.png)	

![image-20230806205349907](D:\typora笔记\操作系统笔记图片\image-20230806205349907.png)	

### 有快表的情况（快表是一个硬件

![image-20230806205625685](D:\typora笔记\操作系统笔记图片\image-20230806205625685.png)	

### 注意绿色框：就类似于缓存的效果

![image-20230806205729901](D:\typora笔记\操作系统笔记图片\image-20230806205729901.png)	

同时查快表，慢表； 先快表，再慢表；

![image-20230806205819338](D:\typora笔记\操作系统笔记图片\image-20230806205819338.png)	

### 快表提升效率的原因：

![image-20230806205919716](D:\typora笔记\操作系统笔记图片\image-20230806205919716.png)	

### 小结：

![image-20230806205949480](D:\typora笔记\操作系统笔记图片\image-20230806205949480.png)	

------



## 两级页表：

### 单级页表存在的问题：

- 32 位 CPU 一次可以计算 4 个字节；（图中有误）
- 64 位 CPU 一次可以计算 8 个字节；

~~~
一个大小为 4KB 的内存，可以用 12 位来表示。

为了将大小转换为位数，我们需要将大小转换为比特（Bit），因为位是计算机存储的最小单位。

1 字节（Byte）等于 8 位（Bit），所以 4KB 等于 4 * 1024 字节，即 4 * 1024 * 8 = 32768 位。

因此，一个大小为 4KB 的内存可以用 32768 位或者 12 位来表示。
~~~

~~~c
1. 页内地址需要用 12 位表示：
   因为一个页面的大小为 4KB，也就是 4 * 1024 字节。一个字节需要用 8 位来表示，所以一个页面的大小为 4 * 1024 * 8 = 32,768 位。为了表示页面内的地址，我们可以用 32,768 位的二进制数来表示，其中有效地址范围为 0 到 4KB-1，即 0 到 2^12-1。因此，需要 12 位二进制数来表示页内地址。

2. 页号需要用 20 位表示：
   页号是用来标识不同页面的索引或编号。在一个页表中，页号可以看作是页面的标签。如果一个页表能够管理的页面总数为 N，那么页号需要用 log2(N) 位来表示。
   
   我们假设计算机的总可寻址内存空间为 4GB，页面大小为 4KB。总内存空间为 4GB（4 * 1024 * 1024 * 1024 字节），页面大小为 4KB（4 * 1024 字节）。计算页面总数 N = (4 * 1024 * 1024 * 1024) / (4 * 1024) = 1,048,576。 //这里是通过总内存算出了 内存会被划分的页数量，为20页

   因此，页号需要用 log2(1,048,576) ≈ 20 位来表示。

正确的总结：

- 页内地址需要用 12 位表示（12 位 ≈ log2(4KB)）。
- 页号需要用 20 位表示（20 位 ≈ log2(1,048,576)）。
    
//这就意味着一个进程最多有 20 个页面（也就是要管理20个页表项，一个页表项4B，需要2^22B的空间存储页表，
    //而内存中一个页面最多4KB，即2^22位，需要10个页框才能存储所有的页表项；
~~~

![image-20230808223123153](D:\typora笔记\操作系统笔记图片\image-20230808223123153.png)	

![image-20230808225522746](D:\typora笔记\操作系统笔记图片\image-20230808225522746.png)	

### 解决上述两个问题：

将单个页表拆分为二级页表管理；

![image-20230808225944711](D:\typora笔记\操作系统笔记图片\image-20230808225944711.png)	

~~~c
//此时就可以不必一次将所有页表加载进页表项，因为进程在一段时间内，只会访问局部的一块页表（页表项的顺序是连续的，根据局部性原理可知），只要在需要时，判断对应页表是否在内存中，不在则调入；
~~~

![image-20230808230235827](D:\typora笔记\操作系统笔记图片\image-20230808230235827.png)	

![image-20230808230426506](D:\typora笔记\操作系统笔记图片\image-20230808230426506.png)	

### 小结：

![image-20230808230441015](D:\typora笔记\操作系统笔记图片\image-20230808230441015.png)	

------



## 基本分段存储管理：

~~~
使用段 对内存进行管理分配：
~~~

![image-20230808230927760](D:\typora笔记\操作系统笔记图片\image-20230808230927760.png)	

![image-20230808231100016](D:\typora笔记\操作系统笔记图片\image-20230808231100016.png)	

### 段表：

看蓝色框：

![image-20230808231252921](D:\typora笔记\操作系统笔记图片\image-20230808231252921.png)	

每个段表项的段长是不同的，不像分页那样，每页都大小一致。

这里假设段号为16位，则16段号一定能够被均匀的表示4GB内存；基址表示内存的起始地址，因此需要32位表示，因为4GB内存位2^32次方；



### 段中的地址偏移计算：

![image-20230808233313753](D:\typora笔记\操作系统笔记图片\image-20230808233313753.png)	

### 和分页的区别：

蓝色框：

![image-20230808233543987](D:\typora笔记\操作系统笔记图片\image-20230808233543987.png)	

#### 分段的优点：

~~~
可以将程序进行分段管理，程序中允许共享的逻辑  使用单独一个段存放

【纯代码】【可重入代码】
~~~

![image-20230808233804377](D:\typora笔记\操作系统笔记图片\image-20230808233804377.png)	

![image-20230808233901285](D:\typora笔记\操作系统笔记图片\image-20230808233901285.png)	

### 分段逻辑地址需要变化的次数：：

![image-20230808234018353](D:\typora笔记\操作系统笔记图片\image-20230808234018353.png)	

### 小结：

![image-20230808234047873](D:\typora笔记\操作系统笔记图片\image-20230808234047873.png)	

------



## 段页式管理方式：

### 两种管理方式的优缺点：

![image-20230808234528696](D:\typora笔记\操作系统笔记图片\image-20230808234528696.png)	

~~~c
//注意：页表存放块号的概念；
~~~

![image-20230808234901368](D:\typora笔记\操作系统笔记图片\image-20230808234901368.png)	

~~~
将段和页的优点结合管理内存；
~~~

需要访问三次缓存进行地址变换：

~~~
较长的段需要使用多个页块，对应一个页表，长度为n；找到页表后，在根据页号和页内偏移地址，转为物理地址
~~~

![image-20230808235123332](D:\typora笔记\操作系统笔记图片\image-20230808235123332.png)	

### 小结：

![image-20230808235159641](D:\typora笔记\操作系统笔记图片\image-20230808235159641.png)	

------

## 虚拟内存：

### 传统内存管理方式：

![image-20230809002231123](D:\typora笔记\操作系统笔记图片\image-20230809002231123.png)	

### 局部性原理：

![image-20230809002331854](D:\typora笔记\操作系统笔记图片\image-20230809002331854.png)	

### 虚拟内存：

![image-20230809002359524](D:\typora笔记\操作系统笔记图片\image-20230809002359524.png)	

#### 三个特征：

![image-20230809002514261](D:\typora笔记\操作系统笔记图片\image-20230809002514261.png)	

### 虚拟内存实现过程：

~~~
依赖于内存离散分配
~~~

![image-20230809002657030](D:\typora笔记\操作系统笔记图片\image-20230809002657030.png)

~~~
请求的内存管理
~~~

![image-20230809002728200](D:\typora笔记\操作系统笔记图片\image-20230809002728200.png)	

### 小结：

![image-20230809002759370](D:\typora笔记\操作系统笔记图片\image-20230809002759370.png)	

------

## 请求分页管理方式：

### 和基本分页的区别：

![image-20230809003029089](D:\typora笔记\操作系统笔记图片\image-20230809003029089.png)	

### 页表：增加了四个字段

![image-20230809003236500](D:\typora笔记\操作系统笔记图片\image-20230809003236500.png)	

~~~
访问字段；
修改位：如果调入内存后没有被修改过，就不需要写回外存；
~~~

### 缺页中断：

~~~
属于故障
~~~

![image-20230809003458601](D:\typora笔记\操作系统笔记图片\image-20230809003458601.png)	

### 地址变换机构：

![image-20230809003742542](D:\typora笔记\操作系统笔记图片\image-20230809003742542.png)	

![image-20230809003931216](D:\typora笔记\操作系统笔记图片\image-20230809003931216.png)	

![image-20230809003956119](D:\typora笔记\操作系统笔记图片\image-20230809003956119.png)	

~~~
【写指令】修改 修改位，删除快表数据
~~~

![image-20230809004154949](D:\typora笔记\操作系统笔记图片\image-20230809004154949.png)	

### 小结：

![image-20230809004307991](D:\typora笔记\操作系统笔记图片\image-20230809004307991.png)	

------

## 页面置换算法：

![image-20230809004409451](D:\typora笔记\操作系统笔记图片\image-20230809004409451.png)	

### 最佳置换算法：

~~~
现实中无法实现
~~~

![image-20230809004532400](D:\typora笔记\操作系统笔记图片\image-20230809004532400.png)	

~~~
缺页中断发生了9次，页面置换发生了6次；
缺页率 9/20=25
~~~



### 先进先出置换：

![image-20230809004756199](D:\typora笔记\操作系统笔记图片\image-20230809004756199.png)	



### LRU：最近最久未使用：

~~~
依赖于硬件实现
~~~

![image-20230809004956056](D:\typora笔记\操作系统笔记图片\image-20230809004956056.png)	



### 时钟置换算法：

~~~
将内存块链接为一个环，当内存块满时，检查当前内存中的内存块哪个没有被访问过，如果为1在检查后改为0；

这里6需要进入内存，经过一圈检查全都变为0了，此时再重新检查一圈，1号为0，因此1被替换为6
~~~

![image-20230809005217644](D:\typora笔记\操作系统笔记图片\image-20230809005217644.png)	

### 改进型：

![image-20230809005544891](D:\typora笔记\操作系统笔记图片\image-20230809005544891.png)		

![image-20230809005515274](D:\typora笔记\操作系统笔记图片\image-20230809005515274.png)	

### 小结：

![image-20230809005606388](D:\typora笔记\操作系统笔记图片\image-20230809005606388.png)	

------



## 页面分配策略，抖动，工作集：

### 驻留集：

![image-20230818003303510](D:\typora笔记\操作系统笔记图片\image-20230818003303510.png)	

~~~
驻留集就是分配给进程的内存（页）集合；
~~~

![image-20230818003456355](D:\typora笔记\操作系统笔记图片\image-20230818003456355.png)	

### 三种页面置换策略：

![image-20230818003811927](D:\typora笔记\操作系统笔记图片\image-20230818003811927.png)	

~~~
进程刚开始运行，物理块数量就是确定的，当发生缺页，只能局部置换；
~~~

![image-20230818003857541](D:\typora笔记\操作系统笔记图片\image-20230818003857541.png)	

~~~
有一部分空闲的物理块，在进程发生缺页时，从中分配给进程。全部分配完了，并且发生缺页，就开始选择系统内存中任意一个未锁定的页面换出。
~~~

![image-20230818004132977](D:\typora笔记\操作系统笔记图片\image-20230818004132977.png)	

~~~
和上一个相比的区别就是  发生缺页，只能从当前进程自己的物理块中选一个换出，不能动其他进程的（也就是不能动全局）

并且根据缺页次数，动态的分配物理块；
~~~

![image-20230818004116752](D:\typora笔记\操作系统笔记图片\image-20230818004116752.png)	

------



### 调入页面的时机：

![image-20230818010310436](D:\typora笔记\操作系统笔记图片\image-20230818010310436.png)	

![image-20230818010327123](D:\typora笔记\操作系统笔记图片\image-20230818010327123.png)	

### 调入页面的位置（三种方式：

![image-20230818010541631](D:\typora笔记\操作系统笔记图片\image-20230818010541631.png)	

------

### 抖动：

~~~
频繁的页面调度
~~~

![image-20230818010641443](D:\typora笔记\操作系统笔记图片\image-20230818010641443.png)	

### 工作集：

![image-20230818010809450](D:\typora笔记\操作系统笔记图片\image-20230818010809450.png)	

![image-20230818010850306](D:\typora笔记\操作系统笔记图片\image-20230818010850306.png)	

### 小结：

![image-20230818010909486](D:\typora笔记\操作系统笔记图片\image-20230818010909486.png)	

------



## 内存映射文件：

### 传统文件访问方式：

![image-20230818011241491](D:\typora笔记\操作系统笔记图片\image-20230818011241491.png)	

### 内存映射文件：

![image-20230818011415071](D:\typora笔记\操作系统笔记图片\image-20230818011415071.png)	

~~~
进程中的虚拟地址映射到真实的文件物理地址；

程序员只需要知道起始地址，就可以访问对应文件；

例如这里要读取2页面时，此时实际的数据还没有读入内存，只是映射关系，则发生缺页中断，由操作系统将文件读出，不需要像传统方式一样，手动将文件读出；

文件修改后，程序员直接关闭文件即可，操作系统自动写回；
~~~

~~~c
//两份进程，通过虚拟映射指向同一个物理地址，使这两个进程共享
~~~

![image-20230818011806074](D:\typora笔记\操作系统笔记图片\image-20230818011806074.png)	

------



## 文件管理：

## 基础：

![image-20230818012152229](D:\typora笔记\操作系统笔记图片\image-20230818012152229.png)	![image-20230818012319621](D:\typora笔记\操作系统笔记图片\image-20230818012319621.png)	

### 操作系统提供的功能：

![image-20230818012410539](D:\typora笔记\操作系统笔记图片\image-20230818012410539.png)	

~~~
外存文件存放：
~~~

![image-20230818012535351](D:\typora笔记\操作系统笔记图片\image-20230818012535351.png)	

### 小结：

![image-20230818012558510](D:\typora笔记\操作系统笔记图片\image-20230818012558510.png)	

------

## 文件逻辑结构：

![image-20230818012817956](D:\typora笔记\操作系统笔记图片\image-20230818012817956.png)	

![image-20230818012852609](D:\typora笔记\操作系统笔记图片\image-20230818012852609.png)	

### 顺序文件：

![image-20230818013255529](D:\typora笔记\操作系统笔记图片\image-20230818013255529.png)	

![image-20230818013336784](D:\typora笔记\操作系统笔记图片\image-20230818013336784.png)	

~~~
串结构，没有按照关键字排序；
顺序结构：按照关键字排序；
~~~

![image-20230818013641879](D:\typora笔记\操作系统笔记图片\image-20230818013641879.png)	

### 小结：

![image-20230818013702949](D:\typora笔记\操作系统笔记图片\image-20230818013702949.png)	

------

# 文件目录：

~~~
目录自身就是一个结构文件，每个目录都有一条对应的记录存储；
~~~

![image-20230822232509517](D:\typora笔记\操作系统笔记图片\image-20230822232509517.png)	

~~~
FCB--文件目录，一个FCB代表一个文件名目录项；
~~~

![image-20230822232700318](D:\typora笔记\操作系统笔记图片\image-20230822232700318.png)	

### 现代目录结构：

~~~
多级目录（最早是单级目录，二级目录）
~~~

![image-20230822232917238](D:\typora笔记\操作系统笔记图片\image-20230822232917238.png)	

## 索引：

~~~
fcb结构，在查找文件时，只需要根据文件名查找，找到后才会需要物理位置的信息。其他信息都暂时不需要；
~~~

![image-20230822233224033](D:\typora笔记\操作系统笔记图片\image-20230822233224033.png)	

![image-20230822233339859](D:\typora笔记\操作系统笔记图片\image-20230822233339859.png)	这样的FCB，多余的信息会占用空间，导致浪费

~~~
因此使用索引优化，只需要存放文件名即可；

·可减少目录项的占用空间；加快检索速度；
~~~

![image-20230822233504759](D:\typora笔记\操作系统笔记图片\image-20230822233504759.png)	

![image-20230822233522977](D:\typora笔记\操作系统笔记图片\image-20230822233522977.png)	

## 小结：

![image-20230822233623226](D:\typora笔记\操作系统笔记图片\image-20230822233623226.png)	

------

# 文件分配方式（物理结构）

![image-20230822233739345](D:\typora笔记\操作系统笔记图片\image-20230822233739345.png)	

~~~
磁盘中的空间：在使用时，是被分为多个磁盘块来使用的；
~~~

## 连续分配的方式：

![image-20230822234328621](D:\typora笔记\操作系统笔记图片\image-20230822234328621.png)	

~~~
文件在磁盘上占有一组连续的磁盘块  像这里的 4---6
物理块号=起始块号+逻辑块号；
支持顺序访问和随机访问；
~~~

~~~
上图的三个内存块，使用机械硬盘时，磁头要访问这个文件时，由于磁盘块是连续的，磁头不需要移动很长的距离；
因此这种方式顺序读写时最快；
~~~

![image-20230822234647034](D:\typora笔记\操作系统笔记图片\image-20230822234647034.png)	

~~~
如果连续的磁盘块不足时，只能全部迁移到其他连续空间，耗费大量资源；
~~~

## 链接分配方式：

### 隐式链接：

![image-20230822234948301](D:\typora笔记\操作系统笔记图片\image-20230822234948301.png)	

~~~
每个磁盘块都需要存储下一个块的指针空间；
不支持随机访问，要访问第i块，必须访问前面i-1块；
~~~

### 显式链接：

~~~
把各个文件块的指针存放在一张表中管理；
~~~

![image-20230822235221583](D:\typora笔记\操作系统笔记图片\image-20230822235221583.png)	

~~~
一个磁盘设置一张FAT表，开机时读入内存，并且常驻内存；
~~~

~~~
支持随机访问，要访问某个块，直接查表即可；
逻辑块号转换为物理块号不需要读磁盘；
~~~

![image-20230822235401410](D:\typora笔记\操作系统笔记图片\image-20230822235401410.png)	

## 索引分配：

~~~
每个文件都会有一个索引表；
~~~

例如文件aaa：这个文件内容存放在 2 5 13 9这四个磁盘块，索引存在了7磁盘块

![image-20230823000140491](D:\typora笔记\操作系统笔记图片\image-20230823000140491.png)	

![image-20230823000221202](D:\typora笔记\操作系统笔记图片\image-20230823000221202.png)	

~~~
其中逻辑块号可以是隐含的，用下标代替；
操作系统查找文件时，只需要查找索引表中的索引块号，再根据索引块中的表查询

支持随机访问；文件扩展；
索引表需要占用空间；
【空间换时间】
~~~



**文件过大，一个磁盘块存不下这个文件的索引表：**

~~~
将索引块使用链接存放；

文件过大，如果要访问文件的最后一个磁盘块，需要读取多个索引磁盘块才能能读到，太慢了；
~~~



### 多级索引：

~~~
和多级页表对应；
~~~

![image-20230823000931606](D:\typora笔记\操作系统笔记图片\image-20230823000931606.png)	

### 混合索引：

~~~
包含直接，一级，二级索引；

0~7号，读取两次磁盘就可以访问到；
~~~

![image-20230823001257664](D:\typora笔记\操作系统笔记图片\image-20230823001257664.png)	

## 注意点：

![image-20230823001425418](D:\typora笔记\操作系统笔记图片\image-20230823001425418.png)	

## 小结：

![image-20230823001445333](D:\typora笔记\操作系统笔记图片\image-20230823001445333.png)	

------

# 文件存储空间管理：

![image-20230823001842637](D:\typora笔记\操作系统笔记图片\image-20230823001842637.png)	

![image-20230823001858800](D:\typora笔记\操作系统笔记图片\image-20230823001858800.png)	

## 存储空间划分，初始化：

~~~
红框部分注意；
~~~

![image-20230823002104874](D:\typora笔记\操作系统笔记图片\image-20230823002104874.png)	

## 空闲表法：

![image-20230823002354765](D:\typora笔记\操作系统笔记图片\image-20230823002354765.png)	![image-20230823002359459](D:\typora笔记\操作系统笔记图片\image-20230823002359459.png)	通过表记录最大的连续磁盘空间

~~~
适用于连续分配方式；
~~~

![image-20230823002455019](D:\typora笔记\操作系统笔记图片\image-20230823002455019.png)	

## 空闲链表法：

![image-20230823002725504](D:\typora笔记\操作系统笔记图片\image-20230823002725504.png)	

![image-20230823002636796](D:\typora笔记\操作系统笔记图片\image-20230823002636796.png)	

![image-20230823002750922](D:\typora笔记\操作系统笔记图片\image-20230823002750922.png)	

~~~
盘区比盘块回收效率更高，一个是一块一块回收，一个是一次回收一片；	
~~~

## 位图表示：

![image-20230823003149709](D:\typora笔记\操作系统笔记图片\image-20230823003149709.png)	

![image-20230823003157845](D:\typora笔记\操作系统笔记图片\image-20230823003157845.png)	

![image-20230823003222687](D:\typora笔记\操作系统笔记图片\image-20230823003222687.png)	

![image-20230823003228805](D:\typora笔记\操作系统笔记图片\image-20230823003228805.png)	这里以16位为例；

![image-20230823003258886](D:\typora笔记\操作系统笔记图片\image-20230823003258886.png)	

### 分配回收：

![image-20230823003348367](D:\typora笔记\操作系统笔记图片\image-20230823003348367.png)	

~~~
效率更高；
~~~

## 成组链接法：unix使用

![image-20230823003613540](D:\typora笔记\操作系统笔记图片\image-20230823003613540.png)	

![image-20230823003753273](D:\typora笔记\操作系统笔记图片\image-20230823003753273.png)	

~~~
当下一组没有空闲块时，设置特殊值：
~~~

![image-20230823003842432](D:\typora笔记\操作系统笔记图片\image-20230823003842432.png)	

### 分配空闲块：

![image-20230823004136751](D:\typora笔记\操作系统笔记图片\image-20230823004136751.png)	

~~~
这里300的空闲块中有100个空闲块可以分配出去

但是300还存了其他空闲块的位置信息
~~~

![image-20230823004203311](D:\typora笔记\操作系统笔记图片\image-20230823004203311.png)	

~~~
因此需要对300存储的信息复制：
~~~

![image-20230823004306068](D:\typora笔记\操作系统笔记图片\image-20230823004306068.png)	

![image-20230823004317776](D:\typora笔记\操作系统笔记图片\image-20230823004317776.png)	

### 回收：

![image-20230823004434695](D:\typora笔记\操作系统笔记图片\image-20230823004434695.png)	

![image-20230823004534007](D:\typora笔记\操作系统笔记图片\image-20230823004534007.png)	

## AI回答：

当挂载一个文件系统时，操作系统会读取超级块中的信息，以初始化文件系统的各种参数。以下是一个简化的字符画图表，用于说明超级块的作用：

```
--------------------------------------------------------------
|                     超级块 (Superblock)                    |
|------------------------------------------------------------|
| 文件系统类型：ext4             块大小：4KB                |
| 块组大小：8KB                文件系统容量：10GB           |
| 文件系统状态：已挂载             空闲块：500              |
| 索引节点总数：2000            空闲索引节点：100         |
|------------------------------------------------------------|
| 块组1                 块组2                 块组3           |
|------------------------------------------------------------|
| 位图      索引节点表  | 位图      索引节点表  | 位图      索引节点表 |
| 数据块      数据块  | 数据块      数据块  | 数据块      数据块 |
--------------------------------------------------------------
```

在这个字符画的示例中：

- 超级块包含了文件系统的基本信息，如文件系统类型、块大小、块组大小、文件系统容量等。
- 块组是文件系统的逻辑单元，每个块组包含一个或多个数据块和对应的元数据结构，如位图和索引节点表。
- 位图用于记录每个块的分配状态，0 表示空闲块，1 表示已分配块。
- 索引节点表存储了文件的元数据，如文件大小、访问权限等。
- 文件系统状态标识文件系统是否已挂载。
- 空闲块和空闲索引节点字段记录了文件系统中当前可用的空闲块和索引节点数量。

当操作系统需要创建、读取或写入文件时，它会使用超级块中的信息来管理块的分配和回收，以及索引节点的使用。超级块帮助操作系统了解文件系统的结构和状态，从而正确地进行文件系统的操作。

~~~
上图超级块中的【方格】就是一个个块组；
~~~

以下是一个简化的字符画图表，用于说明块组的作用：

```
----------------------------------------------------------
|                   块组1 (Block Group 1)                 |
|--------------------------------------------------------|
|  数据块  数据块  数据块  数据块  数据块  数据块  数据块   |
|   |        |        |         |        |        |        |
|   |        |        |         |        |        |        |
|--------------------------------------------------------|
|                   位图 (Bitmap)                       |
|--------------------------------------------------------|
|  0   1   0   1   1   0   0   1   0   1   1   1   0   0   |
|--------------------------------------------------------|
|              索引节点表 (Inode Table)                 |
|--------------------------------------------------------|
|  Inode 1  Inode 2  Inode 3  Inode 4  Inode 5  Inode 6  |
|--------------------------------------------------------|
|               其他元数据 (Block Group Desc.)            |
|--------------------------------------------------------|
|   ...                                                     |
----------------------------------------------------------
```

在这个字符画的示例中：

- 块组1（Block Group 1）包含了一组数据块，位图、索引节点表和其他元数据。
- 数据块（Data Blocks）用于存储文件实际的数据内容。
- 位图（Bitmap）记录了数据块的分配状态，0 表示空闲块，1 表示已分配块。
- 索引节点表（Inode Table）存储了块组中的索引节点，包括文件的元数据。
- 其他元数据（Block Group Descriptor）可能包含了块组的信息、校验和等。
- 不同的块组可以包含不同的数据块、位图和索引节点表，用于组织和管理文件系统的数据和元数据。

块组的作用在于更有效地管理磁盘空间，提高文件系统的性能和管理效率。通过将文件系统的数据和元数据划分为一组组块组，文件系统可以更好地组织和管理磁盘上的内容，从而减少碎片化、提高块的分配和回收效率，以及提高文件系统的整体性能。

~~~
通过位图记录还有哪些空闲的块；
~~~

~~~
假设每个块只能记录100个磁盘块的情况（记录空闲或不空闲，因为位图大小是有限的），因此对于大容量的磁盘，需要分多级存储；就类似于多级页表
~~~

## 小结：

![image-20230823010822800](D:\typora笔记\操作系统笔记图片\image-20230823010822800.png)	

------

# 文件基本操作：

~~~
太基础，没必要看，直接看小结
~~~

![image-20230823024836475](D:\typora笔记\操作系统笔记图片\image-20230823024836475.png)	

------

# 文件共享：

![image-20230823203219613](D:\typora笔记\操作系统笔记图片\image-20230823203219613.png)	

## 基于索引节点共享：

![image-20230823203423895](D:\typora笔记\操作系统笔记图片\image-20230823203423895.png)	

~~~
当两个用户共享一个文件，u1把这个文件取名aaa，u2取名bbb；

两个用户都在使用这个文件时，索引节点的count为2；
如果一个用户删除了这个文件，对于系统而言，只是把这个用户对这个文件的索引删除了，文件还在，并且count-1；

count=0时，文件被真正删除；
~~~

## 基于符号链共享：

![image-20230823203841309](D:\typora笔记\操作系统笔记图片\image-20230823203841309.png)	

~~~
link类型文件：
~~~

![image-20230823203942322](D:\typora笔记\操作系统笔记图片\image-20230823203942322.png)	

~~~
软连接，如果一个用户删除该link类型文件后，就真正删除了，其他用户访问不到了
~~~

## 小结：

![image-20230823204110982](D:\typora笔记\操作系统笔记图片\image-20230823204110982.png)	

------

# 文件保护：

~~~
不重要，直接小结
~~~

![image-20230824001131341](D:\typora笔记\操作系统笔记图片\image-20230824001131341.png)		

------

# 文件层次结构：

~~~
这张图涉及了文件章节的知识点顺序；从上到下，从文件到磁盘；
~~~



![image-20230824001504664](D:\typora笔记\操作系统笔记图片\image-20230824001504664.png)	

------

# 文件系统的全局结构：

## 物理格式化：

~~~
划分物理扇区
~~~

![image-20230824001806616](D:\typora笔记\操作系统笔记图片\image-20230824001806616.png)	

## 逻辑格式化：

~~~
将磁盘划分为多个逻辑卷（逻辑磁盘）
~~~

### unix系统为例：

![image-20230824002143781](D:\typora笔记\操作系统笔记图片\image-20230824002143781.png)	

## 文件系统在外存中的作用：

![image-20230824002503824](D:\typora笔记\操作系统笔记图片\image-20230824002503824.png)	

~~~
1 先打开外存M目录下的A文件，以只读的方式，并且放入缓存

2 将已经打开的A文件放入系统打开文件表，表示这个文件被打开的，并且有一个程序在使用（打开计数）

3 在使用这个文件的进程中 的打开文件表存入索引，以及存入打开方式；

4 最后内存通过进程的打开文件表，查到到系统打开文件表的索引；
再通过系统打开文件表，读取到外存的文件；

~~~

------

# 虚拟文件系统&文件系统挂载：

![image-20230824003244995](D:\typora笔记\操作系统笔记图片\image-20230824003244995.png)	

## 虚拟文件系统：

~~~
屏蔽底层文件系统特性；对于不同的文件系统要求按照虚拟文件系统的标准实现接口；
~~~

![image-20230824003342056](D:\typora笔记\操作系统笔记图片\image-20230824003342056.png)	

~~~
不同的文件系统，其中的文件数据结构不同，因此需要使用一个统一标准：Vnode

UFS和FAT文件系统，打开后都会被读取为一个Vnode结构
~~~

![image-20230824003815725](D:\typora笔记\操作系统笔记图片\image-20230824003815725.png)	

![image-20230824003839955](D:\typora笔记\操作系统笔记图片\image-20230824003839955.png)	

~~~
Vnode只会存在于主存，inode会被调入主存，也会存放于外存；
~~~

### 函数功能指针：

![image-20230824004135779](D:\typora笔记\操作系统笔记图片\image-20230824004135779.png)	

## 挂载：

~~~
u盘插入电脑，就是挂载；

使用内存中的挂载表 进行管理；并且新挂载的系统需要说明自己的函数功能；
~~~

![image-20230824004405594](D:\typora笔记\操作系统笔记图片\image-20230824004405594.png)	

------

# ------------------------------------------------------------------------------------------

# 最后一章：

# IO控制器：

![image-20230829002019877](D:\typora笔记\操作系统笔记图片\image-20230829002019877.png)	

![image-20230829002053719](D:\typora笔记\操作系统笔记图片\image-20230829002053719.png)	

![image-20230829002157518](D:\typora笔记\操作系统笔记图片\image-20230829002157518.png)	

## 组成：

![image-20230829002318339](D:\typora笔记\操作系统笔记图片\image-20230829002318339.png)	

## 小结：

![image-20230829002426581](D:\typora笔记\操作系统笔记图片\image-20230829002426581.png)	

------

# IO控制方式：

![image-20230829002541946](D:\typora笔记\操作系统笔记图片\image-20230829002541946.png)	

## 程序控制方式（最早

~~~
cpu一直处于忙等状态；
~~~

![image-20230829002811795](D:\typora笔记\操作系统笔记图片\image-20230829002811795.png)	

## 中断控制方式

~~~
实现了cpu和io设备并行工作的方式；

每次中断都必须保存当前进程状态，结束后又要恢复状态，耗费资源和时间。
~~~

![image-20230829003014485](D:\typora笔记\操作系统笔记图片\image-20230829003014485.png)	

![image-20230829003058428](D:\typora笔记\操作系统笔记图片\image-20230829003058428.png)	

## DMA方式：

~~~
可以读入一个或多个块，但是要求必须连续的块；

如果读入的多个快都是离散的，就需要发出多次读取指令；
~~~



![image-20230829003229477](D:\typora笔记\操作系统笔记图片\image-20230829003229477.png)	

![image-20230829003247169](D:\typora笔记\操作系统笔记图片\image-20230829003247169.png)	

![image-20230829003641835](D:\typora笔记\操作系统笔记图片\image-20230829003641835.png)	

## 通道控制方式：

![image-20230829003900171](D:\typora笔记\操作系统笔记图片\image-20230829003900171.png)	

## 小结：

![image-20230829003915996](D:\typora笔记\操作系统笔记图片\image-20230829003915996.png)	

------



# IO软件层次

## 用户层：

![image-20230829004113898](D:\typora笔记\操作系统笔记图片\image-20230829004113898.png)	

~~~
讲的很水，直接小结
~~~

![image-20230829004333812](D:\typora笔记\操作系统笔记图片\image-20230829004333812.png)	

------

# 输入输出接口：

![image-20230829004621561](D:\typora笔记\操作系统笔记图片\image-20230829004621561.png)	

## 网络设备接口：

![image-20230829004734726](D:\typora笔记\操作系统笔记图片\image-20230829004734726.png)	

## 知识点：

![image-20230829004853022](D:\typora笔记\操作系统笔记图片\image-20230829004853022.png)	

------

# IO核心子系统：

![image-20230829005013851](D:\typora笔记\操作系统笔记图片\image-20230829005013851.png)	

## 假脱机技术：

![image-20230829005045907](D:\typora笔记\操作系统笔记图片\image-20230829005045907.png)	

~~~
脱机：脱离主机的控制，进行输入输出操作；
~~~

![image-20230829005314224](D:\typora笔记\操作系统笔记图片\image-20230829005314224.png)	

## 小结：

![image-20230829005520708](D:\typora笔记\操作系统笔记图片\image-20230829005520708.png)

~~~
共享打印机，就是为每一个进程分配一个输入/输出缓冲区，当每个进程都以为自己独占一台物理机；
~~~

------

# 设备的分配与回收：

![image-20230829005741520](D:\typora笔记\操作系统笔记图片\image-20230829005741520.png)	

## 小结

~~~
讲的太水
~~~

![image-20230829010020797](D:\typora笔记\操作系统笔记图片\image-20230829010020797.png)	

------

# 缓冲区：

~~~
讲的太水了！！！
~~~



![image-20230829010042613](D:\typora笔记\操作系统笔记图片\image-20230829010042613.png)	

## 作用：

![image-20230829010102249](D:\typora笔记\操作系统笔记图片\image-20230829010102249.png)	

~~~
如果是字符输入输出，没输入一个字符，就要中断一次cpu，缓冲区就可以一次存一堆字符，然后一次写入
~~~

![image-20230829010238248](D:\typora笔记\操作系统笔记图片\image-20230829010238248.png)	

## 单缓冲：

~~~
默认一次只读入一块数据
~~~

![image-20230829010630411](D:\typora笔记\操作系统笔记图片\image-20230829010630411.png)	

![image-20230829010613732](D:\typora笔记\操作系统笔记图片\image-20230829010613732.png)	
