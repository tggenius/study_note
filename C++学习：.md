# C++学习：

## visual Studio 快捷键：

~~~
项目相关的快捷键
       Ctrl + Shift + N ： 新建项目

       Ctrl + Shift + B 或者 F7 ： 编译项目（Build解决方案）

　　Ctrl + Alt + L ： 显示 Solution Explorer（解决方案资源管理器）

　　Shift + Alt + A ： 添加新项目到项目

编辑相关的键盘快捷键
　　Ctrl + Enter ： 在当前行插入空行

　　Ctrl + Shift + Enter ：在当前行下方插入空行

       Ctrl + L ：删除光标所在行

　　Ctrl + J 或者 Alt+→： 代码智能提示

　　Alt + Shift + 箭头键(←,↑,↓,→) ：选择代码的自定义部分

　　Ctrl + } ：匹配大括号、括号

　　Ctrl + Shift +} ：选中匹配的括号、括号内的所有文本

　　Ctrl + Shift + S ：保存所有文件和项目

　　Ctrl + K，Ctrl + C ：注释选定行（按住Ctrl，先按K再按C）

　　Ctrl + K，Ctrl + U ：取消选定行的注释（按住Ctrl，先按K再按U）

　　Ctrl + K，Ctrl + D ：正确对齐所有代码（按住Ctrl，先按K再按D）

       Ctrl + M，Ctrl + M ：关闭/打开整个方法（按住Ctrl，按两次M）

　　Shift + End ：从头到尾选择整行

　　Shift + Home ： 从尾到头选择整行

       Shift + Tap ：取消制表符，即取消整体缩进

       Ctrl + Delete ：删除至词尾

       Ctrl + Backspace ：删除至词头

       Ctrl + U ：转小写

       Ctrl + Shift + U ：转大写

       Ctrl + W ：选择当前单词

导航相关的键盘快捷键
　　Ctrl +↑,↓ ： 上下滚动窗口但不移动光标

       CTRL + Page Down：光标定位到窗口上方

       CTRL + Page Up：光标定位到窗口下方

　　Ctrl + - ： 定位到之前光标所在的位置

　　Ctrl +Shift+ - ：定位到之后光标所在的位置

　　F12 ： 转到定义

调试相关的键盘快捷键
　　Ctrl + Alt + P ： 附加到进程

　　F10 ： 调试单步执行

　　F5 ： 开始调试

       Ctrl + F5 ：编译运行

　　Shift + F5 ： 停止调试

　　Ctrl + Alt + Q ： 添加快捷匹配

　　F9 ： 设置或删除断点

搜索相关的键盘快捷键
　　Ctrl + K ，Ctrl + K ： 将当前行添加书签（按住Ctrl，按两次K）

　　Ctrl + K ，Ctrl + N ： 导航至下一个书签（按住Ctrl，先按K再按N）

　　Ctrl + . ： 如果你键入一个类名如 Collection<string>，且命名空间导入不正确的话，那么这个快捷方式组合将自动插入导入，需要注意与搜狗输入法的中英文标点切换快捷键冲突

　　Ctrl + Shift + F ： 在文件中查找

　　Shift  + F12 ： 查找所有引用

　　Ctrl + F ： 显示查找对话框

　　Ctrl + H ： 显示替换对话框

　　Ctrl + G ： 跳转到行号或行

　　Ctrl + Shift + F ： 查找所选条目在整个解决方案中的引用
~~~

### ·特性：

在 Visual Studio 中，如果需要使用一个函数或标识符，但不确定应该引入哪个头文件，可以使用 IntelliSense 功能来辅助你完成。IntelliSense 是 Visual Studio 的自动代码补全和智能感知功能，它可以根据你的代码上下文提供相关的建议和补全选项。

当你输入函数或标识符时，IntelliSense 会自动显示与之相关的建议列表。你可以使用键盘方向键或鼠标进行选择，并按下 Enter 键或单击以将建议添加到代码中。当你选择一个建议时，Visual Studio 会尝试自动引入适当的头文件。

如果 IntelliSense 没有自动引入所需的头文件，你可以使用以下方法手动引入：

1. 使用快捷键：你可以将光标放在未知标识符上，然后使用快捷键 `Ctrl + .`，它会显示一个上下文菜单。你可以选择 "包含 #include..." 选项，然后选择适当的头文件。

2. 手动添加头文件：你可以在源文件的开头手动添加需要的头文件。通过了解所需函数或标识符的功能，你可以确定需要哪个头文件，并将其包含在代码中。

需要注意的是，IntelliSense 功能可能需要一些时间来分析和加载项目中的头文件，并提供准确的建议。如果你的项目中的头文件有较多或复杂的依赖关系，可能需要稍等片刻，让 IntelliSense 完成分析。

总结起来，Visual Studio 提供了 IntelliSense 功能来帮助开发者自动完成代码、提供建议，并在可能的情况下自动引入所需的头文件。如果自动引入不起作用，你可以手动添加合适的头文件来解决问题。



## 1.C++特点：

![image-20230103001440091](D:\typora笔记\图片\image-20230103001440091.png)	



## 2.hello world：

![image-20230103001807299](D:\typora笔记\图片\image-20230103001807299.png)	

·这里cout就是一个对象，用于帮助输出字符串；

·在C++中，以函数为基本单位；



### ·IO流：

![image-20230103002211697](D:\typora笔记\图片\image-20230103002211697.png)	

### ·插入符（<<)   提取符（>>）

![image-20230103002306171](D:\typora笔记\图片\image-20230103002306171.png)	

### ·词法记号：

![image-20230103002443268](D:\typora笔记\图片\image-20230103002443268.png)	

### ·标识符：

![image-20230103002655978](D:\typora笔记\图片\image-20230103002655978.png)	

·注意没有美元符号；

### ·数据类型：

​	![image-20230103002803687](D:\typora笔记\图片\image-20230103002803687.png)	

### ·变量定义方式（与java不同）：

![image-20230103002855819](D:\typora笔记\图片\image-20230103002855819.png)	

·注意：使用大括号初始化，不能使用double数据类型初始化int，会造成数据丢失；



### ·符号常量：

![image-20230103003123811](D:\typora笔记\图片\image-20230103003123811.png)	

·例如get_size()返回的是PI + 2，pi是常量，2也是常量，两者相加仍是常量，因此可使用constexpr；

~~~c++
	int const a = 0;
	const int b = 0;
//这两种定义方式一样，都是定义常量
	cout << a << endl;
	cout << b << endl;
~~~

~~~c++
	int const a = 0;
	const int b = 0;
	int d = 5;
	constexpr int c = a + b;//正常
	constexpr int c = a + d;//报错，因为d不是常量
~~~





### ·常量表达式：

![image-20230103003321706](D:\typora笔记\图片\image-20230103003321706.png)	

### ·基本数据类型：

![image-20230103003535180](D:\typora笔记\图片\image-20230103003535180.png)	

### ·整数文字常量：

![image-20230103003631892](D:\typora笔记\图片\image-20230103003631892.png)	

### ·浮点数据类型：

·默认是double类型：

![image-20230103003813274](D:\typora笔记\图片\image-20230103003813274.png)	

### ·sizeOf运算符：

![image-20230103003841737](D:\typora笔记\图片\image-20230103003841737.png)	

·c++中各数据类型占多少字节没定义，各系统不一样，使用该运算符可知；



### ·字符运算符：

![image-20230103003955847](D:\typora笔记\图片\image-20230103003955847.png)	

#### ·转义符号：

![image-20230103004039487](D:\typora笔记\图片\image-20230103004039487.png)	



### ·C风格字符串常量：

·在字符串末尾存放 \0 作为结束标记；

![image-20230103004143654](D:\typora笔记\图片\image-20230103004143654.png)	

#### ·通过改变前缀修改字符串常量类型：

![image-20230103004222561](D:\typora笔记\图片\image-20230103004222561.png)





### ·数据类型字节范围：（根据系统而定）

![image-20230103004305340](D:\typora笔记\图片\image-20230103004305340.png)	

![image-20230103004334873](D:\typora笔记\图片\image-20230103004334873.png)	

### ·类型别名：

![image-20230103004402503](D:\typora笔记\图片\image-20230103004402503.png)	

·可使用这种方式，加强程序的可读性；

~~~c++
typedef int volumn;
using tgg = double;

...main：
    volumn x = 5;
	tgg y = 6.5;
	cout << x << endl;
	cout << y << endl;
~~~



### ·auto类型，decltype类型：

![image-20230103004448577](D:\typora笔记\图片\image-20230103004448577.png)http://c.biancheng.net/view/7151.html  讲解；

~~~c++
double i = 6.7;
decltype(i)j = 7.7;
cout << j << "sizeOf:" << sizeof(j) << endl; //这里定义j的数据类型由表达式i决定，并且以7.7为初始值；
~~~



#### ·两者的区别：

~~~c++
auto varname = value;
decltype(exp) varname = value;
~~~

·其中，varname 表示变量名，value 表示赋给变量的值，**exp 表示一个表达式**。

·auto 根据`=`右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟`=`右边的 value 没有关系。

·auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是**根据变量的初始值来推导出变量类型**的，如果不初始化，变量的类型也就无法推导了。decltype 可以写成下面的形式：

~~~c++
decltype(exp) varname;
~~~



#### ·exp 注意事项：

·原则上讲，exp 就是一个普通的表达式，它可以是任意复杂的形式，但是我们必须要保证 **exp 的结果是有类型的，不能是 void**；例如，当 exp 调用一个返回值类型为 void 的函数时，exp 的结果也是 void 类型，此时就会导致编译错误。

~~~c++
int a = 0;
decltype(a) b = 1;  //b 被推导成了 int
decltype(10.8) x = 5.5;  //x 被推导成了 double
decltype(x + 100) y;  //y 被推导成了 double
~~~



#### ·decltype三个原则：

- 如果 exp 是一个不被括号`( )`包围的表达式，或者是一个**类成员访问表达式**，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。
- 如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。
- 如果 exp 是一个左值，或者被括号`( )`包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&。

**第三个原则-举例说明：**

这个原则是描述了使用 `decltype` 运算符时，根据表达式 `exp` 的左值或右值特性来确定 `decltype(exp)` 的类型。如果 `exp` 是一个左值（可被赋值的表达式），或者被括号 `( )` 包围，那么 `decltype(exp)` 的类型将是 `exp` 的引用。换句话说，如果 `exp` 的类型为 `T`，那么 `decltype(exp)` 的类型将是 `T&`。

让我们通过一些例子来说明这个原则：

```cpp
int x = 5;
decltype(x) a = x;  // a的类型是int，直接拷贝x的值

int& y = x;
decltype(y) b = x;  // b的类型是int&，decltype(y)为int&，因为y是一个左值

decltype(x + 1) c = x;  // c的类型是int，x + 1是一个右值，decltype(x + 1)为int

decltype((x)) d = x;  // d的类型是int&，(x)是一个左值，decltype((x))为int&
```

在上面的例子中，我们可以看到：

- 对于变量 `x`，`decltype(x)` 的类型是 `int`。
- 对于引用 `y`，`decltype(y)` 的类型是 `int&`，因为 `y` 是一个左值。
- 对于表达式 `x + 1`，`decltype(x + 1)` 的类型是 `int`，因为 `x + 1` 是一个右值。
- 对于被括号 `(x)` 包围的表达式，`decltype((x))` 的类型是 `int&`，因为 `(x)` 是一个左值。

这个原则在某些情况下很有用，特别是在模板元编程和泛型编程中，可以根据表达式的左值或右值特性来确定变量或函数的返回类型。

------



### ·左值和右值：

当讨论左值（lvalue）和右值（rvalue）时，我们指的是C++表达式的属性或特性。理解这两个概念对于理解C++中的值类别（value category）和语言特性非常重要。

1. 左值（lvalue）：
左值是一个**表达式**，它具有**可标识的内存地址**，并且**可以出现在赋值运算符的左边**。**简单来说，左值可以被取地址、引用或修改**。以下是一些示例：

```cpp
int x = 5;  // x是一个左值
int* ptr = &x;  // &x取得x的地址，因此x是一个左值
int arr[5];  // 数组名arr是一个左值
```

在上面的示例中，变量 `x`、指针 `ptr` 和数组 `arr` 都是左值。

2. 右值（rvalue）：
右值是一个表达式，**它没有可标识的内存地址**，或者在**表达式求值后会被销毁**。简单来说，右值不能被取地址或引用。以下是一些示例：

```cpp
int a = 5;  // 5是一个右值
int b = a + 3;  // a + 3是一个右值
int c = foo();  // foo()返回的值是一个右值
```

在上面的示例中，常量 `5`、表达式 `a + 3` 和函数调用 `foo()` 的返回值都是右值。

需要注意的是，C++11引入了右值引用（rvalue reference）的概念，通过使用 `&&` 语法来声明。右值引用允许我们将右值绑定到一个新的标识符上，并且可以通过右值引用对其进行修改。这是为了支持移动语义和完美转发等特性。

```cpp
int&& rvalueRef = 7;  // 7是一个右值，可以绑定到右值引用rvalueRef上
```

在C++17中，还引入了类似于右值引用的折叠规则，称为折叠引用（forwarding reference），使用 `T&&` 的形式。它具有更广泛的用途，可以用于实现完美转发。

左值和右值的区分在C++中非常重要，因为它们在语法和语义上有所不同。例如，只有左值可以被赋值，而右值则不能。在理解C++的值类别、函数重载和移动语义等方面，了解左值和右值的概念至关重要。

------



### ·算数运算符，表达式：

![image-20230103004822527](D:\typora笔记\图片\image-20230103004822527.png)	

------



### ·自增、自减：

在表达式 `i++` 和 `++i` 中，`i` 是一个整数变量。它们是递增运算符的两种形式，都用于增加 `i` 的值。

1. `i++`（后置递增）：
   - 先将 `i` 的当前值使用作为整个表达式的结果。
   - 然后将 `i` 的值增加 1。

   ```cpp
   int i = 1;
   int result = i++;  // result = 1, i = 2
   ```

   在这个例子中，`result` 的值是 `1`，因为后置递增运算符 `i++` 返回的是 `i` 的当前值（在递增之前的值），然后 `i` 的值增加了 1。

2. `++i`（前置递增）：
   - 先将 `i` 的值增加 1。
   - 然后将增加后的 `i` 的值作为整个表达式的结果。

   ```cpp
   int i = 1;
   int result = ++i;  // result = 2, i = 2
   ```

   在这个例子中，`result` 的值是 `2`，因为前置递增运算符 `++i` 先将 `i` 的值增加 1，然后将增加后的值作为表达式的结果。

总结区别：
- `i++` 是后置递增运算符，先使用 `i` 的值，然后再递增 `i` 的值。
- `++i` 是前置递增运算符，先递增 `i` 的值，然后再使用递增后的值。

在大多数情况下，这两种形式的递增运算符没有明显的区别，特别是当它们**作为独立的语句使用时**。然而，在某些特定的使用情况下，它们可能会有不同的行为，例如在表达式中作为函数参数或赋值语句的一部分。所以，在具体使用时需要根据具体情况选择合适的递增形式。

#### ·i++的原理：

在后置递增 `i++` 的操作中，确实会先将 `i` 的值进行备份，然后将备份的值作为表达式的结果，最后再对 `i` 进行自增。

具体步骤如下：
1. 备份 `i` 的当前值。
2. 将备份的值作为整个表达式的结果。
3. 将 `i` 的值增加 1。

这意味着，在后置递增表达式中，使用的是 `i` 的旧值，然后 `i` 的值会被增加。

以下是一个示例来说明后置递增操作：

```cpp
int i = 1;
int result = i++;  // result = 1，i = 2
```

在这个示例中，`result` 的值是 `1`，因为后置递增 `i++` 返回的是 `i` 的备份（递增之前的值），然后 `i` 的值增加了 1，所以 `i` 现在的值是 `2`。

总结：
后置递增运算符 `i++` 在使用 `i` 的旧值作为表达式的结果后，再对 `i` 进行递增操作。

------



### ·逗号运算，逗号表达式：

![image-20230103005315066](D:\typora笔记\图片\image-20230103005315066.png)	

~~~c++
	int a, b;
	a = 3 * 5, a = 5 * 5;
	cout << a << endl; //25
~~~



### ·关系运算符：

![image-20230103005503245](D:\typora笔记\图片\image-20230103005503245.png)	

### ·逻辑运算符：

![image-20230103005603504](D:\typora笔记\图片\image-20230103005603504.png)	

#### ·短路特性：

![image-20230103005628877](D:\typora笔记\图片\image-20230103005628877.png)	



### ·条件表达式：

![image-20230103005844569](D:\typora笔记\图片\image-20230103005844569.png)	



### ·位运算符：

![image-20230103010009116](D:\typora笔记\图片\image-20230103010009116.png)	

#### ·异或：

![image-20230103010136151](D:\typora笔记\图片\image-20230103010136151.png)	

#### ·取反：

![image-20230103010236225](D:\typora笔记\图片\image-20230103010236225.png)	

#### ·移位：

![image-20230103010309727](D:\typora笔记\图片\image-20230103010309727.png)	

在对有符号整数进行右移运算时，其具体行为由编译器和所用的数据类型决定。C++标准没有明确规定右移有符号整数的行为，因此结果可能因编译器而异。通常情况下，有符号整数的右移运算采用算术右移（arithmetic right shift）或逻辑右移（logical right shift）两种方式之一。

1. 算术右移（符号位保持不变）：
   - 对于有符号整数，算术右移将右移操作应用于二进制表示，并保持符号位不变。也就是说，最高位（符号位）的值会在右移操作后保持不变。
   - 右移操作会将每一位向右移动指定的位数，并在左侧填充符号位的值。

   假设我们有一个有符号整数 `-20`，以32位二进制表示，即 `11111111 11111111 11111111 11101100`。对该数进行算术右移一位，结果如下：

   ```
   11111111 11111111 11111111 11110110
   ```

   在算术右移中，最高位的 `1` 作为符号位保持不变，右移操作将其它位向右移动，左侧使用符号位进行填充。

2. 逻辑右移（符号位补0）：
   - 对于无符号整数或将有符号整数强制转换为无符号整数类型后进行的右移操作，逻辑右移将右移操作应用于二进制表示，并在左侧使用0进行填充。
   - 右移操作将每一位向右移动指定的位数，并在左侧填充0。

   如果将 `-20` 视为无符号整数（强制转换为无符号整数类型），它的二进制表示仍然是 `11111111 11111111 11111111 11101100`。对该数进行逻辑右移一位，结果如下：

   ```
   01111111 11111111 11111111 11110110
   ```

   在逻辑右移中，所有位都向右移动，左侧使用0进行填充。

需要注意的是，右移操作的位数决定了右移的幅度。右移一位相当于除以2，右移两位相当于除以4，依此类推。

最终的右移结果取决于编译器的实现和所用的数据类型。如果您希望确切了解特定编译器和数据类型的右移行为，请查阅相应的文档或参考编译器的规范。

------



### ·混合数据类型运算：

![image-20230103010429385](D:\typora笔记\图片\image-20230103010429385.png)	

### ·数据类型转换：

![image-20230103010655962](D:\typora笔记\图片\image-20230103010655962.png)	

在C++中，有四种显式类型转换形式，分别为：static_cast、dynamic_cast、reinterpret_cast和const_cast。

1. static_cast：用于将一个表达式转换为某个类型，是一种通用的类型转换方式，可以在各种类型之间进行转换。它会检查转换的类型是否合法，例如将浮点型转换为整型时会自动进行截断操作。以下是一些示例：

   ```c++
   double d = 3.1415926;
   int i = static_cast<int>(d); // 将double类型的d转换为int类型的i
   float f = static_cast<float>(i); // 将int类型的i转换为float类型的f
   ```

2. dynamic_cast：用于将一个指针或引用转换为某个派生类类型或基类类型。它主要用于运行时类型识别，可以检查指针或引用所指向的对象的实际类型是否与转换后的类型兼容。以下是一个示例：

   ```c++
   class Base {
       virtual void foo() {}
   };

   class Derived : public Base {
   public:
       void bar() {}
   };

   Base* b = new Derived;
   Derived* d = dynamic_cast<Derived*>(b); // 将基类指针转换为派生类指针
   if (d != nullptr) {
       d->bar(); // 转换成功，可以调用派生类的函数
   }
   ```

3. reinterpret_cast：用于进行底层的类型转换，即将一个指针或引用的位模式重新解释为另一种类型的指针或引用。它不进行类型检查，因此需要谨慎使用。以下是一个示例：

   ```c++
   int i = 42;
   char* p = reinterpret_cast<char*>(&i); // 将int类型的指针转换为char类型的指针
   *p = 'A'; // 修改char类型指针指向的值
   ```

4. const_cast：用于去除表达式的const或volatile属性。它可以将一个指向非常量对象的指针转换为指向常量对象的指针，或者将一个指向常量对象的指针转换为指向非常量对象的指针。以下是一个示例：

   ```c++
   const int i = 42;
   int& r = const_cast<int&>(i); // 去除i的const属性，返回一个int类型的引用
   r = 0; // 可以修改i的值
   ```

需要注意的是，显式类型转换应该谨慎使用，因为它可能会引入类型不兼容的问题，导致程序运行异常或产生不可预测的结果。在进行类型转换时，应该尽可能使用隐式类型转换或其他更安全的方式。

------



### ·IO格式控制：

![image-20230103010744154](D:\typora笔记\图片\image-20230103010744154.png)	

常见的操纵符用于在C++中对输入和输出进行格式化和控制。以下是一些常见的操纵符及其使用方式：

1. `dec` 和 `hex`：用于控制整数的输出进制。
   - `dec`：将整数的输出进制设置为十进制。
   - `hex`：将整数的输出进制设置为十六进制。

   ```cpp
   int num = 42;
   std::cout << std::dec << num << std::endl;  // 输出为十进制，默认格式  42 
   std::cout << std::hex << num << std::endl;  // 输出为十六进制，以字母表示 2a
   ```

2. `endl`：用于输出换行符，并刷新输出缓冲区。
   - `endl` 在输出流中插入一个换行符，并且将输出缓冲区刷新，确保输出立即显示在设备上。

   ```cpp
   std::cout << "Hello, world!" << std::endl;
   ```

3. `ends`：用于输出空字符，并刷新输出缓冲区。
   - `ends` 在输出流中插入一个空字符，并且将输出缓冲区刷新，类似于插入字符 `'\0'`。

   ```cpp
   std::cout << "Hello" << std::ends << "world!" << std::endl;
   ```

4. `setw`：用于设置字段宽度。
   - `setw` 可以指定后续输出的字段宽度，即所占的字符数。

   ```cpp
   #include <iomanip>
   std::cout << std::setw(10) << "Hello" << std::setw(10) << "world!" << std::endl;
   ```

   输出：

   ```
       Hello    world!
   ```

这些操纵符可以与输出流对象 `std::cout` 一起使用，也可以与输入流对象一起使用。它们的具体效果取决于其在流中的位置和顺序。可以根据需要在输出语句中灵活地组合和使用这些操纵符，以实现所需的格式化和控制效果。需要注意的是，在使用这些操纵符之前，应包含适当的头文件，例如 `<iostream>` 和 `<iomanip>`。

在使用标准库中的对象和函数时，为了避免命名冲突和提高代码的可读性，通常建议在使用它们之前加上命名空间 `std::`，以明确指定使用的是标准库中的成员。

但是，在特定情况下，可以通过使用 `using` 声明或者命名空间别名来简化代码，使得可以直接使用 `cout` 而不写 `std::cout`。

使用 `using` 声明：

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Hello, world!" << endl;
    return 0;
}
```

命名空间别名：

```cpp
#include <iostream>
namespace io = std;

int main() {
    io::cout << "Hello, world!" << io::endl;
    return 0;
}
```

这种简化的写法可以提高代码的可读性和编写的便捷性。然而，需要注意的是，为了避免潜在的命名冲突问题，最好只在较小的范围内使用 `using` 声明或者命名空间别名，而不要在全局范围内使用，以免引入不必要的问题。

------



## 3.条件语句：

![image-20230103011207086](D:\typora笔记\图片\image-20230103011207086.png)	

### ·switch语句：

![image-20230103011400794](D:\typora笔记\图片\image-20230103011400794.png)	

·switch中允许变量表达式；

~~~c++
	int sw = 12;
	int se = 22;
	switch (sw+se)
	{
	case 34:cout << "t1" << endl; break;
	default:
		break;
	}
~~~





## 4.循环语句：

### ·while：

![image-20230103012039240](D:\typora笔记\图片\image-20230103012039240.png)	

### ·do-while：

![image-20230103012429576](D:\typora笔记\图片\image-20230103012429576.png)



### ·for语句：

![image-20230103013117391](D:\typora笔记\图片\image-20230103013117391.png)	

### ·流程控制语句：

![image-20230103013718392](D:\typora笔记\图片\image-20230103013718392.png)

~~~c++
int main() {
	int sw = 12;
	int se = 22;
	int i = 1;
	cout << sw++ << endl;
	cout << sw << endl;

	do {
		cout << i << endl;
		i++;
	} while (i <= 10);

	cout << i << endl;
	cout << ++se << endl;
	goto flag;
	cout << "t3" << endl;

	flag:
	cout << "t4" << endl;
~~~





## 5.函数：

![image-20230103014312845](D:\typora笔记\图片\image-20230103014312845.png)	

### ·函数调用：

![image-20230103014421469](D:\typora笔记\图片\image-20230103014421469.png)	

![image-20230103014447716](D:\typora笔记\图片\image-20230103014447716.png)	



### ·n--过程：

![image-20230103014910472](D:\typora笔记\图片\image-20230103014910472.png)	

·这个程序刚开始，第一次执行n--，首先将n的值2备份一份进行存储；

![image-20230103015009293](D:\typora笔记\图片\image-20230103015009293.png)	备份完成后，执行n-1的操作；

·上面两件事做完后，n--这个运算才算完成，而此时while中n的值，使用的是备份存储的2；

·因此n是做了 - -运算之后，才进行的while循环判断，而不是先把n=2的值拿来用，再做 - -的运算；



### ·16机制转10机制：

![image-20230103015351088](D:\typora笔记\图片\image-20230103015351088.png)	



### ·泰勒表达式计算：

![image-20230104014305138](D:\typora笔记\图片\image-20230104014305138.png)	

·c++中是由arctan函数的；

![image-20230104014418073](D:\typora笔记\图片\image-20230104014418073.png)	

·手动实现：

![image-20230104014553746](D:\typora笔记\图片\image-20230104014553746.png)	

### ·回文：

![image-20230104014723832](D:\typora笔记\图片\image-20230104014723832.png)	

![image-20230104014839656](D:\typora笔记\图片\image-20230104014839656.png)



### ·骰子问题（随机数）：

![image-20230104015616443](D:\typora笔记\图片\image-20230104015616443.png)	

#### ·随机数函数：

![image-20230104015728877](D:\typora笔记\图片\image-20230104015728877.png)	

·伪随机数，指产生的数并不是真正随机的，第一次执行产生随机数，第二次再执行可能产生和第一次相同的结果；

#### ·随机数种子：

![image-20230104015904078](D:\typora笔记\图片\image-20230104015904078.png)·使用种子重新初始化rand的起始点；

`srand` 函数是C和C++标准库中的一个函数，用于设置随机数生成器的种子。它的作用是在生成随机数之前，初始化伪随机数生成器的种子，以使随机数序列具有不同的起始点。

随机数生成器是基于某种算法的，它根据种子生成一系列的伪随机数。种子的不同将导致生成的随机数序列不同。通常情况下，我们希望每次程序运行时都能获得不同的随机数序列，而不是每次都获得相同的序列。这就是使用 `srand` 函数的目的，它可以根据不同的种子值生成不同的随机数序列。

`Srand` 函数的原型如下所示：

```cpp
void srand(unsigned int seed);
```

它接受一个无符号整数作为参数，该参数被用作种子值。种子值通常使用当前时间（`time` 函数返回的值）来设置，以确保每次运行程序时都使用不同的种子。以下是一个示例：

```cpp
#include <iostream>
#include <cstdlib>
#include <ctime>

int main() {
    // 使用当前时间作为种子
    std::srand(std::time(nullptr));

    // 生成随机数
    int randomNumber = std::rand();

    std::cout << "Random number: " << randomNumber << std::endl;

    return 0;
}
```

在上述示例中，我们使用 `std::time(nullptr)` 获取当前时间的秒数作为种子值，然后将其传递给 `srand` 函数。接下来，使用 `std::rand` 函数生成一个随机数。

需要注意的是，`srand` 函数只需要在程序中调用一次，通常在程序的初始化阶段设置种子即可。如果在程序中多次调用 `srand` 函数并传递相同的种子值，将会生成相同的随机数序列。因此，为了获得更好的随机性，应该确保每次调用 `srand` 函数时传递不同的种子值。

#### ·代码实现：

![image-20230104020126720](D:\typora笔记\图片\image-20230104020126720.png)	

#### ·case语句共用：

![image-20230104020230529](D:\typora笔记\图片\image-20230104020230529.png)	

![image-20230104020254792](D:\typora笔记\图片\image-20230104020254792.png)	

#### ·投骰子：

![image-20230104020342744](D:\typora笔记\图片\image-20230104020342744.png)	



### ·函数嵌套：

![image-20230104020644769](D:\typora笔记\图片\image-20230104020644769.png)	

### ·递归：

![image-20230104020845432](D:\typora笔记\图片\image-20230104020845432.png)	

·未知到已知，已知再到未知的过程；



#### ·组合问题：

![image-20230104021121246](D:\typora笔记\图片\image-20230104021121246.png)	

![image-20230104021244240](D:\typora笔记\图片\image-20230104021244240.png)	

#### ·汉诺塔问题：

![image-20230104021905182](D:\typora笔记\图片\image-20230104021905182.png)	

![image-20230104021918199](D:\typora笔记\图片\image-20230104021918199.png)

##### ·运行过程：

### ·TODO 用4个盘子走一遍；

![image-20230104022155759](D:\typora笔记\图片\image-20230104022155759.png)	



### ·函数参数传递：

![image-20230104022444111](D:\typora笔记\图片\image-20230104022444111.png)	

#### ·值传递案例：

![image-20230104022559023](D:\typora笔记\图片\image-20230104022559023.png)	

#### ·值交换图：

![image-20230104022654911](D:\typora笔记\图片\image-20230104022654911.png)	

#### ·引用类型参数：

![image-20230104022742831](D:\typora笔记\图片\image-20230104022742831.png)	

·这里的a，b 相当于要作为其他变量的 **“别名”** ；

·x传给a，此时a就是x的别名，a就相当于x；

#### ·值交换图：

![image-20230104022941094](D:\typora笔记\图片\image-20230104022941094.png)	



#### ·引用类型说明：

![image-20230104023056024](D:\typora笔记\图片\image-20230104023056024.png)	

**·方法中的形参不需要初始化，因为形参只有在函数被调用时，才分配内存单元；**

是的，一旦引用被初始化，它就不能改变为指向其他对象。一次引用被初始化后，它将一直引用同一个对象，不能再引用其他对象。下面是一个示例来说明这个问题：

```cpp
#include <iostream>

int main() {
    int i = 5;
    int j = 10;

    int& ri = i;  // 初始化引用ri，使其引用i
    std::cout << "ri: " << ri << std::endl;  // 输出：ri: 5

    ri = j;  // 错误！试图将引用ri改为引用j
    std::cout << "ri: " << ri << std::endl;  // 输出：ri: 10

    return 0;
}
```

在上述示例中，我们创建了一个整数变量 `i` 并初始化为 5，然后创建了一个引用 `ri` 并将其初始化为 `i`。我们输出 `ri` 的值，得到 5。

接下来，我们试图将引用 `ri` 改为引用变量 `j`。然而，这是错误的，因为一旦引用被初始化，它就不能改变为指向其他对象。所以，赋值语句 `ri = j` 实际上是将 `j` 的值赋给了 `i`，因为 `ri` 引用的是 `i`。因此，输出 `ri` 的值变为 10。

这个例子强调了引用在初始化后绑定到一个对象，并且无法在后续的代码中改变绑定的对象。引用提供了一种别名的机制，它始终指向初始化时所绑定的对象。

------



#### ·可变数量形参：

![image-20230104023351884](D:\typora笔记\图片\image-20230104023351884.png)	

#### ·参数默认值：	

#### ![image-20230104023451438](D:\typora笔记\图片\image-20230104023451438.png)

##### ·规定：

![image-20230104023539628](D:\typora笔记\图片\image-20230104023539628.png)	

![image-20230104023615403](D:\typora笔记\图片\image-20230104023615403.png)	

![image-20230104023640189](D:\typora笔记\图片\image-20230104023640189.png)	



### ·函数内联：

![image-20230106012706166](D:\typora笔记\图片\image-20230106012706166.png)	

#### ·案例：

·这里的函数非常简单，如果只是为了这种逻辑写函数，所花费的开销比这个函数本身做的事还多；

·因此这里使用内联，在程序执行时把函数体中的逻辑嵌入到main函数逻辑中；

内联函数（inline function）是一种用于优化代码执行效率的函数形式。内联函数的特点是在每个调用点上将函数的代码插入，而不是通过常规的函数调用机制进行函数调用。这样可以减少函数调用的开销，提高代码的执行速度。

内联函数的使用方法如下：

1. 声明函数为内联函数：在函数定义前加上 `inline` 关键字，将函数声明为内联函数。例如：

```cpp
inline int add(int a, int b) {
    return a + b;
}
```

2. 调用内联函数：在代码中像调用普通函数一样使用内联函数。编译器会将函数的代码插入到调用点上，而不是生成函数调用指令。例如：

```cpp
int result = add(3, 4);
```

需要注意的是，内联函数适用于函数体较短、频繁调用的情况。使用内联函数可以减少函数调用的开销，但也会增加代码的体积。因此，通常建议将内联函数的定义放在头文件中，以便编译器在每个调用点上进行内联展开。

内联函数的优势在于减少函数调用的开销，从而提高代码执行效率。但并非所有函数都适合内联，因为内联函数会增加代码的体积，并且只有在函数体较短且频繁调用的情况下才能获得明显的性能提升。对于较长的函数或复杂的函数，内联可能不会带来性能上的显著改进，并且可能增加可执行文件的大小。

需要注意的是，内联函数仅是对编译器的建议，编译器可以选择忽略内联函数的建议并按照常规函数进行处理。因此，无法确保所有声明为内联函数的函数都会被内联展开。	

------



### ·函数重载：

![image-20230106013122874](D:\typora笔记\图片\image-20230106013122874.png)	

#### ·案例：

#### ![image-20230106013206729](D:\typora笔记\图片\image-20230106013206729.png)	

### ·系统函数：

![image-20230106013319016](D:\typora笔记\图片\image-20230106013319016.png)	

·计算角度的弧度：

![image-20230106013350730](D:\typora笔记\图片\image-20230106013350730.png)	





## 6.类与对象：

### 目录·

![image-20230106013441407](D:\typora笔记\图片\image-20230106013441407.png)	

### ·类语法：

![image-20230106014016671](D:\typora笔记\图片\image-20230106014016671.png)	

![image-20230106013815930](D:\typora笔记\图片\image-20230106013815930.png)	

### ·封装：

![image-20230106013842549](D:\typora笔记\图片\image-20230106013842549.png)	

### ·类-对象关系：

![image-20230106013945534](D:\typora笔记\图片\image-20230106013945534.png)	

·类是对象的模板，对象是类的实例；

### ·公有成员：

![image-20230106014101854](D:\typora笔记\图片\image-20230106014101854.png)	

### ·私有成员：

![image-20230106014155799](D:\typora笔记\图片\image-20230106014155799.png)	

### ·保护成员：

![image-20230106014224038](D:\typora笔记\图片\image-20230106014224038.png)	

### ·类定义：

![image-20230106014324294](D:\typora笔记\图片\image-20230106014324294.png)	

**·公有成员和公有函数，一同写在public下面即可，不需要写多个public：**

~~~c++
class MyClass {
public:
    // 公有成员变量
    int publicVariable;

    // 公有成员函数
    void publicFunction();
};

~~~

------

#### ·限定符：（知识点补充）

`Clock::` 是 C++ 中类成员函数的限定符语法，用于指定函数属于哪个类。它的作用是指定类作用域下的成员函数实现。

下面是一个示例，展示了如何使用 `Clock::` 来实现 `showTime` 成员方法：

```cpp
class Clock {
public:
    void showTime();
};

void Clock::showTime() {
    // 在这里实现 showTime 的具体逻辑
}
```

在上述示例中，`Clock` 是一个类名，`showTime()` 是 `Clock` 类的成员函数。在类外部，我们使用 `Clock::` 来指定函数的类作用域，表示该函数属于 `Clock` 类。函数的实现部分放在类外部，使用 `Clock::showTime()` 的语法来定义 `showTime` 函数的具体实现。

通过这种方式，我们可以将成员函数的实现与类的定义分离，使代码更加清晰和模块化。在类的定义中声明成员函数，并在类外部使用 `类名::函数名` 的语法实现函数的具体逻辑。

使用示例：

```cpp
Clock myClock;
myClock.showTime();  // 调用 Clock 类的 showTime 成员函数
```

在上述示例中，我们创建了 `Clock` 类的对象 `myClock`，然后通过对象调用 `showTime` 成员函数，这样就会执行 `Clock::showTime` 的具体逻辑。

总结起来，`Clock::` 是用于指定类成员函数实现的限定符语法，它可以帮助我们将成员函数的定义与类的声明分开，提高代码的可读性和模块化。

------



#### ·类函数实现：

·这里的函数实现，限定了这个函数是专门用于处理clock类的；

·成员函数可以直接访问类中的private成员；

·成员函数的实现可以在类的外部实现，与main方法同级；

![image-20230106014346375](D:\typora笔记\图片\image-20230106014346375.png)	

#### ·对象使用：

![image-20230106014448590](D:\typora笔记\图片\image-20230106014448590.png)	

### ·类初始值：

![image-20230106014722559](D:\typora笔记\图片\image-20230106014722559.png)	

**·默认初始化即给予默认值；**

------



### ·使用 【类名 参数名】和new关键字创建类对象的区别：

在创建一个类对象 `Clock myClock;` 的时候，会为这个对象分配内存空间。内存的分配发生在栈（stack）上，当对象超出作用域时，会自动调用析构函数释放内存。

与使用 `new` 关键字创建对象相比，使用类对象的方式有以下区别：

1. 内存管理：使用类对象方式创建的对象在栈上分配内存，随着对象离开作用域，内存会自动释放。而使用 `new` 关键字创建的对象在堆（heap）上分配内存，需要显式使用 `delete` 关键字来释放内存，否则可能会导致内存泄漏。

2. 生命周期：使用类对象方式创建的对象的生命周期与其所在的作用域相关，当对象超出作用域时会自动调用析构函数进行资源释放。而使用 `new` 关键字创建的对象的生命周期由开发者手动管理，需要显式调用 `delete` 来销毁对象并释放内存。

3. 对象的创建位置：使用类对象方式创建的对象存储在栈上，对象的创建和销毁速度较快。而使用 `new` 关键字创建的对象存储在堆上，对象的创建和销毁速度较慢，因为它涉及到动态内存的分配和释放。

通常情况下，如果对象的生命周期较短并且在局部作用域内，可以优先考虑使用类对象方式创建对象。这样可以避免手动管理内存的麻烦，同时代码也更加简洁。而使用 `new` 关键字创建对象主要适用于需要在动态分配内存的情况，例如在堆上创建对象并返回指针，或者在对象的生命周期需要跨越多个作用域时。

需要注意的是，无论是使用类对象方式创建对象还是使用 `new` 关键字创建对象，都需要在类中定义析构函数来正确释放资源，以避免内存泄漏或资源泄漏的问题。

------



### ·成员函数规则：

![image-20230106014806618](D:\typora笔记\图片\image-20230106014806618.png)

#### ·内联成员函数：

![image-20230106014839758](D:\typora笔记\图片\image-20230106014839758.png)	

### ·构造函数：

![image-20230106015827382](D:\typora笔记\图片\image-20230106015827382.png)	

#### ·规则：

![image-20230106015859663](D:\typora笔记\图片\image-20230106015859663.png)	

·创建对象时自动调用；

#### ·默认构造函数：

![image-20230106015952755](D:\typora笔记\图片\image-20230106015952755.png)	

![image-20230106020037727](D:\typora笔记\图片\image-20230106020037727.png)	

#### ·案例：

![image-20230106020119691](D:\typora笔记\图片\image-20230106020119691.png)	

![image-20230106020136695](D:\typora笔记\图片\image-20230106020136695.png)	

#### ·初始化方式：

![image-20230106020813208](D:\typora笔记\图片\image-20230106020813208.png)	

### ·default关键字：

![image-20230106020941752](D:\typora笔记\图片\image-20230106020941752.png)	

### ·委托构造函数：

~~~
委托构造函数（delegating constructor）是 C++11 引入的特性，它允许一个构造函数调用同一个类中的另一个构造函数来完成对象的初始化。通过使用委托构造函数，可以避免代码的冗余和重复。
~~~

![image-20230106021004141](D:\typora笔记\图片\image-20230106021004141.png)

·这里就委托其他构造函数【Clock（0，0，0）】初始化；

![image-20230106021036393](D:\typora笔记\图片\image-20230106021036393.png)	

#### ·案例说明：

当一个类有多个构造函数时，可以使用委托构造函数来重用初始化逻辑。下面是一个更详细的示例：

```cpp
#include <iostream>

class MyClass {
public:
    // 构造函数1，接收一个整数参数
    MyClass(int value) {
        std::cout << "Constructor 1: " << value << std::endl;
        // 执行特定的初始化逻辑
    }

    // 构造函数2，使用委托构造函数
    MyClass() : MyClass(0) {
        std::cout << "Constructor 2" << std::endl;
        // 可选的其他初始化逻辑
    }
};

int main() {
    MyClass obj1(10);  // 调用构造函数1，输出 "Constructor 1: 10"
    MyClass obj2;     // 调用构造函数2，委托给构造函数1，输出 "Constructor 1: 0"，然后输出 "Constructor 2"

    return 0;
}
```

在上述示例中，`MyClass` 类有两个构造函数：构造函数1和构造函数2。构造函数1接收一个整数参数，并输出相关信息。构造函数2使用了委托构造函数的方式，在初始化列表中调用构造函数1，并输出相关信息。

在 `main` 函数中，创建了两个 `MyClass` 类的对象 `obj1` 和 `obj2`。`obj1` 使用构造函数1，传入参数值为10，输出 "Constructor 1: 10"。`obj2` 使用构造函数2，它会委托调用构造函数1，并输出 "Constructor 1: 0"，然后输出 "Constructor 2"。

通过这个例子，可以看到委托构造函数的使用方式。构造函数2在初始化列表中使用委托构造函数语法 `:` 来调用构造函数1，实现了重用初始化逻辑的效果。

注意：上述示例中只演示了委托构造函数的基本用法，实际应用中可以根据需要添加更多的构造函数和初始化逻辑。

------



### ·复制构造函数：

![image-20230106021158221](D:\typora笔记\图片\image-20230106021158221.png)	

![image-20230106021247608](D:\typora笔记\图片\image-20230106021247608.png)	

#### ·案例说明：

复制构造函数（copy constructor）是一种特殊的构造函数，用于创建一个新对象，该对象是已有对象的精确副本。复制构造函数通常用于实现对象的深拷贝，确保新对象拥有独立的资源，而不仅仅是简单地复制指针或引用。

复制构造函数的语法如下：

```cpp
class MyClass {
public:
    // 复制构造函数
    MyClass(const MyClass& other) {
        // 执行深拷贝操作
    }
};
```

在上述示例中，`MyClass` 类定义了一个复制构造函数，参数类型为 `const MyClass&`，表示传入的是一个常量引用，用于引用要被复制的对象。

在复制构造函数的函数体内，可以执行适当的深拷贝操作，例如分配新的内存并将数据复制到新对象中，以确保新对象与原对象是独立的。

复制构造函数通常用于以下情况：

1. 通过一个已有对象创建一个新对象，这样两个对象具有相同的数据。
2. 将对象作为参数传递给函数时，会调用复制构造函数来创建副本。

需要注意的是，如果不提供自定义的复制构造函数，编译器会自动生成一个默认的复制构造函数，它会逐个成员进行简单的逐位复制。但对于有动态分配内存或资源管理的类，可能需要自定义复制构造函数以实现深拷贝。

使用示例：

```cpp
#include <iostream>

class MyClass {
public:
    int data;

    // 构造函数
    MyClass(int value) : data(value) {
        std::cout << "Constructor called: " << data << std::endl;
    }

    // 复制构造函数
    MyClass(const MyClass& other) : data(other.data) {
        std::cout << "Copy constructor called: " << data << std::endl;
    }
};

void foo(MyClass obj) {
    std::cout << "Inside foo: " << obj.data << std::endl;
}

int main() {
    MyClass obj1(10);       // 调用构造函数，输出 "Constructor called: 10"
    MyClass obj2 = obj1;    // 隐式调用复制构造函数，输出 "Copy constructor called: 10"

    foo(obj2);              // 隐式调用复制构造函数，输出 "Copy constructor called: 10"，然后输出 "Inside foo: 10"

    return 0;
}

```

在上述示例中，`MyClass` 类包含了一个动态分配的 `int` 类型的成员变量 `data`。在构造函数中进行内存分配，在析构函数中释放内存。

为了确保在复制对象时进行深拷贝，自定义了复制构造函数。它在复制对象时创建了一个新的 `int` 对象，并将原对象的值复制给新对象，从而实现了独立的拷贝。

总结起来，复制构造函数用于创建一个新对象，它是已有对象的精确副本。通过自定义复制构造函数，可以实现适当的深拷贝操作，确保新对象独立于原对象。

------

### ·构造函数：成员初始化怎么用？

~~~
以上面复制函数的代码为例：
~~~

在上述代码中，`data(value)` 是一个**成员初始化列表（member initialization list）**。它用于在构造函数中初始化类成员变量。

成员初始化列表位于**构造函数的开头**，紧跟在函数头部的冒号后面。它的**语法是** `成员变量名(表达式)`，其中成员变量名是要初始化的类成员变量的名称，而表达式则是用于提供初始值的值或表达式。

使用成员初始化列表的**好处**是，在构造函数体内，类成员变量已经被正确初始化，可以直接使用，而不需要在构造函数体内再进行赋值操作。

以下是一个示例，演示了成员初始化列表的用法：

```cpp
class MyClass {
public:
    int data;

    // 构造函数
    MyClass(int value) : data(value) {
        // 在成员初始化列表中初始化 data 成员变量
        // 等效于在构造函数体内使用 data = value;
    }
};
```

在上述示例中，`MyClass` 类的构造函数使用成员初始化列表来初始化 `data` 成员变量。通过 `data(value)`，将传入的 `value` 值赋给 `data` 成员变量。

使用成员初始化列表的优点是，它可以更直接和高效地初始化类成员变量。特别是对于成员变量是常量或引用类型的情况，只能通过成员初始化列表来进行初始化。

需要注意的是，成员初始化列表只能在构造函数中使用，并且只能用于初始化类成员变量，而不能用于局部变量或其他目的。

总结起来，成员初始化列表是一种在构造函数中初始化类成员变量的语法，它可以在构造函数体内之前使用。通过成员初始化列表，可以直接将初始值赋给类成员变量，提供更简洁和高效的初始化方式。

------

### ·浅拷贝和深拷贝的区别：

浅拷贝（Shallow Copy）和深拷贝（Deep Copy）是在对象复制过程中常用的两种拷贝方式，它们之间的区别在于对于包含动态分配内存的对象如何处理。

浅拷贝是指将一个对象的值复制到另一个对象，包括对象中的所有成员变量。对于包含指针或引用类型成员变量的对象，浅拷贝只会复制指针或引用的值，而不会复制指针或引用指向的实际数据。这意味着原对象和新对象会共享同一块内存，对其中一个对象的修改会影响到另一个对象。

深拷贝是指创建一个新对象，并复制原对象中的所有值和资源。对于包含指针或引用类型成员变量的对象，深拷贝会创建新的内存空间，并将原对象指针或引用指向的实际数据复制到新的内存空间中。这样，原对象和新对象拥有各自独立的内存空间，对其中一个对象的修改不会影响到另一个对象。

下面通过一个示例来说明浅拷贝和深拷贝的区别：

```cpp
#include <iostream>

class MyClass {
public:
    int* data;

    // 构造函数
    MyClass(int value) {
        data = new int(value);
    }

    // 复制构造函数（浅拷贝）
    MyClass(const MyClass& other) {
        data = other.data;
    }

    // 析构函数
    ~MyClass() {
        delete data;
    }
};

int main() {
    MyClass obj1(10);           // 创建对象 obj1，data 指向值为 10 的内存
    MyClass obj2 = obj1;        // 浅拷贝，obj2 的 data 指向 obj1 的 data 指针指向的内存

    // 修改 obj2 的 data 值
    *obj2.data = 20;

    // 打印 obj1 和 obj2 的 data 值
    std::cout << *obj1.data << std::endl;   // 输出 20，obj1 和 obj2 共享同一块内存
    std::cout << *obj2.data << std::endl;   // 输出 20

    return 0;
}
```

在上述示例中，定义了一个 `MyClass` 类，其中包含一个动态分配的 `int` 类型的成员变量 `data`。

在 `main` 函数中，首先创建了一个对象 `obj1`，并将 `data` 成员变量指向值为 10 的内存。然后，通过浅拷贝将 `obj1` 赋值给 `obj2`，导致 `obj2` 的 `data` 成员变量指向与 `obj1` 相同的内存。

随后，修改 `obj2` 的 `data` 值为 20，由于 `obj1` 和 `obj2`的 `data` 成员变量指向同一块内存，因此对 `obj2` 的修改也会影响到 `obj1`。

这就是浅拷贝的效果，即对象之间共享同一块内存，对其中一个对象的修改会影响到其他对象。

为了避免这种共享内存的问题，我们可以使用深拷贝来创建对象的副本，确保每个对象都有自己独立的内存空间。下面是一个使用深拷贝的示例：

```cpp
#include <iostream>

class MyClass {
public:
    int* data;

    // 构造函数
    MyClass(int value) {
        data = new int(value);
    }

    // 复制构造函数（深拷贝）
    MyClass(const MyClass& other) {
        data = new int(*other.data);
    }

    // 析构函数
    ~MyClass() {
        delete data;
    }
};

int main() {
    MyClass obj1(10);           // 创建对象 obj1，data 指向值为 10 的内存
    MyClass obj2 = obj1;        // 深拷贝，obj2 的 data 指向新的内存，值为 10

    // 修改 obj2 的 data 值
    *obj2.data = 20;

    // 打印 obj1 和 obj2 的 data 值
    std::cout << *obj1.data << std::endl;   // 输出 10，obj1 保持原值不受影响
    std::cout << *obj2.data << std::endl;   // 输出 20

    return 0;
}
```

在上述示例中，通过在复制构造函数中进行深拷贝，即创建了新的内存空间，并将原对象的 `data` 指针指向的值复制到新的内存空间中。这样，`obj1` 和 `obj2` 就拥有各自独立的内存空间，修改其中一个对象的 `data` 值不会影响到另一个对象。

总结起来，浅拷贝和深拷贝是对象复制过程中的两种方式。浅拷贝只复制指针或引用，导致多个对象共享同一块内存，对其中一个对象的修改会影响到其他对象。而深拷贝创建对象的副本，并复制实际数据到新的内存空间，确保每个对象都有自己独立的内存空间，修改一个对象不会影响其他对象。选择使用浅拷贝还是深拷贝取决于具体的需求和对象的特性。

------



### ·delete：

![image-20230106021405210](D:\typora笔记\图片\image-20230106021405210.png)	

·用于释放内存块；

[`::`] `delete`*cast-expression*
[`::`] `delete []`*cast-expression*

*cast-expression* 自变量必须是指向以前分配给使用 [new 运算符](https://learn.microsoft.com/zh-cn/cpp/cpp/new-operator-cpp?view=msvc-170)创建的对象的内存块的指针。 **`delete`** 运算符的结果类型为 **`void`**，因此它不返回值。 例如：

~~~c++
CDialog* MyDialog = new CDialog;
// use MyDialog
delete MyDialog;
~~~

对指向不使用 **`new`** 分配的对象的指针使用 **`delete`** 将产生不可预知的结果。 但是，可以对值为 0 的指针使用 **`delete`**。 此设置意味着，在失败时 **`new`** 返回 0 时，删除已失败的 **`new`** 操作的结果不会造成损害。

#### ·删除数组：

**`new`** 和 **`delete`** 运算符还可用于内置类型（包括数组）。 如果 `pointer` 指的是某一数组，请在 `pointer` 前放置空括号 (`[]`)：	

~~~c
int* set = new int[100];
//use set[]
delete [] set;
~~~

https://www.cnblogs.com/hazir/p/new_and_delete.html





### ·使用复制构造函数的情况：(一知半解)

![image-20230106021602343](D:\typora笔记\图片\image-20230106021602343.png)	

#### ·案例：

![image-20230106021638967](D:\typora笔记\图片\image-20230106021638967.png)	![image-20230106021650494](D:\typora笔记\图片\image-20230106021650494.png)	

![image-20230106022149846](D:\typora笔记\图片\image-20230106022149846.png)	

### ·左值右值：（这里解释的不清楚，看上面的笔记）

https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/

![image-20230106022216211](D:\typora笔记\图片\image-20230106022216211.png)	

![image-20230106022426608](D:\typora笔记\图片\image-20230106022426608.png)	

~~~txt
·左值就相当于一个引用，表示一个内存地址；
·右值就相当于一个临时变量，一个实际的值，而不是内存地址；
~~~

------

### ·&&运算符：

在 C++ 中，`&&` 是右值引用（Rvalue Reference）的语法表示。

右值引用是 C++11 引入的新特性，用于标识一个对象是右值。右值表示临时对象、将要销毁的对象或可以被移动的对象。

右值引用的主要目的是支持移动语义（Move Semantics），即在对象的转移过程中，通过移动资源而不是复制资源，提高程序的性能。

在移动构造函数和移动赋值运算符等场景中，通常会使用右值引用。其语法如下：

```cpp
T&&
```

其中，`T` 是类型，表示对象的类型。`&&` 表示右值引用修饰符，用于声明右值引用类型。

右值引用可以用于以下几种情况：

1. 移动语义：用于实现移动构造函数和移动赋值运算符，将资源从一个对象移动到另一个对象。
2. 完美转发：用于实现通用的转发函数，能够正确地将参数转发给其他函数，维护值类别和引用类型。
3. 临时对象：在需要构造临时对象或绑定到临时对象上时，可以使用右值引用来延长其生命周期。

在移动构造函数的示例代码中，`MyClass(MyClass&& other)` 中的 `&&` 表示右值引用类型。它接受一个右值对象（临时对象、将要销毁的对象）作为参数，用于实现对象的移动操作。

通过右值引用，可以区分左值（左值引用）和右值，从而实现特定的语义和操作。

需要注意的是，为了触发移动构造函数或使用右值引用参数，可以使用 `std::move` 函数将一个对象转换为右值引用。例如：

```cpp
MyClass obj1;
MyClass obj2 = std::move(obj1);  // 将 obj1 转为右值引用，触发移动构造函数
```

总结起来，右值引用是 C++11 引入的特性，用于标识右值对象并支持移动语义。通过 `&&` 语法，可以声明右值引用类型，并在移动构造函数、移动赋值运算符等场景中使用。右值引用的引入使得在对象的转移过程中可以高效地移动资源，提高程序性能。

#### ·move函数：

~~~
标准库中的一个函数，用于对象移动操作；
~~~

`std::move` 是一个 C++ 标准库中的函数模板，位于 `<utility>` 头文件中。

`std::move` 函数用于将一个对象转换为右值引用，以便在移动语义下使用。它的定义如下：

```cpp
template <typename T>
typename std::remove_reference<T>::type&& move(T&& arg) noexcept;
```

`std::move` 接受一个参数 `arg`，类型为模板类型 `T` 的右值引用 `T&&`。它将参数 `arg` 转换为右值引用，并返回对应的右值引用。

`std::move` 的主要目的是用于标识一个对象为右值，并提供一种简洁的方式将对象转移给移动构造函数、移动赋值运算符等。通过使用 `std::move`，可以显式地表达对对象资源的移动操作，而不是进行不必要的拷贝。

在之前的示例中，我提到了使用 `std::move` 将一个对象转换为右值引用，从而触发移动构造函数的调用。这样可以避免不必要的拷贝操作，提高程序的性能。

需要注意的是，使用 `std::move` 时需要谨慎，确保被转移的对象不再被使用，以免出现悬空引用或使用无效资源的情况。移动后的对象通常处于一种有效但不可预测的状态。

总结起来，`std::move` 是一个 C++ 标准库中的函数模板，用于将对象转换为右值引用，触发移动语义。通过使用 `std::move`，可以显式地将对象转移给移动构造函数、移动赋值运算符等，避免不必要的拷贝，提高程序性能。

------



### ·移动构造函数：

#### ·实例说明：

**·使用运算符 &&，对右值进行暂存操作；**

移动构造函数（Move Constructor）是C++11引入的特殊成员函数，用于在对象的移动语义下进行构造。它允许将资源（如动态分配的内存）**从一个对象移动到另一个对象，而不是进行传统的复制操作**。

移动构造函数的语法如下：

```cpp
class MyClass {
public:
    // 移动构造函数
    MyClass(MyClass&& other) {
        // 对资源进行移动操作
        // 将 other 的资源转移给当前对象
        // 然后将 other 的资源置为有效的默认状态
    }
};
```

在移动构造函数中，参数类型是右值引用 `&&`，表示被移动对象的临时值或即将销毁的对象。移动构造函数内部的逻辑通常涉及资源的转移，如指针的交换、数据的移动等操作。

移动构造函数的使用场景通常是在以下情况下：

1. 对象的复制构造函数的开销较大，而通过移动可以更高效地将资源转移到新对象中；
2. 对象拥有独占性资源，如动态分配的内存、文件句柄等，可以通过移动构造函数避免不必要的资源复制。

下面是一个示例，演示如何使用移动构造函数：

```cpp
#include <iostream>

class MyClass {
public:
    int* data;

    // 构造函数
    MyClass(int value) {
        data = new int(value);
    }

    // 移动构造函数
    MyClass(MyClass&& other) {
        data = other.data;          // 移动资源
        other.data = nullptr;       // 将原对象的资源置为无效状态
    }

    // 析构函数
    ~MyClass() {
        delete data;
    }
};

int main() {
    MyClass obj1(10);               // 创建对象 obj1
    MyClass obj2 = std::move(obj1); // 使用移动构造函数将 obj1 的资源移动给 obj2

    // 尝试访问 obj1 的 data（已经移动）
    std::cout << obj1.data << std::endl;    // 输出 0，指向无效的内存

    // 访问 obj2 的 data（已经移动）
    std::cout << *obj2.data << std::endl;   // 输出 10

    return 0;
}
```

在上述示例中，定义了一个 `MyClass` 类，其中包含了一个动态分配的 `int` 类型的成员变量 `data`。

在 `main` 函数中，创建了对象 `obj1` 并初始化其 `data` 成员变量。然后，使用 `std::move` 将 `obj1` 的资源移动给 `obj2`，通过调用移动构造函数实现。

移动构造函数内部，将 `other.data` 的值赋给当前对象的 `data`，然后将 `other.data` 置为 `nullptr`，表示原对象的资源已被移动。

需要注意的是，**在移动构造函数中，移动后的对象不再拥有原来的资源，因此要确保原对象在移动后的状态下不会被误用，一般将其指针置为无效状态或特定的默认值。**

在 `main` 函数中，可以看到通过移动构造函数将 `obj1` 的资源移动给了 `obj2`，`obj1` 的 `data` 指针被置为 `nullptr`，表示其不再拥有有效的资源。而 `obj2` 正确地继承了原对象的资源，并可以继续使用。

移动构造函数的使用可以提高程序的效率，特别是在处理大型对象或资源密集型操作时。通过移动而不是复制对象，可以避免不必要的资源拷贝和内存分配，提高程序的性能。

需要注意的是，移动构造函数只在特定的条件下被调用，通常是在将右值对象（临时对象、将要销毁的对象）赋值给新对象时。可以使用 `std::move` 函数显式地将一个对象转换为右值引用，以触发移动构造函数的调用。

总结起来，移动构造函数是C++11引入的特殊成员函数，用于在对象的移动语义下进行构造。它允许将资源从一个对象移动到另一个对象，提高程序的效率。通过定义移动构造函数，可以显式控制对象资源的移动，避免不必要的拷贝操作，提高代码的性能。

------



### ·析构函数：

![image-20230106022906884](D:\typora笔记\图片\image-20230106022906884.png)

![image-20230106022937592](D:\typora笔记\图片\image-20230106022937592.png)	

·不允许有形参；





### ·类的组合：

·组合：即一个类的成员是另一个类的数据类型；

#### ·类组合构造函数：

![image-20230108200513765](D:\typora笔记\图片\image-20230108200513765.png)	

#### ·构造函数初始化次序：

![image-20230108200836682](D:\typora笔记\图片\image-20230108200836682.png)	

·先初始化成员，在初始化本类构造函数；

####  ·案例：

·点类：

![image-20230108201011698](D:\typora笔记\图片\image-20230108201011698.png)	

·线段类：内部成员是point类；

![image-20230108201029872](D:\typora笔记\图片\image-20230108201029872.png)

#### ·构造函数：

![image-20230108201234451](D:\typora笔记\图片\image-20230108201234451.png)	

![image-20230108201304312](D:\typora笔记\图片\image-20230108201304312.png)	

·主函数：

![image-20230108201537265](D:\typora笔记\图片\image-20230108201537265.png)

·**这里创建对象，先创建point，再创建line；**



### ·构造函数的调用顺序：

在一个类中，当成员对象作为该类的成员时，它们的构造函数的调用顺序取决于它们在类中的声明顺序，而不是它们在成员初始化列表中的顺序。

具体来说，当创建包含其他类对象的类对象时，构造函数的调用顺序如下：

1. 首先，基类的构造函数会被调用。如果有多个基类，它们的构造函数会按照它们在派生类中声明的顺序依次调用。
2. 接下来，按照它们在类中声明的顺序，依次调用成员对象的构造函数。
3. 最后，调用派生类自身的构造函数。

下面是一个示例代码来说明构造函数的调用顺序：

```cpp
#include <iostream>

class A {
public:
    A() {
        std::cout << "A Constructor" << std::endl;
    }
};

class B {
public:
    B() {
        std::cout << "B Constructor" << std::endl;
    }
};

class C {
public:
    C() {
        std::cout << "C Constructor" << std::endl;
    }
};

class MyClass {
private:
    A a;
    B b;
    C c;

public:
    MyClass() {
        std::cout << "MyClass Constructor" << std::endl;
    }
};

int main() {
    MyClass obj;
    return 0;
}
```

输出结果将按照构造函数的调用顺序输出：

```
A Constructor
B Constructor
C Constructor
MyClass Constructor
```

在上述示例中，`MyClass` 包含了 `A`、`B`、`C` 作为成员对象。根据构造函数的调用顺序，首先调用 `A` 的构造函数，然后调用 `B` 的构造函数，最后调用 `C` 的构造函数，最终调用 `MyClass` 自身的构造函数。

需要注意的是，**在析构函数中，对象的销毁顺序与构造函数的调用顺序相反**。也就是说，首先调用派生类自身的析构函数，然后按照成员对象的声明顺序依次调用析构函数，最后调用基类的析构函数。这确保了构造函数和析构函数的调用顺序相匹配。

总结起来，当一个类中包含其他类对象作为成员时，**构造函数的调用顺序是**基类构造函数 -> 成员对象构造函数 -> 派生类构造函数。它们的调用顺序取决于它们在类中的声明顺序。

------



### ·前向引用声明：

![image-20230108202044518](D:\typora笔记\图片\image-20230108202044518.png)	

![image-20230108202120863](D:\typora笔记\图片\image-20230108202120863.png)	

·错误案例：

![image-20230108202217345](D:\typora笔记\图片\image-20230108202217345.png)	

·这里在定义时，对象成员信息并不明确；



#### ·注意事项：

![image-20230108202315529](D:\typora笔记\图片\image-20230108202315529.png)	

·当内联成员是其他类数据类型，在这个类提供完整声明之前，不能使用；





## 7.数据共享与保护：

### ·作用域：

#### ·函数原型作用域（最小作用域）

![image-20230108202657340](D:\typora笔记\图片\image-20230108202657340.png)	

#### ·局部作用域：

![image-20230108202736457](D:\typora笔记\图片\image-20230108202736457.png)	

#### ·类作用域：

![image-20230108204253658](D:\typora笔记\图片\image-20230108204253658.png)	

#### ·命名空间作用域：

![image-20230108204635711](D:\typora笔记\图片\image-20230108204635711.png)	

##### **·案例说明：**

命名空间（Namespace）是 C++ 中用于将全局标识符划分为不同逻辑区域的一种机制。命名空间提供了一种组织和管理代码的方式，以避免名称冲突和碰撞。

命名空间的作用域是指定义在命名空间内的标识符（变量、函数、类等）在该命名空间内可见并可访问。通过使用命名空间，可以将相关的代码组织在一起，并提供一定的隔离性。

命名空间的基本语法如下：

```cpp
namespace namespace_name {
    // 声明和定义代码
}
```

其中，`namespace_name` 是命名空间的名称，可以是任意有效的标识符。在命名空间中，可以包含变量、函数、类、结构体等代码实体的声明和定义。

命名空间的使用方式有两种：

1. 命名空间限定符：通过在标识符前加上命名空间的名称和作用域解析运算符 `::`，可以访问命名空间内的成员。例如：`namespace_name::identifier`。
2. 使用 `using` 声明：使用 `using` 关键字可以引入整个命名空间或命名空间内的特定成员，使得在代码中可以直接使用这些成员，而无需使用限定符。

命名空间的使用场景包括但不限于以下几种情况：

1. 避免名称冲突：当不同的库、模块或代码文件中存在相同名称的标识符时，使用命名空间可以将它们分隔开，避免冲突。
2. 代码组织与模块化：将相关的代码放置在同一个命名空间中，可以提高代码的可读性和维护性，便于进行模块化开发。
3. 第三方库的使用：当使用第三方库时，为了避免与自己的代码发生冲突，可以将库的代码放置在自己的命名空间中，以示区别和隔离。
4. 嵌套命名空间：命名空间可以嵌套使用，通过使用多级命名空间，可以更细致地划分代码结构，提高代码组织和管理的灵活性。

下面是一个简单的示例，展示了命名空间的用法和场景：

```cpp
#include <iostream>

// 声明一个命名空间
namespace Geometry {
    const double PI = 3.14159;

    // 声明一个圆类
    class Circle {
    private:
        double radius;

    public:
        Circle(double r) : radius(r) {}

        double getArea() {
            return PI * radius * radius;
        }
    };
}

int main() {
    Geometry::Circle circle(5.0);  // 使用命名空间限定符创建 Circle 对象
    double area = circle.getArea();  // 使用命名空间限定符调用成员函数

    std::cout << "Circle Area: " << area << std::endl;

    return 0;
}

/*  
在上述示例中，我们创建了一个命名空间 Geometry，用于组织几何相关的代码。在该命名空间中，我们声明了一个常量 PI 和一个圆类 Circle。圆类有一个私有成员 radius 和一个公有成员函数 getArea()，用于计算圆的面积。

在 main() 函数中，我们使用命名空间限定符 Geometry:: 来创建 Circle 对象并调用成员函数。这样，我们可以清晰地区分和访问命名空间中的成员。

通过使用命名空间，我们将几何相关的代码组织在一起，使得代码更具可读性和可维护性。如果在该程序中还有其他几何相关的类或函数，可以都放置在 Geometry 命名空间中，使得代码更加模块化和结构化。
*/
```



#### ·限定作用域枚举类：

![image-20230108204829994](D:\typora笔记\图片\image-20230108204829994.png)	

##### ·案例说明：

枚举类（Enum Class）是 C++11 引入的一种类型安全的枚举类型，它提供了更强的类型检查和作用域限定，避免了传统枚举类型的一些问题。枚举类的语法如下：

```cpp
enum class EnumName {
    Enumerator1,
    Enumerator2,
    // ...
};
```

其中，`EnumName` 是枚举类的名称，`Enumerator1`、`Enumerator2` 是枚举类的枚举值（或称为枚举成员）。枚举值可以是整数、字符等常量表达式。

相比于传统的枚举类型，枚举类有以下特点：
1. 枚举值的作用域限定：枚举值在枚举类的作用域内，不会污染全局命名空间。
2. 类型安全：枚举类的枚举值不能隐式转换为整数类型，也不能与其他枚举类进行混合运算。
3. 枚举值的显式指定：枚举值可以显式指定其对应的整数值。

下面是一个示例，展示了如何定义和使用枚举类：

```cpp
#include <iostream>

enum class Day {
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday
};

int main() {
    Day today = Day::Wednesday;  // 使用枚举类的枚举值

    switch (today) {
        case Day::Monday:
            std::cout << "Today is Monday." << std::endl;
            break;
        case Day::Tuesday:
            std::cout << "Today is Tuesday." << std::endl;
            break;
        case Day::Wednesday:
            std::cout << "Today is Wednesday." << std::endl;
            break;
        // ...
    }

    return 0;
}
```

在上述示例中，我们定义了一个枚举类 `Day`，其中包含了一周的每一天作为枚举值。我们使用 `Day::` 来限定枚举值的作用域。

在 `main()` 函数中，我们声明并初始化一个 `Day` 类型的变量 `today`，并将其设置为 `Day::Wednesday`。然后，我们使用 `switch` 语句根据 `today` 的值输出相应的提示信息。

需要注意的是，由于枚举类的枚举值是类型安全的，无法与其他整数类型进行隐式转换，也不能与其他枚举类进行混合运算。这样可以避免一些潜在的错误和问题，并提供更强的类型检查。



##### ·数据类型：

C++ 的枚举类成员**只能是整数类型（包括整数和字符类型）**。以下是一些常见的枚举类成员数据类型的示例：

```cpp
enum class Month {
    JANUARY = 1,
    FEBRUARY,
    MARCH,
    APRIL,
    MAY,
    JUNE,
    JULY,
    AUGUST,
    SEPTEMBER,
    OCTOBER,
    NOVEMBER,
    DECEMBER
};

enum class Color : char {
    RED = 'R',
    GREEN = 'G',
    BLUE = 'B'
};

enum class Status : short {
    OK = 200,
    BAD_REQUEST = 400,
    NOT_FOUND = 404,
    INTERNAL_SERVER_ERROR = 500
};
```

在上述示例中，我们定义了三个不同的枚举类，每个枚举类成员都有不同的底层数据类型：

1. `Month` 枚举类的成员使用默认的底层数据类型 `int`，并从 1 开始递增。这里的枚举成员是整数类型。
2. `Color` 枚举类的成员使用底层数据类型 `char`，并将每个枚举成员显式指定为一个字符。这里的枚举成员是字符类型。
3. `Status` 枚举类的成员使用底层数据类型 `short`，并将每个枚举成员显式指定为一个整数值。这里的枚举成员是短整数类型。

需要注意的是，枚举类成员的数据类型是由枚举类的定义中指定的底层数据类型决定的。枚举成员必须是其底层数据类型的合法值。

------



#### ·可见性：

![image-20230108205002929](D:\typora笔记\图片\image-20230108205002929.png)	

·案例：

![image-20230108205039113](D:\typora笔记\图片\image-20230108205039113.png)	

·在内部使用被屏蔽的全局作用域变量：

![image-20230108205220269](D:\typora笔记\图片\image-20230108205220269.png)	



### ·对象生存期：

![image-20230108205357106](D:\typora笔记\图片\image-20230108205357106.png)	

#### ·静态生存期：

![image-20230108205414558](D:\typora笔记\图片\image-20230108205414558.png)	

#### ·动态生存期：

![image-20230108205440886](D:\typora笔记\图片\image-20230108205440886.png)	

#### ·案例：

~~~c
//全局变量具有静态生存期；
//使用static修饰的比哪里具有全局寿命
~~~



![image-20230108205524290](D:\typora笔记\图片\image-20230108205524290.png)

![image-20230108205636393](D:\typora笔记\图片\image-20230108205636393.png)

**·这两个函数的静态变量互不影响；但是生存期和当前程序一致；即使函数结束了，该值仍然存活；**	

![image-20230108205958941](D:\typora笔记\图片\image-20230108205958941.png)		

##### ·代码说明：

静态生存期适用于具有静态存储持续时间的变量。在 C++ 中，具备静态生存期的变量包括：

1. 静态成员变量（类变量）：在类中声明为静态的成员变量，在程序运行期间只有一个实例，并且生命周期从程序开始到程序结束。

```cpp
class MyClass {
    static int staticVar; // 静态成员变量
};

int MyClass::staticVar = 0; // 静态成员变量的定义和初始化

int main() {
    // ...
    return 0;
}
```

在上述示例中，`staticVar` 是 `MyClass` 类的静态成员变量，它在程序运行期间只有一个实例，且生命周期从程序开始到程序结束。

2. 静态局部变量：在函数体内使用 `static` 关键字声明的局部变量。它们在首次进入声明语句时初始化，并在整个程序执行期间保持其值，生命周期延长到整个程序的运行期间。

```cpp
void myFunction() {
    static int staticVar = 0; // 静态局部变量
    // ...
}

int main() {
    myFunction();
    // ...
    return 0;
}
```

在上述示例中，`staticVar` 是 `myFunction` 函数的静态局部变量，它在首次进入声明语句时初始化，并在整个程序执行期间保持其值。

需要注意的是，静态生存期的变量不受作用域限制，可以在声明它们的作用域之外访问。静态成员变量可以通过类名和作用域解析运算符 `::` 来访问，而静态局部变量可以通过函数名和作用域解析运算符来访问。

------



### ·对象间的共享：

#### ·目录：

![image-20230108210040091](D:\typora笔记\图片\image-20230108210040091.png)	

#### ·静态数据成员：

![image-20230108210240462](D:\typora笔记\图片\image-20230108210240462.png)	

#### ·案例：

![image-20230108210359730](D:\typora笔记\图片\image-20230108210359730.png)	

·这里的count变量是属于类的，该类所有的实例共享；

![image-20230108210516694](D:\typora笔记\图片\image-20230108210516694.png)	

#### ·静态函数成员：

![image-20230108210729195](D:\typora笔记\图片\image-20230108210729195.png)	

##### ·案例：

![image-20230108210842846](D:\typora笔记\图片\image-20230108210842846.png)	

·这里的showCount方法属于整个类共用的；

·即使使用a.showCount（）调用，进入showCount方法后，看不到是哪个对象调用的这个方法，**this对象不会在静态函数中体现**；



#### ·类的友元：

友元可以用于以下方面：

1. 访问私有成员：友元关系允许其他类或函数访问一个类的私有成员，包括私有变量和私有成员函数。通过将其他类或函数声明为友元，可以打破类的封装性，使其能够直接访问受限制的成员。

2. 提供操作符重载：友元函数可以用于重载类的操作符，使其能够对类对象进行特定的操作。通过声明为友元函数，可以在函数中直接访问类的私有成员，从而实现对操作符的重载。

3. 辅助函数或工具函数：友元函数可以作为类的辅助函数或工具函数，提供与类相关的功能，但不属于类的成员函数。这些函数能够访问类的私有成员，以便完成特定的任务。

4. 访问其他类的私有成员：友元关系不仅限于在类内部声明，还可以在全局范围内声明。这样，一个类可以成为另一个类的友元类，使得友元类能够访问其私有成员。

5. 继承关系：友元关系可以应用于继承关系中，使得派生类能够访问基类的私有成员。

6. 模板类和模板函数：友元关系可以在模板类或模板函数中使用，使其能够访问其他类的私有成员。

总体而言，友元关系提供了一种在需要时授权其他类或函数访问受限制成员的方式。它在某些特定的情况下可以提供更灵活的访问控制，但应谨慎使用，以确保封装性和安全性不受破坏。

------

·单向的授权；

![image-20230108211305750](D:\typora笔记\图片\image-20230108211305750.png)	

·要求：

![image-20230108211348965](D:\typora笔记\图片\image-20230108211348965.png)	

##### ·案例：

![image-20230108211441923](D:\typora笔记\图片\image-20230108211441923.png)	

![image-20230108211503747](D:\typora笔记\图片\image-20230108211503747.png)	

·这里使用友元，使x，y不需要调用get方法，只需要直接使用即可；

**·函数形参推荐用引用，这样开销小，不用发生复制构造，为了避免使用引用+友元时，源对象数据被修改，可使用常量；**



##### 案例：

![image-20230108211913328](D:\typora笔记\图片\image-20230108211913328.png)·这里A授权给B，使B能够访问A的私有成员； 	



##### ·单向：

![image-20230108211939302](D:\typora笔记\图片\image-20230108211939302.png)	

------



##### ·代码案例：

在 C++ 中，友元（friend）是一种特殊的关系，它**允许一个类或函数访问另一个类的私有成员**。通过使用友元关键字 `friend`，可以**将其他类**或函数**声明为当前类的友元**，从而允许它们访问当前类的私有成员。

下面是一个详细的示例，展示了友元的使用和特点：

```cpp
#include <iostream>

// 前向声明
class B;

class A {
private:
    int privateData;

public:
    A() : privateData(0) {}

    void displayData(B& b);

    friend class B; // B 类是 A 类的友元类
};

class B {
private:
    int privateData;

public:
    B() : privateData(0) {}

    void modifyData(A& a, int value) {
        a.privateData = value; // 可以访问 A 类的私有成员 privateData
    }

    void displayData(A& a) {
        std::cout << "Data in A: " << a.privateData << std::endl; // 可以访问 A 类的私有成员 privateData
    }
};

void A::displayData(B& b) {
    std::cout << "Data in B: " << b.privateData << std::endl; // 可以访问 B 类的私有成员 privateData
}

int main() {
    A objA;
    B objB;

    objA.displayData(objB); // A 类访问 B 类的私有成员 privateData
    objB.modifyData(objA, 42); // B 类访问 A 类的私有成员 privateData
    objA.displayData(objB); // A 类访问 B 类的私有成员 privateData

    return 0;
}
```

在上述示例中，我们有两个类：`A` 和 `B`。`A` 类声明了 `B` 类为友元类，这意味着 `B` 类可以访问 `A` 类的私有成员 `privateData`。同样，`B` 类可以访问 `A` 类的私有成员。

在 `A` 类的成员函数 `displayData()` 中，我们可以访问 `B` 类的私有成员 `privateData`，并在 `main()` 函数中通过调用 `objA.displayData(objB)` 来演示。

在 `B` 类的成员函数 `modifyData()` 中，我们可以访问 `A` 类的私有成员 `privateData`，并在 `main()` 函数中通过调用 `objB.modifyData(objA, 42)` 来演示。

通过友元关系，`A` 类和 `B` 类能够互相访问彼此的私有成员，从而实现了一种特殊的关系和访问权限。



**·友元的友元函数、友元类、友元类的成员函数、友元类的继承：**（暂时用不上）

------



#### **·共享数据的保护：**

##### ·常对象：

![image-20230108212338560](D:\typora笔记\图片\image-20230108212338560.png)	

##### ·常成员：	![image-20230108212651527](D:\typora笔记\图片\image-20230108212651527.png)



##### ·案例：

![image-20230108212730356](D:\typora笔记\图片\image-20230108212730356.png)	 

![image-20230108212856823](D:\typora笔记\图片\image-20230108212856823.png)	

**·常对象只能调用对应的常函数；不允许调用非常函数；会报错：**

![image-20230108212934724](D:\typora笔记\图片\image-20230108212934724.png)	



##### ·常数据成员案例：

![image-20230108213126581](D:\typora笔记\图片\image-20230108213126581.png)

![image-20230108213251193](D:\typora笔记\图片\image-20230108213251193.png)	

·这里的a**只能在初始化列表里面赋值**，不能在大括号里面赋值（简而言之不能在**函数体**中改变常成员）

------



##### ·常引用：

~~~c
"重点：：："//（关键就在于【引用】，只是引用而已，不能修改！！！）
~~~



~~~c++
int i=42;
const int &r1=i;
const int &r2=42;//允许常量引用绑定一个常量值，或者非常量对象

const int &r3=r1*2;
int &r4=r1*2; // 错误 引用的类型必须与其所引用的对象  数据类型  一致；这里r4是普通的非常量引用，而r1是常量引用，赋给r4，相当于r4可以修改r1所引用的对象，因此是非法的；

/*
实际上，这行代码 `int &r4 = r1 * 2;` 会导致编译错误。

在 C++ 中，表达式 `r1 * 2` 的结果是一个临时的右值（即临时对象），而非常量引用只能绑定到左值（即可修改的对象）。因此，将右值赋给非常量引用是不允许的。

如果你想要创建一个引用来保存乘法结果，你可以使用 const 引用，如下所示：

const int &r4 = r1 * 2;

这样，`r4` 将成为一个常量引用，可以绑定到乘法结果的临时值。请注意，这里的 `r4` 是一个常量引用，不能修改它所绑定的值。

如果你需要一个可修改的引用来保存乘法结果，你可以将其声明为变量而不是引用：

int result = r1 * 2;

这样，`result` 将成为一个变量，存储乘法结果的值，并且你可以修改它。
*/
~~~

~~~c++
	int i = 42;
	int j = 90;
	const int &r1 = i;
	const int &r2 = 42;//允许常量引用绑定一个常量值，或者非常量对象

	const int &r3 = r1 * 2;
	r1 = j;  //为什么这行会报错？？
	int x = r1*5; //这行是没问题的，因为r1常量引用，就相当于引用了一个变量的值，改变i的值后，r1引用的值也会变



"重点：：："//（关键就在于【引用】，只是引用而已，不能修改！！！）
~~~

这行代码 `r1 = j;` 会导致编译错误，因为 `r1` 是一个常量引用，不能通过赋值运算符修改其绑定的值。

在 C++ 中，常量引用被设计为只能读取其绑定的值，而不能修改它。当你尝试通过赋值运算符修改常量引用时，编译器会报错，以保护常量引用的只读特性。

在你提供的代码中，`r1` 是一个常量引用，它引用了变量 `i` 的值。当你尝试将变量 `j` 的值赋给 `r1` 时，实际上是试图修改 `r1` 引用的值，这是不允许的。

如果你想要修改 `r1` 引用的值，你需要将 `r1` 声明为非常量引用，如下所示：

```cpp
int& r1 = i;
```

这样，`r1` 将成为一个非常量引用，可以修改其所绑定的值。但请注意，在这种情况下，你需要确保 `i` 是一个可修改的变量，否则尝试修改 `r1` 引用的值可能导致未定义的行为。

总结起来，常量引用只能读取值，不能修改；非常量引用可以修改值。在赋值操作中，常量引用不能被修改，因此 `r1 = j;` 会导致编译错误。

------

![image-20230108213628508](D:\typora笔记\图片\image-20230108213628508.png)	

![image-20230108213646751](D:\typora笔记\图片\image-20230108213646751.png)



​	

## 8.分文件编写程序：

[函数分文件编写](onenote:https://d.docs.live.net/8511fccf5af68114/文档/唐俊 的笔记本/C++.one#函数分文件编写&section-id={85DE8669-9D8B-434E-B026-FAE667F23461}&page-id={6FD56A6A-3EBE-4566-9873-CB1AFE976342}&end) ([Web 视图](https://onedrive.live.com/view.aspx?resid=8511FCCF5AF68114!354&id=documents&wd=target(C%2B%2B.one|85DE8669-9D8B-434E-B026-FAE667F23461%2F函数分文件编写|6FD56A6A-3EBE-4566-9873-CB1AFE976342%2F)))

·oneNote笔记：





## 9.数组：

![image-20230108215250870](D:\typora笔记\图片\image-20230108215250870.png)	

### ·定义：

![image-20230108215353072](D:\typora笔记\图片\image-20230108215353072.png)

![image-20230108215536643](D:\typora笔记\图片\image-20230108215536643.png)	

### ·一维数组：

·数组名是常量，代表数组元素的首地址；

![image-20230108215644052](D:\typora笔记\图片\image-20230108215644052.png)	

#### ·初始化方式：

![image-20230108215722103](D:\typora笔记\图片\image-20230108215722103.png)	

### ·二维数组：

·存储顺序是按行展开；

![image-20230108215850173](D:\typora笔记\图片\image-20230108215850173.png)	

#### ·初始化方式：

·一维下标可省略：

![image-20230108220023992](D:\typora笔记\图片\image-20230108220023992.png)	

#### ·数组作为参数：

·传递的是数组的首地址；

![image-20230108220101117](D:\typora笔记\图片\image-20230108220101117.png)

​	

### ·常数组：

![image-20230108220443904](D:\typora笔记\图片\image-20230108220443904.png)	

·这里数组的每个元素都不能改变；

**·允许形参定义好数组的二维长度；**

------



### ·数组地址：

![image-20230108220710253](D:\typora笔记\图片\image-20230108220710253.png)	

![image-20230108220719018](D:\typora笔记\图片\image-20230108220719018.png)	





### ·对象数组：

![image-20230108220844451](D:\typora笔记\图片\image-20230108220844451.png)	

#### ·初始化：

![image-20230108220910989](D:\typora笔记\图片\image-20230108220910989.png)	

#### ·对象数组的析构：

·数组中每删除一个对象，就会调用该对象的析构函数；

![image-20230108221013933](D:\typora笔记\图片\image-20230108221013933.png)	

![image-20230108221042267](D:\typora笔记\图片\image-20230108221042267.png)	

·这里定义了两个Point对象，a数组；因此构造函数调用了两次，系统为这两个无名对象分配内存空间；对象中的值根据默认规则初始化；





## 10.指针：

·内存空间的访问方式：

1.变量名访问；2.地址访问；

### ·地址运算符：

·表示获取该变量的**首字节地址**；

![image-20230108221610010](D:\typora笔记\图片\image-20230108221610010.png)	



### ·指针：

·**指针=内存地址**；

·**指针变量：**专门保存地址的变量；

![image-20230108221655577](D:\typora笔记\图片\image-20230108221655577.png)	

![image-20230108221822733](D:\typora笔记\图片\image-20230108221822733.png)	

~~~c
*ptr就是找到指针ptr所指向的对象  的目标地址；相当于指针寻址的过程，找到地址为2000的目标位置；
~~~





#### ·指针的类型：

![image-20230108222246833](D:\typora笔记\图片\image-20230108222246833.png)	

·根据指针定义时标示的数据类型，表示该指针所指向的对象的数据类型；



#### ·指针初始化：![image-20230108222413646](D:\typora笔记\图片\image-20230108222413646.png)

~~~
·不能用非静态变量，初始化静态指针，非静态变量生命周期比静态短；变量消亡了，静态指针还活着；
~~~







#### ·指针所占用的内存空间：

[指针占的内存空间](onenote:https://d.docs.live.net/8511fccf5af68114/文档/唐俊 的笔记本/C++.one#指针占的内存空间&section-id={85DE8669-9D8B-434E-B026-FAE667F23461}&page-id={73163083-DA99-426C-ACF4-0C149BEBD88D}&end) ([Web 视图](https://onedrive.live.com/view.aspx?resid=8511FCCF5AF68114!354&id=documents&wd=target(C%2B%2B.one|85DE8669-9D8B-434E-B026-FAE667F23461%2F指针占的内存空间|73163083-DA99-426C-ACF4-0C149BEBD88D%2F)))





#### ·指针运算：

![image-20230108222730546](D:\typora笔记\图片\image-20230108222730546.png)	

~~~c
·无类型指针什么数据类型都可以存，但取数据不能用；只能存地址；

//·0赋值给指针就是空指针；
~~~

**·nullptr关键字；**

![image-20230108222842489](D:\typora笔记\图片\image-20230108222842489.png)	

##### ·案例说明：

当我们谈论nullptr时，需要先了解空指针的概念。在C++中，空指针表示指向无效或不存在的内存地址。空指针不指向任何有效的对象或函数。

在早期的C++版本中，使用整数0表示空指针，因为0不是有效的内存地址。然而，这种用法可能会引起一些歧义，因为0也可以表示整数值。

为了解决这个问题，C++11引入了nullptr关键字。nullptr是一个特殊的字面值，表示空指针。它的类型是nullptr_t，可以隐式转换为任何指针类型。

使用nullptr可以带来以下好处：

1. 清晰明确：nullptr用于表示空指针，没有歧义，易于阅读和理解代码意图。
2. 类型安全：nullptr具有自己的类型nullptr_t，与其他类型不会发生混淆。

使用nullptr很简单。你可以将nullptr直接赋值给指针变量，或者将其用作函数调用的参数。下面是一些使用nullptr的示例：

```cpp
int* ptr = nullptr;  // 将指针ptr初始化为空指针
if (ptr == nullptr)  // 检查指针是否为空
{
    // 执行一些操作
}

void foo(int* ptr)
{
    if (ptr == nullptr)
    {
        // 指针为空时的处理逻辑
    }
    else
    {
        // 指针不为空时的处理逻辑
    }
}

foo(nullptr);  // 将空指针作为函数参数传递
```

在这些示例中，我们将指针初始化为空指针，使用nullptr进行比较，以及将nullptr作为函数参数传递。

总结起来，nullptr是C++11引入的表示空指针的关键字。它提供了一种明确且类型安全的方式来表示空指针，避免了0带来的歧义。在代码中使用nullptr可以提高可读性和类型安全性。

------



### ·指向常量的指针：

**·从左往右的顺序读，即可知道指针类型；**

·常量 + 指针 = 常量指针； 指向常量的指针，指向可以变，指向的值不能变；

![image-20230108222943900](D:\typora笔记\图片\image-20230108222943900.png)	

### ·指针常量：

·指针+常量 = 指针常量；  该指针的值不能改变，指向的对象的值可以改变；

![image-20230108223152589](D:\typora笔记\图片\image-20230108223152589.png)	

### ·指针的运算：

![image-20230108223246602](D:\typora笔记\图片\image-20230108223246602.png)	

![image-20230108223331528](D:\typora笔记\图片\image-20230108223331528.png)·这个定义只有在指针指向的数据类型，存储地址是连续的才有意义；

·例如一个指针指向int数组，++相当于移动4个字节，到下一个数组元素；

![image-20230108223604044](D:\typora笔记\图片\image-20230108223604044.png)	



#### ·指针关系运算：

·指向相同数据的指针，则地址相同，是 == 的；

![image-20230108223715875](D:\typora笔记\图片\image-20230108223715875.png)	

##### ·详细说明：

指针在关系运算中可以进行以下比较操作：

1. 相等性比较（==）：可以比较两个指针是否指向相同的内存地址。如果两个指针指向同一个内存地址，则它们相等，返回true；否则返回false。

2. 不等性比较（!=）：与相等性比较相反，可以比较两个指针是否指向不同的内存地址。如果两个指针指向不同的内存地址，则它们不相等，返回true；否则返回false。

3. 大小比较（<、<=、>、>=）：可以比较两个指针所指向的内存地址的相对顺序。在进行大小比较时，编译器通常使用指针所指向的内存地址作为比较依据。具体的比较规则如下：

   - 如果两个指针指向相同的内存地址，则它们被视为相等，大小比较的结果为false。
   - 如果两个指针指向不同的内存地址，编译器会比较它们的内存地址值。较小的内存地址被认为是较小的指针，较大的内存地址被认为是较大的指针。

需要注意的是，进行指针比较时需要满足一些前提条件：

1. 指针必须指向同一种类型的对象或者函数。
2. 指针必须是有效的指针，即不能是空指针或未初始化的指针。

下面是一些使用指针进行关系运算的示例：

```cpp
int* ptr1 = new int(10);
int* ptr2 = new int(5);
int* ptr3 = ptr1;

if (ptr1 == ptr2) {
    // 执行逻辑，因为ptr1和ptr2指向不同的内存地址
}

if (ptr1 != ptr2) {
    // 执行逻辑，因为ptr1和ptr2指向不同的内存地址
}

if (ptr1 == ptr3) {
    // 执行逻辑，因为ptr1和ptr3指向相同的内存地址
}

if (ptr1 < ptr2) {
    // 执行逻辑，因为ptr1指向的内存地址比ptr2小
}

delete ptr1;
delete ptr2;
```

在上述示例中，我们创建了两个指针ptr1和ptr2，分别指向不同的内存地址。我们还创建了指针ptr3，并将其指向ptr1指向的内存地址。然后我们进行了相等性比较、不等性比较和大小比较操作，并根据比较结果执行相应的逻辑。

需要注意的是，**指针的关系运算仅仅比较指针所指向的内存地址，并不考虑内存地址中存储的具体值。**

------



## 11.指针数组：

·a[1] 实际上等价于  内存地址xxx [1]  ，即内存地址+下标1；

![image-20230110030909481](D:\typora笔记\图片\image-20230110030909481.png)	

### ·例子：

![image-20230110031130972](D:\typora笔记\图片\image-20230110031130972.png)	

### ·指针输出数组：

![image-20230110031203792](D:\typora笔记\图片\image-20230110031203792.png)	

### ·指针变量：

·a是数组首地址，+10即a后面的十个内存地址；

![image-20230110031436622](D:\typora笔记\图片\image-20230110031436622.png)	

### ·指针数组：

![image-20230110031733077](D:\typora笔记\图片\image-20230110031733077.png)	

·定义指针二维数组：

·在需要频繁交换数组行的情况下，使用指针数组能更快交换；

![image-20230110031901896](D:\typora笔记\图片\image-20230110031901896.png)

![image-20230110032152070](D:\typora笔记\图片\image-20230110032152070.png)		



## 12.指针字符串:

### ·指针作为函数参数：

![image-20230115172942647](D:\typora笔记\图片\image-20230115172942647.png)	

### ·案例：

![image-20230115173328272](D:\typora笔记\图片\image-20230115173328272.png)	

·当不希望传入的对象在函数中被改变，就可以使用常量指针；



### ·指针函数：

![image-20230115173534602](D:\typora笔记\图片\image-20230115173534602.png)	

### · **错误案例：**![image-20230115184234190](D:\typora笔记\图片\image-20230115184234190.png)	

![image-20230115184307991](D:\typora笔记\图片\image-20230115184307991.png)**·这个错误是作用域导致的；**



### **·正确案例：**

**·注意：**

![image-20230115184609932](D:\typora笔记\图片\image-20230115184609932.png)	

![image-20230115184544966](D:\typora笔记\图片\image-20230115184544966.png)	

### **·内存泄漏：**

![image-20230115184640586](D:\typora笔记\图片\image-20230115184640586.png)	

### **·函数指针：**

​	![image-20230115184929192](D:\typora笔记\图片\image-20230115184929192.png)	

·这个指针表示内存中可执行的函数体，不是高级语言，是编译过的；





### ·函数指针实现函数回调： 

#### ·案例：

![image-20230115193543132](D:\typora笔记\图片\image-20230115193543132.png)	

![image-20230115193636685](D:\typora笔记\图片\image-20230115193636685.png)**·将函数的首地址传入；**	



### ·指向对象的指针：

![image-20230115193745987](D:\typora笔记\图片\image-20230115193745987.png)	

![image-20230115193908036](D:\typora笔记\图片\image-20230115193908036.png)	

![image-20230115194014724](D:\typora笔记\图片\image-20230115194014724.png)	

![image-20230115194241387](D:\typora笔记\图片\image-20230115194241387.png)	





## 13.动态授权内存：

·没有括号和初始化参数，就不进行初始化，内存中的内容不确定；

![image-20230115194451295](D:\typora笔记\图片\image-20230115194451295.png)	

### ·动态申请数组：

![image-20230115194715240](D:\typora笔记\图片\image-20230115194715240.png)	

~~~c++
char (*fp)[3] //这里表示char [3] 一维数组，fp是指向这个一维数组的指针；
~~~

![image-20230115195331312](D:\typora笔记\图片\image-20230115195331312.png)	

### ·释放内存：

![image-20230115195549468](D:\typora笔记\图片\image-20230115195549468.png)	

### ·案例：



![image-20230115195644158](D:\typora笔记\图片\image-20230115195644158.png)·删除空间后指针还在，还可以使用；

![image-20230115195740300](D:\typora笔记\图片\image-20230115195740300.png)		

### ·创建多维数组：

 ![image-20230115195915452](D:\typora笔记\图片\image-20230115195915452.png)

![image-20230115200049129](D:\typora笔记\图片\image-20230115200049129.png)	

### ·动态数组封装为类：

![image-20230115200112918](D:\typora笔记\图片\image-20230115200112918.png)	

### ·案例：

![image-20230115200155981](D:\typora笔记\图片\image-20230115200155981.png)	

·这里定义了一个数组类；assert是在

### ·案例：

![image-20230115200341824](D:\typora笔记\图片\image-20230115200341824.png)	

### ·vector：

![image-20230115201213341](D:\typora笔记\图片\image-20230115201213341.png)	

![image-20230115201619346](D:\typora笔记\图片\image-20230115201619346.png)	

![image-20230115201648790](D:\typora笔记\图片\image-20230115201648790.png)	

### ·案例：

![image-20230115201714661](D:\typora笔记\图片\image-20230115201714661.png)	

![image-20230115201733093](D:\typora笔记\图片\image-20230115201733093.png)	

### ·api案例：

![image-20230115201752853](D:\typora笔记\图片\image-20230115201752853.png)	

·begin，end：相当于迭代器；指向首元素的泛型指针；





## 14.类的继承：

​	![image-20230115202236254](D:\typora笔记\图片\image-20230115202236254.png)	

### ·目的：

![image-20230115202306545](D:\typora笔记\图片\image-20230115202306545.png)	

### ·单继承：

![image-20230115202416186](D:\typora笔记\图片\image-20230115202416186.png)	

### ·多继承：

![image-20230115202522717](D:\typora笔记\图片\image-20230115202522717.png)	

### ·派生类结构：

​	![image-20230115202638477](D:\typora笔记\图片\image-20230115202638477.png)

### ·继承方式：

![image-20230115202717580](D:\typora笔记\图片\image-20230115202717580.png)	

### ·公有继承：

![image-20230115202807592](D:\typora笔记\图片\image-20230115202807592.png)	



### ·protected成员：

·对于子类来说，与public成员性质相同；对于非子类来说，与private相同，不可直接访问；

![image-20230115203324982](D:\typora笔记\图片\image-20230115203324982.png)	

### ·private继承：

·父类的成员在子类中都是private修饰；

![image-20230115203610869](D:\typora笔记\图片\image-20230115203610869.png)	

### ·多继承案例：

![image-20230115204040095](D:\typora笔记\图片\image-20230115204040095.png)	

### ·向上转型：

![image-20230115204910015](D:\typora笔记\图片\image-20230115204910015.png)	

### ·案例：

![image-20230115205056305](D:\typora笔记\图片\image-20230115205056305.png)	

![image-20230115205250583](D:\typora笔记\图片\image-20230115205250583.png)·这里定义的函数都是非虚函数；

~~~c++
 /*在一个类里定义了一个const成员函数后，则此函数不能修改类中的成员变量，如果定义了一个类的const对象（非const对象可以调用const成员函数和非const成员hanshu )，它只能调用类中的const成员函数，如：*/

class text{
        public:
               void print_const(void) const   { cout<<"hello"<<endl;}          //有const修饰

              void print(void) {cout<<"hello"<<endl;}            //没有const修饰

             void getk(void)  const  {k=5; }          //错误，有const修饰，不能修改k的值，

      private:

             int k;
};

const text a;

int main()

{
            a.print();           //错误，const对象只能调用const成员函数

           a.printf_const();   //正确
}
~~~





### ·继承关系下，子类父类（派生类与基类）的构造函数，析构函数：

 ![image-20230116000925440](D:\typora笔记\图片\image-20230116000925440.png)	

·子类继承基类，基类的成员是自动调用基类的构造函数初始化的；

·子类使用using调用基类构造函数；11版本；

#### ·语法：

![image-20230116002502377](D:\typora笔记\图片\image-20230116002502377.png)	

#### ·案例：

·基类：

![image-20230116002701836](D:\typora笔记\图片\image-20230116002701836.png)	

·子类：

![image-20230116002736798](D:\typora笔记\图片\image-20230116002736798.png)	



#### ·多继承构造函数：

![image-20230116002815098](D:\typora笔记\图片\image-20230116002815098.png)	



#### ·多继承且有组合情况（成员是类对象）：

#### ![image-20230116002928041](D:\typora笔记\图片\image-20230116002928041.png)·构造函数的执行顺序：

![image-20230116002950257](D:\typora笔记\图片\image-20230116002950257.png)	

![image-20230116003152097](D:\typora笔记\图片\image-20230116003152097.png)	

·在构造函数中，应该根据在类中的声明顺序来写构造函数，提高程序可读性；



#### ·赋值构造函数：

![image-20230116003550983](D:\typora笔记\图片\image-20230116003550983.png)	

#### ·析构函数：

![image-20230116003712479](D:\typora笔记\图片\image-20230116003712479.png)	



### ·基类成员访问：

·案例：只需要标示类名；

![image-20230116003935104](D:\typora笔记\图片\image-20230116003935104.png)	

#### ·二义性：

·两个类存在同名成员；尽量避免；	![image-20230116004012730](D:\typora笔记\图片\image-20230116004012730.png)	

#### ·虚基类：

·第一季继承就要将共同基类设计为虚基类；

![image-20230116004227790](D:\typora笔记\图片\image-20230116004227790.png)	

![image-20230116004313233](D:\typora笔记\图片\image-20230116004313233.png)	

#### ·案例：

![image-20230116004335174](D:\typora笔记\图片\image-20230116004335174.png)	

![image-20230116004356094](D:\typora笔记\图片\image-20230116004356094.png)	

base1，base2访问var0，访问的都是同一个变量base0；



#### ·案例：虚基类构造函数：

![image-20230116004609478](D:\typora笔记\图片\image-20230116004609478.png)	

![image-20230116004639793](D:\typora笔记\图片\image-20230116004639793.png)	

**·这里base1，base2共同基类是base0；**

**·若不使用虚基类，会导致derived多次基础base0；使用虚基类，最远派生类derived就不会重复继承base0；base0基类只会为最远派生类derived提供一个虚基类；不会重复复制；**





#### ·语法：

![image-20230116004910707](D:\typora笔记\图片\image-20230116004910707.png)	

### ·小结：

![image-20230116004956489](D:\typora笔记\图片\image-20230116004956489.png)	



## 15.虚函数：

~~~c++
class Animal
{
public:
    Animal(const string& name):
        m_name{name}
    {}

    const string& getName() const
    {
        return m_name;
    }

    string speak() const
    {
        return "???";
    }

private:
    string m_name;
};



class Cat : public Animal
{
public:
    Cat(const string& name): 
        Animal(name)
    {}

    string speak() const
    {
        return "Meow";
    }
};



class Dog : public Animal
{
public:
    Dog(const string& name):
        Animal(name)
    {}

    string speak() const
    {
        return "Woof";
    }
};
~~~

【虚函数】虚就虚在所谓"推迟联编"或者"动态联编"上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为"虚"函数。

·这里cat和dog都继承animal，重写了speak（）方法；但实际调用时，调用的仍是基类的方法；

~~~c
int main()
{
    Cat cat{ "Fred" };
    cout << "Cat is named " << cat.getName() << ", and it says " << cat.speak() << endl;

    Dog dog{ "Carbo" };
    cout << "Dog is named " << dog.getName() << ", and it says " << dog.speak() << endl;

    Animal* catAnimal = &cat;
    cout << "Cat is named " << catAnimal->getName() << ", and it says " << catAnimal->speak() << endl;

    Animal& dogAnimal = dog;
    cout << "Dog is named " << dogAnimal.getName() << ", and it says " << dogAnimal.speak() << endl;

        return 0;
}

/**
cat is named Fred, and it says Meow
dog is named Garbo, and it says Woof
pAnimal is named Fred, and it says ???
pAnimal is named Garbo, and it says ???
*/
~~~

·要想**实现基类调用子类重写的方法**，需要使用虚函数；

~~~c
class Animal
{
public:
    Animal(const string& name):
        m_name{name}
    {}

    const string& getName() const
    {
        return m_name;
    }

    virtual string speak() const  //这里使用了虚函数
    {
        return "???";
    }

private:
    string m_name;
};

class Cat : public Animal
{
public:
    Cat(const string& name): 
        Animal(name)
    {}

    virtual string speak() const
    {
        return "Meow";
    }
};

class Dog : public Animal
{
public:
    Dog(const string& name):
        Animal(name)
    {}

    virtual string speak() const
    {
        return "Woof";
    }
};
~~~

调用结果：

~~~c
int main()
{
    Cat cat{ "Fred" };
    cout << "Cat is named " << cat.getName() << ", and it says " << cat.speak() << endl;

    Dog dog{ "Carbo" };
    cout << "Dog is named " << dog.getName() << ", and it says " << dog.speak() << endl;

    Animal* catAnimal = &cat;
    cout << "Cat is named " << catAnimal->getName() << ", and it says " << catAnimal->speak() << endl;

    Animal& dogAnimal = dog;
    cout << "Dog is named " << dogAnimal.getName() << ", and it says " << dogAnimal.speak() << endl;

        return 0;
}
/** 
output:
cat is named Fred, and it says Meow
dog is named Garbo, and it says Woof
cat is named Fred, and it says Meow
dog is named Garbo, and it says Woof
*/
~~~

### ·虚函数概念：

虚函数是类方法中的一种特殊函数，当你调用它时，它会匹配派生最远的重写版本。这种特性是多态性。匹配的规则是相同的函数签名（函数名，参数个数与类型）以及返回类型（返回类型可以不相同，但必须存在派生关系）。

·虚函数必须是非静态成员函数，必须属于对象；

### ·虚表与动态绑定：

·根据虚表找到虚函数调用；

![image-20230125170809552](D:\typora笔记\图片\image-20230125170809552.png)	

### ·虚表示意图：

![image-20230125170857487](D:\typora笔记\图片\image-20230125170857487.png)	

### ·virtual关键字：

·不写该关键字，根据虚函数规则判断该函数是否是虚函数；

![image-20230125171004484](D:\typora笔记\图片\image-20230125171004484.png)	

### ·虚函数成员：

![image-20230125171402970](D:\typora笔记\图片\image-20230125171402970.png)	

### ·虚析构函数：

![image-20230125171824571](D:\typora笔记\图片\image-20230125171824571.png)·这种方式只会执行基类的虚构函数，不会执行子类的虚构函数；**解决方式：**将虚函数声明为virtual，即可正常运行；

![image-20230125172014655](D:\typora笔记\图片\image-20230125172014655.png)	



### ·构造函数，析构函数不能调用虚函数：

·注意千万不要在构造函数与析构函数中调用虚函数。我们知道派生类对象在创建时，首先基类部分先被创建，如果你在基类构造函数调用虚函数时，它此时将无法调用派生类版本的函数，因为派生类对象还未创建，此时派生类虚函数没有作用的对象。那么，它只能调用基类版本的虚函数。对于析构函数，派生类对象中的派生部分先被析构，如果你在基类析构函数中调用了虚函数，它也只能调用基类版本的虚函数，因为派生类对象已经不存在了。

·其实对于Java语言来说，所有的方法默认是虚函数。但是使用虚函数是有代价的，相对于普通函数，虚函数的调用代价稍高，但是这种差别不会太大，所以还是建议所有方法都使用`virtual`关键字。



### ·Override标识符：

~~~c
class Super
{
public:
    virtual string getName1(int x)
    {
        return "Super";
    }

    virtual string getName2(int x)
    {
        return "Super";
    }
};

class Sub: public Super
{
public:
    virtual string getName1(double x) //这里参数不一致
    {
        return "Sub";
    }

    virtual string getName2(int x) const //这里参数不一致，多了const
    {
        return "Sub";
    }
};

int main()
{
    Sub sub;
    Super* super = &sub;

    cout << super->getName1(1) << endl;  // output: Super
    cout << super->getName2(2) << endl;  // output: Super

    cin.ignore(10);
    return 0;
}
~~~

我们修改了基类虚函数，但是没有更新派生类的对应重载版本，也将有可能使重写失效。为了避免这样的错误，**C++引入了`override`标识符**，使用这个标识符告诉编译器这是重写的方法，如果方法不匹配，那么将无法通过编译。用`override`修改代码如下：

~~~c++
class Super
{
public:
    virtual string getName1(int x)
    {
        return "Super";
    }

    virtual string getName2(int x)
    {
        return "Super";
    }
};

class Sub: public Super
{
public:
    virtual string getName1(double x) override  //关键字
    {
        return "Sub";
    }

    virtual string getName2(int x) const override
    {
        return "Sub";
    }
    // 此时无法编译
};
~~~



### final标识符：

~~~c++
class A
{
public:
    virtual void someMethod() { cout << "A" << endl; }
}

class B: public A
{
public:
    // 基类A的someMethod方法没有final标识符，那么B可以重写该方法
    // 但是此虚方法使用了final标识符，后面的派生类无法重写
    virtual void someMethod() override final { cout << "B" << endl; }
}

class C: public B
{
public:
    // 无法编译，因为不允许重写
    virtual void someMethod() override { cout << "C" << endl; }
}
~~~

![image-20230125172416847](D:\typora笔记\图片\image-20230125172416847.png)	



### ·更多知识补充：

https://zhuanlan.zhihu.com/p/54145222



### ·显式覆盖作用：

![image-20230125172316485](D:\typora笔记\图片\image-20230125172316485.png)	





## 16.抽象类：

![image-20230125172051908](D:\typora笔记\图片\image-20230125172051908.png)	

### ·纯虚函数：（不允许创建对象）

纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 **=0**:

~~~c
virtual void funtion1()=0
~~~

·声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。

·**纯虚函数最显著的特征是**：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。

·定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。

·纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的默认实现。所以类纯虚函数的声明就是在告诉子类的设计者，"你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它"。

![image-20230125172145256](D:\typora笔记\图片\image-20230125172145256.png)	



### ·虚函数与纯虚函数的区别：

定义一个函数为虚函数，不代表函数为不被实现的函数。

定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

定义一个函数为纯虚函数，才代表函数没有被实现。

定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。



### ·虚函数小结：

纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。

·虚函数报错不实现报错：

~~~c
error LNK****: unresolved external symbol "public: virtual void __thiscall ClassName::virtualFunctionName(void)"
~~~





## 17.运算符重载：

![image-20230127002326127](D:\typora笔记\图片\image-20230127002326127.png)	

### ·重载规则（重载为成员函数）：

![image-20230127002415015](D:\typora笔记\图片\image-20230127002415015.png)	

![image-20230127002956963](D:\typora笔记\图片\image-20230127002956963.png)	

### ·代码案例：

![image-20230127002600277](D:\typora笔记\图片\image-20230127002600277.png)	

![image-20230127002733851](D:\typora笔记\图片\image-20230127002733851.png)	

![image-20230127002813431](D:\typora笔记\图片\image-20230127002813431.png)	

#### ·执行结果：

![image-20230127002854657](D:\typora笔记\图片\image-20230127002854657.png)	

### ·双目运算符重载规则：

![image-20230127003104016](D:\typora笔记\图片\image-20230127003104016.png)·具体可参考上方红色部分；B在这里表示一个运算符；	



### ·单目运算符 前置/后置++ -- 如何区分？

#### ·代码案例：

![image-20230127003319287](D:\typora笔记\图片\image-20230127003319287.png)	

![image-20230127003426606](D:\typora笔记\图片\image-20230127003426606.png)	![image-20230127003852265](D:\typora笔记\图片\image-20230127003852265.png)··这里后置++返回的是局部变量，不能返回地址，直接返回对象；

~~~c
#include <iostream>

int main()
{
    int i = 0;
    int a = 0;
    a=i++;//此时a=0
    std::cout << a;//a=0
    if (a >= 1) {
        std::cout << "Hello World!\n";
    }
    std::cout << i;//i=1

    /**  
    由此可以说明，i++，++i在没有给其他变量赋值的情况下，效果是相同的；
    反之如果有赋值给其他变量的操作，就会出现差异，前置后置；
    */

    int i = 0;
    i++;//此时i=1
    std::cout << i;//i=1
    if (i >= 1) {//i=1
        std::cout << "Hello World!\n";
    }
    std::cout << i;//i=1
}
~~~





#### ·执行结果：

·这里先执行了后置++，再执行前置++；

#### ![image-20230127004027455](D:\typora笔记\图片\image-20230127004027455.png)			

### ·代码案例2：

![image-20230127004652572](D:\typora笔记\图片\image-20230127004652572.png)	

![image-20230127004804041](D:\typora笔记\图片\image-20230127004804041.png)	![image-20230127004817668](D:\typora笔记\图片\image-20230127004817668.png)	

![image-20230127194858077](D:\typora笔记\图片\image-20230127194858077.png)	

### ·运算符重载为非成员函数的规则：

![image-20230127195011733](D:\typora笔记\图片\image-20230127195011733.png)	







## 18.模板与群体数据：

## ·函数模板：

·使用情景：

![image-20230127195551631](D:\typora笔记\图片\image-20230127195551631.png)	

### ·示例程序：

![image-20230127200106913](D:\typora笔记\图片\image-20230127200106913.png)	

### ·语法：

![image-20230127200137017](D:\typora笔记\图片\image-20230127200137017.png)	

### ·示例程序：

![image-20230127200318063](D:\typora笔记\图片\image-20230127200318063.png)	

![image-20230127200342781](D:\typora笔记\图片\image-20230127200342781.png)	

### ·三点注意事项：

·函数模板不能处理所有数据类型；

·只有能够进行函数模板运算的类型，可以作为类型实参；（例如模板的 class T，就是类型实参，传入int数据类型，这里的class就是int，可以进行函数模板运算）；

·自定义的类需要重载运算符才可以作为类型实参；



## ·类模板：

### ·定义：

![image-20230127200925172](D:\typora笔记\图片\image-20230127200925172.png)	

![image-20230127201219353](D:\typora笔记\图片\image-20230127201219353.png)	

### ·模板默认实参：

![image-20230127201333411](D:\typora笔记\图片\image-20230127201333411.png)	

![image-20230127201529562](D:\typora笔记\图片\image-20230127201529562.png)	

### ·函数返回地址：

~~~c++
int& print()
{
	int a = 10;
	int &b = a;
	
	return b;	
}

int* print()
{
	int *a = new int(10);
	
	return a;	
}
~~~

![image-20230127201909436](D:\typora笔记\图片\image-20230127201909436.png)	

·这里定义了函数模板，使用函数模板附加到类模板上



·这里使用结构体，using两种方式体现类模板的使用：

![image-20230127202135963](D:\typora笔记\图片\image-20230127202135963.png)	





## ·线性群体：

### ·群体：

![image-20230127202524292](D:\typora笔记\图片\image-20230127202524292.png)	

### ·线性群体：

![image-20230127202547697](D:\typora笔记\图片\image-20230127202547697.png)	

### ·直接访问线性群体：

![image-20230127202626350](D:\typora笔记\图片\image-20230127202626350.png)	

### ·示例程序：

![image-20230127203749061](D:\typora笔记\图片\image-20230127203749061.png)

![image-20230127204343055](D:\typora笔记\图片\image-20230127204343055.png)·这里的const函数重载，是提供给常对象使用的；	

·指针转换运算符重载：用于将当前对象转为指针数据类型；

![image-20230127205051604](D:\typora笔记\图片\image-20230127205051604.png)	



### ·为什么要返回引用？

·右值，即放在赋值运算符右边的值，代表的是对象的值，修改这个值，源对象不会被修改；

·左值，即放在赋值运算符左边的值，代表对象的地址（引用/别名），通过改变这个值，可以修改源对象的值；

![image-20230127204403323](D:\typora笔记\图片\image-20230127204403323.png)	

### ·示例程序：

![image-20230127204611065](D:\typora笔记\图片\image-20230127204611065.png)	



### ·程序解释：

·复制构造函数：

![image-20230127205312587](D:\typora笔记\图片\image-20230127205312587.png)	

·重载深层复制，一般也要重载赋值运算符；

![image-20230127205747063](D:\typora笔记\图片\image-20230127205747063.png)	

·c++中赋值运算符是简单赋值；

·如果要判断两个类对象是否相等或不相等，需要重载== 或 ！=运算符，或使用函数：

~~~c++
#include <iostream>
 
class Node {
public:
    int x, y;
    Node(int x, int y): x(x), y(y) {}
    bool operator==(const Node& rhs) const;
};
 
bool Node::operator==(const Node& rhs) const {
    return x == rhs.x and y == rhs.y;
}
 
int main()
{
    Node node1(1, 1);
    Node node2(1, 1);
 
    bool isEqual = (node1 == node2);
    std::cout << std::boolalpha << isEqual << std::endl;
 
    return 0;
}
~~~

~~~c++
/**  
对象比较应该在对确定其相等性至关重要的所有字段上进行。从 C++11 开始，我们可以构造一个 std::tie 轻松匹配多个字段，如下所示：
*/
#include <iostream>
#include <tuple>
 
class Node {
public:
    int x, y;
    Node(int x, int y): x(x), y(y) {}
    bool operator==(const Node& rhs) const;
};
 
bool Node::operator==(const Node& rhs) const {
    return std::tie(x, y) == std::tie(rhs.x, rhs.y);
}
 
int main()
{
    Node node1(1, 1);
    Node node2(1, 1);
 
    bool isEqual = (node1 == node2);
    std::cout << std::boolalpha << isEqual << std::endl;
 
    return 0;
}
~~~

**网站说明：**https://www.techiedelight.com/zh/compare-two-objects-in-cpp/  









·重载下标运算符：

![image-20230127210809699](D:\typora笔记\图片\image-20230127210809699.png)	

·重载指针转换运算符：

![image-20230127210915309](D:\typora笔记\图片\image-20230127210915309.png)	

![image-20230127211128934](D:\typora笔记\图片\image-20230127211128934.png)	

·resize函数：

![image-20230127211320009](D:\typora笔记\图片\image-20230127211320009.png)	

### ·实际使用：

![image-20230127211343035](D:\typora笔记\图片\image-20230127211343035.png)	

![image-20230127211419717](D:\typora笔记\图片\image-20230127211419717.png)	









## 

## 从这里开始的模板，自己找代码看：

## 







## ·链表类模板：

·无头节点单链表：

![image-20230131073545952](D:\typora笔记\图片\image-20230131073545952.png)	

### ·单链表类模板：

![image-20230131073634606](D:\typora笔记\图片\image-20230131073634606.png)	

![image-20230131073821534](D:\typora笔记\图片\image-20230131073821534.png)	

![image-20230131073952692](D:\typora笔记\图片\image-20230131073952692.png)	

·返回被删除的节点，不像java，这里空间不会被释放；

### ·完整代码：

![image-20230131074344169](D:\typora笔记\图片\image-20230131074344169.png)	

![image-20230131074411862](D:\typora笔记\图片\image-20230131074411862.png)	



### ·双链表类模板：

![image-20230131074553822](D:\typora笔记\图片\image-20230131074553822.png)	

![image-20230131074524514](D:\typora笔记\图片\image-20230131074524514.png)	

![image-20230131074918229](D:\typora笔记\图片\image-20230131074918229.png)	

~~~c++

//1.类结构定义
class Node
{
public:
    int data;
    Node * last;
    Node * next;

};
//2.构造函数
class DoubleNode
{
private:
    Node * head;   //头结点
    Node * tail;   //尾节点
};
DoubleNode::DoubleNode()
{
    head = nullptr;
    tail = nullptr;

}
//3.析构函数
DoubleNode::~DoubleNode()
{
    if(getsize()!=0)//空表就没必要调析构了
    {
        Node *ptemp = head;
        Node *p;
        while(ptemp!=nullptr&&ptemp->next!=nullptr)
        {
            p=ptemp;
            ptemp=ptemp->next;
            delete p;
            p=nullptr;
        }
    }
}
//4.求长度
int DoubleNode::getsize()
{
    Node *temp = new Node;
    temp = head;
    int length=0;
    if(temp==nullptr||temp->next==nullptr)
    {
        return length;
    }
    while(temp->next!=nullptr&&temp->next!=tail)
    {
        length++;
        temp = temp->next;
    }
    return length;

}
//5.判断是否为空
bool DoubleNode::isempty()
{

    if(head == nullptr||head->next==nullptr)
    {
        return true;
    }
    else
    {
        return false;
    }
}
//6.建表
void DoubleNode::create(int len)
{
    if(len<=0)
    {
        cout<<"argu is illegal!"<<endl;
        return;
    }
    head = new Node;
    head->next = head->last = nullptr;//初始化
    tail = head;//空链表头尾指针指向一个位置
    for(int i=0;i<len;i++)
    {
        Node *pnew = new Node; //创建一个新的节点
        cout<<"enter num"<<i+1<<" value"<<endl;
        cin>>pnew->data; // 赋值
        pnew->next = nullptr;
        /*
         * 借用尾节点的地址，因为新节点在尾节点的位置
         * 所以last指针指向尾节点的位置
         * 这样也不需要用temp指针去管理头结点的位置了
         */
        pnew->last = tail;
        tail->next = pnew; //为了让节点往后移动

        tail = pnew;//tail就是每次循环的上一个新节点，每次让它变成新节点

    }
    Node *temp =new Node;
    temp->next =nullptr;
    temp->last = tail;
    tail = temp;
}
//7.前驱遍历
void DoubleNode::showhead()
{
    Node * temp = head->next;
    if(temp==nullptr)
    {
        cout<<"this list is empty"<<endl;
        return;

    }
    //如果next指针指向尾节点，说明到最后了
    while(temp!=nullptr&&temp!=tail)
    {
        cout<<temp->data<<endl;
        temp=temp->next;


    }
}
//8.后驱遍历
void DoubleNode::showtail()
{
    Node * temp = tail;
    if(temp==nullptr)
    {
        cout<<"this list is empty"<<endl;
        return;
    }
    while(temp->last!=nullptr&&temp->last != head)
    {

        temp=temp->last;
        cout<<temp->data<<endl;


    }
}
//9.查找
int DoubleNode::get(int index)
{
    int length = this->getsize();
    if(length == 0)
    {
        cout<<"this is an empty list"<<endl;
        return 0;
    }
    if(index>length||index<=0)
    {
        cout<<"illegal index value!"<<endl;
        return 0;
    }
    if(index<=length/2)//前一半
    {
        Node * temp = head;
        for(int i=0;i<index;i++)
        {
            temp = temp->next;

        }
        cout<<"search at head"<<endl;
        return temp->data;
    }
    else//后一半
    {
        Node * temp =tail;
        for(int i=0;i<length-index+1;i++)
        {
            temp = temp->last;
        }
        cout<<"search at tail"<<endl;
        return temp->data;
    }

}
//10.在特定位置插入
oid DoubleNode::insert(int index,int data)
{
    int length=getsize();
    if(index<=0||index>length)
    {
        cout<<"index error"<<endl;
        return;
    }
    Node *p = new Node;//插入节点
    p->data=data;  //赋值
    if(index<=length/2)
    {
        Node *temp = head;
        for(int i=0;i<index;i++)
        {
            temp = temp->next;
        }

        p->last = temp; //
        p->next = temp->next;
        temp->next->last = p;
        temp->last->next = p;
        temp->next = p;

    }
    else
    {
        Node *temp = tail;
        for(int i=0;i<length-index+1;i++)
        {
            temp = temp->last;
        }

        p->last = temp->last;
        temp->last->next = p;

        temp->last = p;
        p->next = temp;
    }

}
//11.头插法
void DoubleNode::insert_first(int data)
{
    Node *p = new Node;
    p->data=data;
    if(getsize()==0)
    {
        cout<<"an empty list"<<endl;
        head = new Node;
        head->last = nullptr;
        head->next = p;  //head链接p
        p->last = head;
        tail = new Node;
        p->next = tail;
        tail->last = p;
        tail->next = nullptr;
    }
    else
    {
        p->next = head->next;
        head->next->last = p;

        p->last = head;
        head->next = p;


    }
}
//12.尾插法
void DoubleNode::insert_append(int data)
{
    Node *p =new Node;
    p->data=data;
    if(getsize()==0)
    {
        cout<<"an empty list"<<endl;
        head = new Node;
        head->last = nullptr;
        head->next = p;  //head链接p
        p->last = head;
        tail = new Node;
        p->next = tail;
        tail->last = p;
        tail->next = nullptr;
    }
    else
    {
        tail->last->next=p;
        p->last = tail->last;
        tail->last = p;
        p->next = tail;
    }
}
//13.删除指定元素
void DoubleNode::del(int index)
{
    int length = getsize();
    if(length==0)
    {
        cout<<"list is empty"<<endl;
        return;
    }
    else if(index<=length/2)
    {
        Node *p = head;
        for(int i=0;i<index;i++)
        {
            p = p->next;
        }
        p->last->next = p->next;
        p->next->last = p->last;
        delete p;

    }
    else if(index>length/2)
    {
        Node *p =tail;
        for(int i=0;i<length-index+1;i++)
        {
            p=p->last;
        }
        p->last->next = p->next;
        p->next->last = p->last;
    }
}
//14.头删法
void DoubleNode::delete_first()
{
    int length = getsize();
    if(length==0)
    {
        cout<<"list is empty"<<endl;
        return;
    }
    Node * temp =head->next;
    head->next->next->last = head;  //跳过一个节点，也就是下下个节点的last是head；
    head->next = head->next->next;  //头结点的next指向后两个节点
    delete temp;
    temp = nullptr;
}
//15.尾删法
void DoubleNode::delete_end()
{
    int length = getsize();
    if(length==0)
    {
        cout<<"list is empty"<<endl;
        return;
    }
    Node *temp = tail->last;

    tail->last->last->next = tail;
    tail->last = tail->last->last;
    delete temp;

}
~~~









## ·栈类模板：

·栈实现计算器：

![image-20230201072407188](D:\typora笔记\图片\image-20230201072407188.png)	

### ·代码实现：

·栈类模板：









## ·队列模板：

### ·代码实现：







## ·直接插入排序：

![image-20230201073311642](D:\typora笔记\图片\image-20230201073311642.png)	

### ·代码实现：









## ·选择排序：

![image-20230201073408419](D:\typora笔记\图片\image-20230201073408419.png)	

### ·代码实现：









## ·交换排序：

### ·冒泡排序：

![image-20230201073515443](D:\typora笔记\图片\image-20230201073515443.png)	

![image-20230201073550485](D:\typora笔记\图片\image-20230201073550485.png)	





## ·顺序查找：

### ·代码实现：





## ·所有查找算法，java实现过的；









## 19.泛型程序设计，标准模板库：

![image-20230201073951768](D:\typora笔记\图片\image-20230201073951768.png)	

**·泛型程序设计，stl库都有专门的学习书本或参考手册可以看；**



### ·标准库概念：

![image-20230201074615845](D:\typora笔记\图片\image-20230201074615845.png)	

### ·模型：

![image-20230201074711746](D:\typora笔记\图片\image-20230201074711746.png)	

**·例如插入排序模板，就不是什么数组都可以直接用于排序，该数组的元素必须可以比较大小（sortable）；**



### ·STL库：

![image-20230201074856729](D:\typora笔记\图片\image-20230201074856729.png)	

#### ·迭代器：

![image-20230201075014781](D:\typora笔记\图片\image-20230201075014781.png)	

·迭代器作为桥梁；不管容器是什么类型的数据结构（队列，数组等），都必须有一个迭代器对象，用于遍历整个容器的元素；

·将可迭代的容器交给通用算法模板处理；



#### ·常用容器：

![image-20230201075345090](D:\typora笔记\图片\image-20230201075345090.png)	

#### ·迭代器：

![image-20230207011545711](D:\typora笔记\图片\image-20230207011545711.png)	

#### ·函数对象，算法：

![image-20230207012005107](D:\typora笔记\图片\image-20230207012005107.png)![image-20230207012025029](D:\typora笔记\图片\image-20230207012025029.png)		



#### ·算法举例：

![image-20230207011816104](D:\typora笔记\图片\image-20230207011816104.png)	

·这里就将函数作为一个对象传入；



#### ·代码示例：

·这个算法用于处理一个容器中所有元素的相反数；

![image-20230207012407924](D:\typora笔记\图片\image-20230207012407924.png)	





### ·输入流，输出流对象：

![image-20230207013011184](D:\typora笔记\图片\image-20230207013011184.png)	

#### ·代码示例：

![image-20230207013731393](D:\typora笔记\图片\image-20230207013731393.png)	

### ·迭代器的区别：

#### ·区间：

![image-20230207013832510](D:\typora笔记\图片\image-20230207013832510.png)	

·下标从0开始，而不是从1开始的原因：（不包含p2的原因）：





#### ·代码示例：

![image-20230207014112700](D:\typora笔记\图片\image-20230207014112700.png)	

·随机访问迭代器：数组一类的就是随机访问迭代器；输入流必须一个一个往下读，不是随机访问迭代器；

·copy可以将前两个迭代器参数所代表的区间，copy到result输出迭代器中；

·![image-20230207014537145](D:\typora笔记\图片\image-20230207014537145.png)	

### ·迭代器辅助函数：

![image-20230207014636726](D:\typora笔记\图片\image-20230207014636726.png)	

### ·容器的基本功能和分类：

![image-20230207014800358](D:\typora笔记\图片\image-20230207014800358.png)	

·多重集合：即数据可以重复；

#### ·分类：

![image-20230207015059607](D:\typora笔记\图片\image-20230207015059607.png)	

![image-20230207015141408](D:\typora笔记\图片\image-20230207015141408.png)	

#### ·通用功能：

![image-20230207015226415](D:\typora笔记\图片\image-20230207015226415.png)	

#### ·逆迭代器：

![image-20230207015316606](D:\typora笔记\图片\image-20230207015316606.png)	





### ·顺序容器：

![image-20230207015434081](D:\typora笔记\图片\image-20230207015434081.png)	

#### ·构造函数：

![image-20230207015538078](D:\typora笔记\图片\image-20230207015538078.png)	

#### ·赋值函数：

![image-20230207015645615](D:\typora笔记\图片\image-20230207015645615.png)	

#### ·插入函数：

![image-20230207015956008](D:\typora笔记\图片\image-20230207015956008.png)	

![image-20230207020007045](D:\typora笔记\图片\image-20230207020007045.png)



#### ·代码示例：

![image-20230207020110407](D:\typora笔记\图片\image-20230207020110407.png)	

![image-20230207020316690](D:\typora笔记\图片\image-20230207020316690.png)	

·交换元素：

![image-20230207020502856](D:\typora笔记\图片\image-20230207020502856.png)	

·earse将取出的元素删除，再插入到原本的位置的下一个索引；

·再用assign将L的区间元素赋值给s；



#### ·顺序容器特性：

![image-20230207020835169](D:\typora笔记\图片\image-20230207020835169.png)

##### 双端队列：

![image-20230207020858437](D:\typora笔记\图片\image-20230207020858437.png)	



##### ·代码示例：

![image-20230207021010533](D:\typora笔记\图片\image-20230207021010533.png)	 

#### ·列表：

![image-20230207023102296](D:\typora笔记\图片\image-20230207023102296.png)	

·代码示例：

![image-20230207023231352](D:\typora笔记\图片\image-20230207023231352.png)	

#### ·单向链表：

![image-20230207023409993](D:\typora笔记\图片\image-20230207023409993.png)	

#### ·数组：

![image-20230207023422150](D:\typora笔记\图片\image-20230207023422150.png)	

#### ·小结：![image-20230207023456120](D:\typora笔记\图片\image-20230207023456120.png)	



#### ·顺序容器的插入迭代器：

![image-20230207023538246](D:\typora笔记\图片\image-20230207023538246.png)	

#### ·数据结构：

![image-20230207023615746](D:\typora笔记\图片\image-20230207023615746.png)	

#### ·栈，队列模板：

![image-20230207023635791](D:\typora笔记\图片\image-20230207023635791.png)	

##### ·共同操作：

![image-20230207023736744](D:\typora笔记\图片\image-20230207023736744.png)	

##### ·不同操作：

![image-20230207023753862](D:\typora笔记\图片\image-20230207023753862.png)	

##### ·代码示例：

![image-20230207023823023](D:\typora笔记\图片\image-20230207023823023.png)	

#### ·优先级队列：

![image-20230207023929838](D:\typora笔记\图片\image-20230207023929838.png)	





## 20.流对象和文件操作：

### ·常用流：

![image-20230209005552330](D:\typora笔记\图片\image-20230209005552330.png)	

### ·输出流（最重要的三个）：

![image-20230209005652817](D:\typora笔记\图片\image-20230209005652817.png)	

### ·构建输出流对象：

![image-20230209005806328](D:\typora笔记\图片\image-20230209005806328.png)·binary二进制文件，out文本文件；	

### ·文件输出流成员函数三种类型：

![image-20230209010059151](D:\typora笔记\图片\image-20230209010059151.png)	

![image-20230209010210126](D:\typora笔记\图片\image-20230209010210126.png)	



### ·向文本文件输出：

·系统定义好的输出流对象：

![image-20230209010602592](D:\typora笔记\图片\image-20230209010602592.png)	

·操作文件需要的输出流对象：

![image-20230209010643419](D:\typora笔记\图片\image-20230209010643419.png)	

### ·级联输出：（控制宽度）

![image-20230209010747840](D:\typora笔记\图片\image-20230209010747840.png)·setw允许插入在插入操作符后面，控制后一个输出项的宽度；

### ·ofstream：

![image-20230209010853460](D:\typora笔记\图片\image-20230209010853460.png)	

​	

### ·设置对齐方式：

![image-20230209010957174](D:\typora笔记\图片\image-20230209010957174.png)·setiosflags（xxxx)	，此操作符允许使用很多参数，并且只需要设置一次，就一直生效；

### ·setiosflags

![image-20230209011130616](D:\typora笔记\图片\image-20230209011130616.png)

![image-20230209011323236](D:\typora笔记\图片\image-20230209011323236.png)	

### ·输出控制精度：

![image-20230209011402112](D:\typora笔记\图片\image-20230209011402112.png)·未设置fixed，默认精度6位（即长度六位数)，设置了则表示小数的位数；

![image-20230209011630856](D:\typora笔记\图片\image-20230209011630856.png)·这里设置了有效数字一位，系统默认使用了科学计数法；	

### ·指定fixed：

·指定scientfic就和上面一样；

·设置一次即可，之后的都会生效；

![image-20230209011804918](D:\typora笔记\图片\image-20230209011804918.png)		



### ·二进制文件输出：

![image-20230209012118325](D:\typora笔记\图片\image-20230209012118325.png)	

·![image-20230209012353652](D:\typora笔记\图片\image-20230209012353652.png)	

### ·向字符串输出：

![image-20230209012533242](D:\typora笔记\图片\image-20230209012533242.png)	

![image-20230209012805729](D:\typora笔记\图片\image-20230209012805729.png)·要使用该输出流，数据类型必须支持 【插入符】；





### 

### 

### ·输入流：

![image-20230209013005840](D:\typora笔记\图片\image-20230209013005840.png)	

·![image-20230209013037414](D:\typora笔记\图片\image-20230209013037414.png)	

### ·提取运算符：

![image-20230209013114848](D:\typora笔记\图片\image-20230209013114848.png)	

![image-20230209013602317](D:\typora笔记\图片\image-20230209013602317.png)	

### ·程序示例：

![image-20230209013741707](D:\typora笔记\图片\image-20230209013741707.png)	

·cout.put（）：

~~~c++
#include <iostream>
#include <string>
using namespace std;

int main(){
    string str = "ten.gnehcnaib.c//:ptth";
    for (int i = str.length() - 1; i >= 0; i--) {
        cout.put(str[i]);  //从最后一个字符开始输出
    }
    cout.put('\n');

    return 0;
}
~~~

【实例1】输出单个字符 a。

cout.put('a');

调用该方法的结果是在屏幕上显示一个字符 a。

【实例2】put() 函数的参数可以是字符或字符的 ASCII 代码（也可以是一个整型表达式）。

cout.put(65 + 32);
cout.put(97);

上面两行代码都输出字符 a，因为 97 是字符 a 的 ASCII 代码。

【实例3】可以在一个语句中连续调用 put() 函数，例如：

cout.put(71).put(79).put(79). put(68).put('\n');	



·程序示例：

![image-20230209014133473](D:\typora笔记\图片\image-20230209014133473.png)



### ·读取二进制数据：

![image-20230209014242995](D:\typora笔记\图片\image-20230209014242995.png)	

![image-20230209014356411](D:\typora笔记\图片\image-20230209014356411.png)·这里读取的字节数为employee2数据类型所占用的内存量；将数据读取到  employee2这个指针表示的内存地址；



### ·seekg设置位置指针：		

![image-20230209014721852](D:\typora笔记\图片\image-20230209014721852.png)

### ·tellg：获取当前指针位置：

![image-20230209014916810](D:\typora笔记\图片\image-20230209014916810.png)	

### ·从字符串输入：

![image-20230209014957606](D:\typora笔记\图片\image-20230209014957606.png)	

·![image-20230209015009469](D:\typora笔记\图片\image-20230209015009469.png)	

![image-20230209015208368](D:\typora笔记\图片\image-20230209015208368.png)	



### ·两个重要的输入/输出流：

![image-20230209015237835](D:\typora笔记\图片\image-20230209015237835.png)	

### ·fstream：

![image-20230209015327593](D:\typora笔记\图片\image-20230209015327593.png)	

### ·stringstream：

![image-20230209015407580](D:\typora笔记\图片\image-20230209015407580.png)	







## 21.异常处理：

![image-20230214011714881](D:\typora笔记\图片\image-20230214011714881.png)	

### ·异常传播思想：

![image-20230214011927740](D:\typora笔记\图片\image-20230214011927740.png)	

### ·异常处理语法：

![image-20230214012032101](D:\typora笔记\图片\image-20230214012032101.png)	

![image-20230214012059731](D:\typora笔记\图片\image-20230214012059731.png)	

### ·异常声明：

![image-20230214012418719](D:\typora笔记\图片\image-20230214012418719.png)	

### ·noexpect：

![image-20230214012500116](D:\typora笔记\图片\image-20230214012500116.png)	

![image-20230214012529601](D:\typora笔记\图片\image-20230214012529601.png)	

### ·析构函数异常：

![image-20230214012719572](D:\typora笔记\图片\image-20230214012719572.png)	

![image-20230214012741922](D:\typora笔记\图片\image-20230214012741922.png)		

![image-20230214012800345](D:\typora笔记\图片\image-20230214012800345.png)	



### ·标准异常类的继承关系：

![image-20230214012835621](D:\typora笔记\图片\image-20230214012835621.png)	

![image-20230214012851470](D:\typora笔记\图片\image-20230214012851470.png)	

#### ·异常基础：

![image-20230214012930440](D:\typora笔记\图片\image-20230214012930440.png)	

~~~c++
try{
    // 可能抛出异常的语句
}catch(exceptionType variable){
    // 处理异常的语句
}
try和catch都是 C++ 中的关键字，后跟语句块，不能省略{ }。try 中包含可能会抛出异常的语句，一旦有异常抛出就会被后面的 catch 捕获。从 try 的意思可以看出，它只是“检测”语句块有没有异常，如果没有发生异常，它就“检测”不到。catch 是“抓住”的意思，用来捕获并处理 try 检测到的异常；如果 try 语句块没有检测到异常（没有异常抛出），那么就不会执行 catch 中的语句。
    
#include <iostream>
#include <string>
#include <exception> //异常需要包含的请求头
using namespace std;

int main(){
    string str = "http://c.biancheng.net";
  
    try{
        char ch1 = str[100];
        cout<<ch1<<endl;
    }catch(exception e){
        cout<<"[1]out of bound!"<<endl;
    }

    try{
        char ch2 = str.at(100);
        cout<<ch2<<endl;
    }catch(exception &e){  //exception类位于<exception>头文件中
        cout<<"[2]out of bound!"<<endl;
    }

    return 0;
}
~~~

### ·Catch中的异常变量是什么：

~~~c++
`exceptionType`是异常类型，它指明了当前的 catch 可以处理什么类型的异常；`variable`是一个变量，用来接收异常信息。当程序抛出异常时，会创建一份数据，这份数据包含了错误信息，程序员可以根据这些信息来判断到底出了什么问题，接下来怎么处理。

异常既然是一份数据，那么就应该有数据类型。[C++] 规定，异常类型可以是 int、char、float、bool 等基本类型，也可以是[指针]、数组、字符串、结构体、类等聚合类型。C++ 语言本身以及标准库中的函数抛出的异常，都是 exception 类或其子类的异常。也就是说，抛出异常时，会创建一个 exception 类或其子类的对象。

`exceptionType variable`和函数的形参非常类似，当异常发生后，会将异常数据传递给 variable 这个变量，这和函数传参的过程类似。当然，只有跟 exceptionType 类型匹配的异常数据才会被传递给 variable，否则 catch 不会接收这份异常数据，也不会执行 catch 块中的语句。换句话说，catch 不会处理当前的异常。


但是 catch 和真正的函数调用又有区别：
真正的函数调用，形参和实参的类型必须要匹配，或者可以自动转换，否则在编译阶段就报错了。
而对于 catch，异常是在运行阶段产生的，它可以是任何类型，没法提前预测，所以不能在编译阶段判断类型是否正确，只能等到程序运行后，真的抛出异常了，再将异常类型和 catch 能处理的类型进行匹配，匹配成功的话就“调用”当前的 catch，否则就忽略当前的 catch。
~~~

~~~c++
另外需要注意的是，如果不希望 catch 处理异常数据，也可以将 variable 省略掉，也即写作：
try{
    // 可能抛出异常的语句
}catch(exceptionType){
    // 处理异常的语句
}

这样只会将异常类型和 catch 所能处理的类型进行匹配，不会传递异常数据了。
~~~

#### ·数据类型转换：

~~~c
算数转换：例如 int 转换为 float，char 转换为 int，double 转换为 int 等。
向上转型：也就是派生类向基类的转换，请猛击《C++向上转型（将派生类赋值给基类）》了解详情。
const 转换：也即将非 const 类型转换为 const 类型，例如将 char * 转换为 const char *。
数组或函数指针转换：如果函数形参不是引用类型，那么数组名会转换为数组指针，函数名也会转换为函数指针。
用户自定的类型转换。

catch 在匹配异常类型的过程中，也会进行类型转换，但是这种转换受到了更多的限制，仅能进行「向上转型」、「const 转换」和「数组或函数指针转换」，其他的都不能应用于 catch。

~~~

~~~c++
#include <iostream>
using namespace std;
int main(){
    int nums[] = {1, 2, 3};
    try{
        throw nums;
        cout<<"This statement will not be executed."<<endl;
    }catch(const int *){  //nums 本来的类型是int [3]，但是 catch 中没有严格匹配的类型，所以先转换为int *，再转换为const int *。
        cout<<"Exception type: const int *"<<endl;
    }
    return 0;
}

//数组也是一种类型，数组并不等价于指针，这点已在《数组和指针绝不等价，数组是另外一种类型》和《数组到底在什么时候会转换为指针》中进行了详细讲解。
~~~







### ·代码示例：

![image-20230214012949707](D:\typora笔记\图片\image-20230214012949707.png)	

![image-20230214013014428](D:\typora笔记\图片\image-20230214013014428.png)	

![image-20230214013050130](D:\typora笔记\图片\image-20230214013050130.png)	

------



# 22.STL知识

## stl基础知识：

![image-20230730213454543](D:\typora笔记\c++_stl\image-20230730213454543.png)	

![image-20230730213557205](D:\typora笔记\c++_stl\image-20230730213557205.png)	

### 容器，算法，迭代器概念：

![image-20230730213831970](D:\typora笔记\c++_stl\image-20230730213831970.png)	

![image-20230730213931060](D:\typora笔记\c++_stl\image-20230730213931060.png)	

### 迭代器种类（了解）

![image-20230730214029004](D:\typora笔记\c++_stl\image-20230730214029004.png)	

------



## 容器Vector：

![image-20230730214121916](D:\typora笔记\c++_stl\image-20230730214121916.png)	

~~~c
arr.begin() 初始迭代器，指向容器第一个元素

arr.end() 结束迭代器，指向容器最后一个元素；
    
for_each(arr.begin(), arr.end(), soutArr); //算法，传入初始指针，结束指针，以及要执行的函数逻辑。内部源码就是第一种方式的for循环
~~~

~~~c++
#include <iostream>

#include <vector>//数组容器

#include <algorithm> //标准算法头文件
using namespace std;

vector<int> getVector() {
    vector<int> arr;
    arr.push_back(10);
    arr.push_back(20);
    arr.push_back(30);
    arr.push_back(40);

    return arr;
}

void soutArr(int val) {
    cout << val << endl;
}

int main()
{
    vector<int> arr=getVector();
    for_each(arr.begin(), arr.end(), soutArr);
}
~~~

![image-20230730215559463](D:\typora笔记\c++_stl\image-20230730215559463.png)	

![image-20230730215605650](D:\typora笔记\c++_stl\image-20230730215605650.png)	

~~~
foreach源码：右键点击算法，找到 【转到定义】
~~~

![image-20230730215646073](D:\typora笔记\c++_stl\image-20230730215646073.png)	

### 存放自定义类型数据：

~~~c++
class Person {
public:
    string name;
    int age;
    Person(string name, int age) {
        this->name = name;
        this->age = age;
    }
};

void getVector() {
    vector<Person> arr;
    Person p1("tgg",23);
    Person p2("rr", 23);
    Person p3("yy", 23);
    Person p4("tttgg", 23);

    arr.push_back(p1);
    arr.push_back(p2);
    arr.push_back(p3);
    arr.push_back(p4);
    for (vector<Person>::iterator it = arr.begin(); it != arr.end(); it++) {
        cout << "name:" << (*it).name << "--age:" << ((*it).age) << endl;
    }
}

int main()
{
   getVector();
}
~~~

~~~c++
#include <iostream>

#include <vector>//数组容器

#include <algorithm> //标准算法头文件
using namespace std;

class Person {
public:
    string name;
    int age;
    Person(string name, int age) {
        this->name = name;
        this->age = age;
    }
};
vector<Person> getVector() {
    vector<Person> arr;
    Person p1("tgg", 23);
    Person p2("rr", 23);
    Person p3("yy", 23);
    Person p4("tttgg", 23);

    arr.push_back(p1);
    arr.push_back(p2);
    arr.push_back(p3);
    arr.push_back(p4);

    //for (vector<Person>::iterator it = arr.begin(); it != arr.end(); it++) {
    //    cout << "name:" << (*it).name << "--age:" << ((*it).age) << endl;
    //}
    return arr;

}

void soutPerson(Person p) {
    cout << "name:" << p.name << "--age:" << (p.age) << endl;
}

int main()
{
    vector<Person> arr=getVector();

    for_each(arr.begin(), arr.end(), soutPerson);
}
~~~

### vector嵌套容器：（二维数组）

~~~
重点就是容器里面存放的还是容器
~~~

![image-20230730222322474](D:\typora笔记\c++_stl\image-20230730222322474.png)	

### 构造函数：

~~~
vector的迭代器支持随机访问；
~~~

![image-20230730230028281](D:\typora笔记\c++_stl\image-20230730230028281.png)	

![image-20230730230114844](D:\typora笔记\c++_stl\image-20230730230114844.png)	

在 C++ 中，`std::vector` 是一个动态数组容器，它提供了多种构造函数来创建和初始化向量。下面详细说明并举例这些构造函数，并提醒一些在实战中需要注意的点：

1. 默认构造函数：
   - 创建一个空的向量，大小为 0。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec; // 默认构造函数创建一个空的向量
    std::cout << "Vector size: " << vec.size() << std::endl; // Output: 0

    return 0;
}
```

2. 构造函数初始化列表：
   - 使用初始化列表来初始化向量。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5}; // 使用初始化列表来初始化向量
    std::cout << "Vector size: " << vec.size() << std::endl; // Output: 5

    return 0;
}
```

3. 构造函数指定大小和初始值：
   - 创建指定大小的向量，并使用给定的初始值初始化所有元素。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec(5, 10); // 创建大小为 5 的向量，并使用 10 初始化所有元素
    std::cout << "Vector size: " << vec.size() << std::endl; // Output: 5

    return 0;
}
```

4. 构造函数指定大小：
   - 创建指定大小的向量，但不进行初始化。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec(3); // 创建大小为 3 的向量，不进行初始化
    std::cout << "Vector size: " << vec.size() << std::endl; // Output: 3

    return 0;
}
```

5. 复制构造函数：
   - 使用一个已存在的向量来创建新的向量。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> originalVec = {1, 2, 3};
    std::vector<int> newVec(originalVec); // 使用已存在的向量来创建新的向量

    std::cout << "New vector size: " << newVec.size() << std::endl; // Output: 3

    return 0;
}
```

6. 移动构造函数：
   - 使用一个右值（例如临时对象或使用 `std::move` 转移的对象）来创建新的向量。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> originalVec = {1, 2, 3};
    std::vector<int> newVec(std::move(originalVec)); // 使用右值来创建新的向量

    std::cout << "New vector size: " << newVec.size() << std::endl; // Output: 3
    // 注意：originalVec 现在为空向量，原来的元素被移动到了 newVec 中

    return 0;
}
```

在实战中需要注意以下几点：

- 如果使用动态内存分配（例如在堆上分配）来创建一个向量，请确保在不再使用向量时释放内存，避免内存泄漏。

- 当使用复制构造函数和移动构造函数时，注意源向量的状态，特别是在使用移动语义时，源向量的内容可能会被移动到新向量中，源向量变为空向量。

- 当使用指定大小和初始值的构造函数时，确保提供的初始值类型与向量的数据类型匹配，避免出现意外的类型转换。

- 在实际使用过程中，根据需求选择适合的构造函数是非常重要的。在向量容器的构造时，合理使用构造函数可以提高程序的效率和代码的可读性。



### 赋值操作：

![image-20230730231329190](D:\typora笔记\c++_stl\image-20230730231329190.png)	

在 C++ 中，给 `std::vector` 赋值有多种方式，可以通过使用等号赋值运算符、拷贝构造函数、移动赋值运算符以及使用范围内的迭代器进行赋值。下面详细说明并举例这些方式，并提醒一些在实战中需要注意的点：

1. 等号赋值运算符：
   - 使用一个向量来替换另一个向量的内容。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec1 = {1, 2, 3};
    std::vector<int> vec2 = {4, 5, 6};

    vec1 = vec2; // 使用等号赋值运算符进行赋值，vec1 现在包含 {4, 5, 6}

    return 0;
}
```

2. 拷贝构造函数：
   - 使用一个向量创建一个新的向量。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec1 = {1, 2, 3};
    std::vector<int> vec2(vec1); // 使用拷贝构造函数进行赋值，vec2 现在包含 {1, 2, 3}

    return 0;
}
```

3. 移动赋值运算符：
   - 使用一个右值向量来替换另一个向量的内容，从而实现资源的转移。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec1 = {1, 2, 3};
    std::vector<int> vec2 = {4, 5, 6};

    vec1 = std::move(vec2); // 使用移动赋值运算符进行赋值，vec1 现在包含 {4, 5, 6}，而 vec2 成为空向量

    return 0;
}
```

4. 使用范围内的迭代器进行赋值：
   - 使用范围内的迭代器来替换向量的内容。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec1 = {1, 2, 3};
    std::vector<int> vec2 = {4, 5, 6, 7, 8};

    vec1.assign(vec2.begin(), vec2.end()); // 使用迭代器进行赋值，vec1 现在包含 {4, 5, 6, 7, 8}

    return 0;
}
```

在实战中需要注意以下几点：

- 当使用等号赋值运算符和拷贝构造函数时，将复制源向量的内容到目标向量中。这可能涉及到对元素的深度复制（例如复制动态分配的内存）。

- 当使用移动赋值运算符时，将转移源向量的资源到目标向量中，避免了资源的深度复制。这在需要大量数据拷贝时，特别有用，可以显著提高性能。

- 在使用范围内的迭代器进行赋值时，要确保迭代器范围有效，避免迭代器越界或无效的访问。

- 在使用等号赋值运算符、拷贝构造函数和移动赋值运算符时，要注意源向量和目标向量的类型必须匹配，否则会导致编译错误。

- 在使用移动赋值运算符时，源向量的状态会被转移，因此源向量在赋值后会变为空向量，应谨慎使用原向量。

根据实际的需求，选择适当的赋值方式可以提高程序的性能和代码的可读性。在对向量进行赋值操作时，考虑向量的大小、资源的转移和复制操作等因素，以确保程序的效率和正确性。



### 容器的大小和容量：

![image-20230730231729884](D:\typora笔记\c++_stl\image-20230730231729884.png)	

在 C++ 中，`std::vector` 提供了容量和大小的相关操作。容量是指向量在内存中可以容纳的元素数量，而大小是指向量当前包含的元素数量。`std::vector` 提供了以下几个函数来获取和调整容量和大小：

1. `size()` 函数：获取向量的大小，即当前包含的元素数量。
2. `max_size()` 函数：获取向量可能包含的最大元素数量，这是由系统和硬件的限制决定的。
3. `capacity()` 函数：获取向量在重新分配内存之前可以容纳的元素数量。
4. `resize(size_type n)` 函数：调整向量的大小，将向量的大小调整为 n。如果 n 小于当前大小，则删除多余的元素；如果 n 大于当前大小，则添加默认构造的元素。
5. `reserve(size_type n)` 函数：增加向量的容量，确保向量可以容纳至少 n 个元素，避免多次重新分配内存。

下面是一个示例，演示了这些操作的使用：

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 获取向量的大小和容量
    std::cout << "Size: " << vec.size() << std::endl;         // Output: Size: 5
    std::cout << "Max Size: " << vec.max_size() << std::endl; // Output: Max Size: 4611686018427387903
    std::cout << "Capacity: " << vec.capacity() << std::endl; // Output: Capacity: 5

    // 调整向量的大小
    vec.resize(3); // 向量现在包含 {1, 2, 3}
    std::cout << "Size after resizing: " << vec.size() << std::endl; // Output: Size after resizing: 3

    // 增加向量的容量
    vec.reserve(10); // 现在向量的容量至少为 10

    return 0;
}
```

在实战中需要注意以下几点：

- 使用 `size()` 函数可以获取向量的大小，即当前包含的元素数量。`size()` 返回的是 `size_type` 类型，这是一个无符号整数类型，应该避免与有符号整数混用，以防止类型不匹配的问题。

- 使用 `capacity()` 函数可以获取向量的容量，即向量在重新分配内存之前可以容纳的元素数量。容量是指向量的实际内存大小，而大小是指向量当前包含的元素数量。

- 使用 `resize()` 函数可以调整向量的大小，它会增加或减少向量的元素数量。在减少向量的大小时，超出部分的元素会被删除；在增加向量的大小时，会添加默认构造的元素。

- 使用 `reserve()` 函数可以增加向量的容量，确保向量可以容纳至少指定数量的元素。这有助于避免在添加元素时频繁地重新分配内存，提高了性能。

- 调整容量和大小时，要谨慎考虑内存的使用和性能，避免不必要的内存分配和复制操作。在大规模数据处理时，选择适当的容量和大小操作可以提高程序的效率。

- 当向量的容量超过当前包含的元素数量时，不会释放多余的内存。可以使用 `shrink_to_fit()` 函数来要求向量释放多余的内存，但这并不保证一定会成功。

- 在多线程环境中，修改向量的大小和容量时需要注意线程安全性，可以使用互斥锁等机制来保护共享资源。



### 插入，删除操作：

![image-20230730232020119](D:\typora笔记\c++_stl\image-20230730232020119.png)	

`std::vector` 提供了多种插入和删除元素的操作，让我们详细说明并举例：

1. 插入操作：

   - `push_back()`：在向量的末尾插入一个元素。

   ```cpp
   #include <iostream>
   #include <vector>

   int main() {
       std::vector<int> vec = {1, 2, 3};

       vec.push_back(4); // 向向量的末尾插入元素 4

       return 0;
   }
   ```

   - `insert()`：在指定位置插入一个或多个元素。

   ```cpp
   #include <iostream>
   #include <vector>

   int main() {
       std::vector<int> vec = {1, 2, 3};

       // 在位置 1 处插入元素 4
       vec.insert(vec.begin() + 1, 4); // 现在 vec 包含 {1, 4, 2, 3}

       // 在位置 2 处插入元素 5 和 6
       vec.insert(vec.begin() + 2, {5, 6}); // 现在 vec 包含 {1, 4, 5, 6, 2, 3}

       return 0;
   }
   ```

2. 删除操作：

   - `pop_back()`：删除向量的最后一个元素。

   ```cpp
   #include <iostream>
   #include <vector>
   
   int main() {
       std::vector<int> vec = {1, 2, 3, 4};
   
       vec.pop_back(); // 删除向量的最后一个元素，现在 vec 包含 {1, 2, 3}
   
       return 0;
   }
   ```

   - `erase()`：删除指定位置的一个或多个元素。

   ```cpp
   #include <iostream>
   #include <vector>
   
   int main() {
       std::vector<int> vec = {1, 2, 3, 4, 5, 6};
   
       // 删除位置 1 处的元素
       vec.erase(vec.begin() + 1); // 现在 vec 包含 {1, 3, 4, 5, 6}
   
       // 删除位置 2 到 4（不包含）之间的元素
       vec.erase(vec.begin() + 2, vec.begin() + 4); // 现在 vec 包含 {1, 3, 6}
   
       return 0;
   }
   ```

在实战中需要注意以下几点：

- 在插入和删除元素时，要确保操作的位置在向量的有效范围内，避免出现越界访问的问题。
- 使用 `push_back()` 和 `pop_back()` 可以高效地在向量的末尾插入和删除元素，因为它们只涉及到向量的最后一个位置。
- 使用 `insert()` 和 `erase()` 可以在任意位置插入和删除元素，但在大规模数据处理时要注意性能，避免频繁地插入和删除导致内存的频繁分配和释放。
- 在使用 `insert()` 插入多个元素时，可以传递一个初始化列表来插入多个元素，这可以提高效率。
- 在使用 `erase()` 删除多个元素时，要注意删除的范围是左闭右开区间，即删除的范围不包含右边界。
- 当在循环中对向量进行插入或删除操作时，要特别注意迭代器的失效问题。插入或删除元素后，原先获取的迭代器可能已经失效，导致访问非法内存。可以使用返回的新迭代器或使用智能迭代器（例如 `std::list`）来避免这个问题。

~~~c
'clear不会释放向量所占用的内存
~~~

`std::vector` 还提供了 `clear()` 操作用于清空向量中的所有元素。这个操作会将向量的大小设置为0，**但不会释放向量所占用的内存**，因此向量的容量保持不变。

下面是 `clear()` 的示例：

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    vec.clear(); // 清空向量中的所有元素，现在 vec 为空向量

    return 0;
}
```

在实战中，`clear()` 操作可以用于释放向量中的所有元素，避免内存泄漏。但请注意，`clear()` 并不会减少向量的容量，如果需要释放多余的内存，可以使用 `shrink_to_fit()` 函数来实现。

当使用 `clear()` 操作时，要注意以下几点：

- `clear()` 操作会删除向量中的所有元素，如果向量中的元素是指针类型或者包含资源管理的对象，需要在删除元素之前先手动释放这些资源，避免内存泄漏。

- `clear()` 操作会将向量的大小设置为0，但不会释放向量所占用的内存。如果希望在清空向量后释放多余的内存，可以使用 `shrink_to_fit()` 函数。

- 在使用 `clear()` 操作后，原先获取的迭代器会失效，如果之后需要继续使用迭代器，需要重新获取。

- 在多线程环境中使用 `clear()` 操作时需要注意线程安全性，可以使用互斥锁等机制来保护共享资源。



### 数据存取：

~~~c
'和string操作是一样的
~~~

![image-20230730232406154](D:\typora笔记\c++_stl\image-20230730232406154.png)	



### 互换容器：

~~~c
进行容器互换时，要特别注意迭代器的失效问题。互换容器后，原先获取的迭代器可能已经失效，导致访问非法内存。可以使用返回的新迭代器或使用智能迭代器（例如 `std::list`）来避免这个问题。
    
互换进行的是指针交换，交换后内存地址会改变，导致互换前获取的迭代器无法使用，内存地址变化了；
~~~

在 C++ 中，可以使用 `std::swap` 函数来互换两个向量的内容，从而实现向量之间的容器互换。`std::swap` 函数位于 `<algorithm>` 头文件中。

下面是互换容器的示例：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3};
    std::vector<int> vec2 = {4, 5, 6};

    std::swap(vec1, vec2); // 互换两个向量的内容

    std::cout << "vec1: ";
    for (int num : vec1) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    std::cout << "vec2: ";
    for (int num : vec2) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

输出结果：
```
vec1: 4 5 6 
vec2: 1 2 3
```

在实战中需要注意以下几点：

- `std::swap` 函数是一个高效的算法，它只交换了两个向量的指针，而没有对向量的元素进行复制操作。因此，对于大规模的数据容器，使用 `std::swap` 可以在性能上得到提升。

- 在使用 `std::swap` 函数互换两个向量时，要确保两个向量的类型和元素类型相同，否则会导致编译错误。

- 在互换容器后，原先向量的内容会交换到新的向量中，原先向量将变为空向量。如果原先向量中有动态分配的内存或资源，应该在互换容器之前先处理好这些资源，以免出现资源泄漏。

- 使用 `std::swap` 函数进行容器互换时，要特别注意迭代器的失效问题。互换容器后，原先获取的迭代器可能已经失效，导致访问非法内存。可以使用返回的新迭代器或使用智能迭代器（例如 `std::list`）来避免这个问题。

- 在多线程环境中使用 `std::swap` 函数进行容器互换时需要注意线程安全性，可以使用互斥锁等机制来保护共享资源。



### 预留空间：

~~~c
这段代码用于统计，当前的容器扩展了多少次空间；

这里存10w个数据，如果原本的容器大小不足，就会申请新的容器，原来的容器就释放，复制原本的数据放到新容器中；

此时p指针就不指向首地址了（首地址变化了），因此变化的次数就是申请内存空间的次数；

预留只需要使用上面提到的'【reserve】'操作即可
~~~

![image-20230730233034988](D:\typora笔记\c++_stl\image-20230730233034988.png)	





### 遗忘知识点复习：

~~~
在C++中，using namespace std; 是一种简化的方式，用于在代码中使用C++标准库中的名称，而无需在每个名称前面加上std::前缀。

标准库（Standard Library）是C++提供的一组丰富的函数和类，包含了很多常用的功能，例如输入输出、容器、算法等。这些功能都被封装在一个名为std的命名空间中。
~~~



#### 复制构造函数：

~~~c
'这里的复制是深复制；
~~~

复制构造函数是一种特殊的构造函数，用于创建一个新对象并使用已有对象的值进行初始化。它的作用是在创建新对象时，使用一个同类型的现有对象来提供初始值，从而实现对象的复制。复制构造函数的语法如下：

```cpp
class MyClass {
public:
    // 复制构造函数
    MyClass(const MyClass& other) {
        // 在这里进行成员变量的复制操作
        // 通常是使用其他对象的值来初始化当前对象的成员变量
    }
};
```

复制构造函数的参数是一个常量引用，它接收一个同类型的对象作为参数，这个参数是要被复制的源对象。当调用复制构造函数时，会将源对象的值复制给新创建的对象。

下面是一个示例，演示了复制构造函数的使用：

```cpp
#include <iostream>

class MyClass {
public:
    // 构造函数
    MyClass(int value) : data(value) {}

    // 复制构造函数
    MyClass(const MyClass& other) : data(other.data) {
        std::cout << "Copy constructor called: " << other.data << std::endl;
    }

    int getData() const {
        return data;
    }

private:
    int data;
};

int main() {
    MyClass obj1(42); // 创建第一个对象
    MyClass obj2 = obj1; // 使用复制构造函数创建第二个对象

    std::cout << "obj1 data: " << obj1.getData() << std::endl; // Output: 42
    std::cout << "obj2 data: " << obj2.getData() << std::endl; // Output: 42

    return 0;
}
```

在底层，复制构造函数主要做了以下几个操作：

1. 接收一个源对象的引用作为参数，它使用 `const` 修饰，确保源对象在复制过程中不会被修改。

2. 创建一个新的对象，并将源对象的成员变量的值复制给新对象的对应成员变量。这通常是通过初始化列表或赋值操作来完成。

3. 返回一个新创建的对象，完成对象的复制。

需要注意的是，复制构造函数是在以下情况下被隐式调用的：

- 用一个对象去初始化另一个同类型的对象，例如 `MyClass obj2 = obj1;`。
- 将一个对象作为函数参数按值传递，或者从函数返回一个对象时。

复制构造函数在实际使用中很常见，特别是在涉及到对象的复制或传递时。了解复制构造函数的工作原理，可以更好地理解对象的复制过程，并确保在复制对象时，成员变量的值被正确复制。



#### 移动构造函数：

~~~c
'这种方式是浅复制；
~~~

移动构造函数是 C++11 引入的特性，它是一种特殊的构造函数，用于在创建新对象时，使用右值（例如临时对象或使用 `std::move` 转移的对象）来提供初始值。它的作用是在对象创建时，通过移动资源（例如动态分配的内存或其他资源）而不是复制，来提高程序的性能和效率。

移动构造函数的语法如下：

```cpp
class MyClass {
public:
    // 移动构造函数
    MyClass(MyClass&& other) {
        // 在这里进行资源的移动操作
        // 通常是将其他对象的资源转移到当前对象
    }
};
```

移动构造函数的参数是一个右值引用 `&&`，它接收一个同类型的右值作为参数。右值引用允许我们直接修改传入的右值对象的状态，而不是创建一个新的对象进行复制。在移动构造函数中，通常会将其他对象的资源（例如指针、动态分配的内存等）转移到当前对象，从而避免了资源的复制和额外的内存分配。

下面是一个示例，演示了移动构造函数的使用：

```cpp
#include <iostream>

class MyResource {
public:
    MyResource() {
        std::cout << "Resource acquired." << std::endl;
    }

    ~MyResource() {
        std::cout << "Resource released." << std::endl;
    }
};

class MyClass {
public:
    // 构造函数
    MyClass() : resource(new MyResource()) {}

    // 移动构造函数
    MyClass(MyClass&& other) : resource(other.resource) {
        other.resource = nullptr; // 将源对象的资源指针设为空，避免重复释放
    }

    ~MyClass() {
        delete resource;
    }

private:
    MyResource* resource;
};

int main() {
    MyClass obj1; // 创建第一个对象
    MyClass obj2 = std::move(obj1); // 使用移动构造函数创建第二个对象

    return 0;
}
```

在底层，移动构造函数主要做了以下几个操作：

1. 接收一个右值引用作为参数，它允许直接修改传入的右值对象的状态。

2. 将其他对象的资源指针转移给当前对象，避免了资源的复制和额外的内存分配。

3. **在移动资源后，为了防止源对象在析构时重复释放资源，通常将源对象的资源指针设为空（将其置为 `nullptr`）**。

需要注意的是，移动构造函数是在以下情况下被隐式调用的：

- 当使用右值（例如临时对象或使用 `std::move` 转移的对象）来初始化一个新对象时，将调用移动构造函数。
- 当返回一个右值对象的局部变量时，将调用移动构造函数（这是返回值优化的一种情况）。

移动构造函数在实际使用中很重要，特别是在涉及到资源的转移和管理时，使用移动语义可以显著提高程序的性能和效率。



#### STD::move（）：

~~~c
'不进行任何实质性的数据移动操作，它只是用于标记一个对象为右值，使得可以调用相应的移动语义操作'
~~~

`std::move` 是 C++ 标准库中提供的一个函数模板，它用于将一个左值转换为右值引用。它的定义位于 `<utility>` 头文件中。`std::move` 并**不进行任何实质性的数据移动操作，它只是用于标记一个对象为右值，使得可以调用相应的移动语义操作**（例如移动构造函数和移动赋值运算符）来提高性能。

`std::move` 的语法如下：

```cpp
template <typename T>
constexpr std::remove_reference_t<T>&& move(T&& t) noexcept;
```

- `T`：要移动的对象的类型。
- `t`：要移动的对象。

`std::move` 将传入的对象 `t` 转换为右值引用，并返回右值引用。这样，可以将该右值引用传递给移动构造函数、移动赋值运算符等，以实现资源的转移，而不是进行深度拷贝。

下面是一个简单的示例，演示了 `std::move` 的使用：

```cpp
#include <iostream>
#include <utility>

class MyResource {
public:
    MyResource() {
        std::cout << "Resource acquired." << std::endl;
    }

    ~MyResource() {
        std::cout << "Resource released." << std::endl;
    }
};

class MyClass {
public:
    // 构造函数
    MyClass() : resource(new MyResource()) {}

    // 移动构造函数
    MyClass(MyClass&& other) : resource(std::move(other.resource)) {}

    ~MyClass() {
        delete resource;
    }

private:
    MyResource* resource;
};

int main() {
    MyClass obj1; // 创建第一个对象
    MyClass obj2 = std::move(obj1); // 使用 std::move 调用移动构造函数

    return 0;
}
```

在上述示例中，通过使用 `std::move` 将 `obj1` 转换为右值引用，并传递给 `MyClass` 的移动构造函数，实现了资源的移动而不是复制。

需要注意的是，使用 `std::move` 时要谨慎，确保对象的状态在移动后仍然有效，避免出现悬空指针或资源泄漏。在使用 `std::move` 之后，通常不应该再使用原对象，除非该对象重新赋值或重新构造。

------



## 容器String：

![image-20230730222723762](D:\typora笔记\c++_stl\image-20230730222723762.png)	

![image-20230730222806982](D:\typora笔记\c++_stl\image-20230730222806982.png)	

### 赋值操作：

![image-20230730222923166](D:\typora笔记\c++_stl\image-20230730222923166.png)	

![image-20230730223148707](D:\typora笔记\c++_stl\image-20230730223148707.png)	![image-20230730223157309](D:\typora笔记\c++_stl\image-20230730223157309.png)	

### 字符串拼接操作：

![image-20230730223309653](D:\typora笔记\c++_stl\image-20230730223309653.png)	

![image-20230730223512767](D:\typora笔记\c++_stl\image-20230730223512767.png)	

#### append和直接 + 的区别：

在 C++ 中，`std::string` 是一个用于存储字符串的容器，它提供了多种方式来拼接字符串，其中包括 `append` 成员函数和使用 `+` 运算符。

1. `append` 成员函数：
   - `append` 是 `std::string` 类的成员函数，用于将一个字符串添加到另一个字符串的末尾。
   - 可以使用 `append` 函数来连接多个字符串，每次都将新的字符串添加到原始字符串的末尾。
   - `append` 函数修改原始字符串，并返回对原始字符串的引用，允许链式调用。

2. `+` 运算符：
   - `+` 运算符重载允许将两个 `std::string` 对象连接起来形成一个新的字符串。
   - 使用 `+` 运算符时，不会修改原始的字符串，而是创建一个新的字符串来保存连接后的结果。

区别和使用场景：
- `append` 成员函数适用于在现有字符串的末尾添加其他字符串。如果需要多次添加，尤其是在循环中拼接字符串时，`append` 更有效率，因为它可以在原始字符串上直接修改，避免了频繁的内存分配和释放。
- `+` 运算符适用于一次性连接两个字符串并生成新的字符串。如果你不想修改原始字符串，并且希望每次连接都生成一个新的字符串，可以使用 `+` 运算符。

示例：
```cpp
#include <iostream>
#include <string>

int main() {
    std::string str1 = "Hello";
    std::string str2 = "World";

    // 使用 append 成员函数
    str1.append(" "); // 在末尾添加空格
    str1.append(str2); // 在末尾添加 str2
    std::cout << "Using append: " << str1 << std::endl; // 输出：Hello World

    // 使用 + 运算符
    std::string str3 = str2 + ", " + str1; // 连接 str2、逗号、str1
    std::cout << "Using + operator: " << str3 << std::endl; // 输出：World, Hello World

    return 0;
}
```

总之，`append` 成员函数适用于在现有字符串的末尾添加其他字符串，而 `+` 运算符用于一次性连接两个字符串并生成新的字符串。根据具体的需求和代码逻辑，可以选择适合的方法。



### 查找，替换操作：

![image-20230730223854726](D:\typora笔记\c++_stl\image-20230730223854726.png)	

当使用 `std::string` 容器时，可以使用 `find`、`rfind` 和 `replace` 成员函数来执行查找和替换操作。下面是这三种操作的所有重载形式的示例代码：

1. `find` 函数：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str = "Hello, Hello, World";

    // Find the first occurrence of "Hello"
    size_t pos1 = str.find("Hello");
    std::cout << "First occurrence of \"Hello\" at position: " << pos1 << std::endl; // Output: 0

    // Find the second occurrence of "Hello" starting from position 7
    size_t pos2 = str.find("Hello", 7);
    std::cout << "Second occurrence of \"Hello\" at position: " << pos2 << std::endl; // Output: 7

    // Find the first occurrence of 'W' (character) starting from position 10
    size_t pos3 = str.find('W', 10);
    std::cout << "First occurrence of 'W' at position: " << pos3 << std::endl; // Output: 14

    return 0;
}
```

2. `rfind` 函数：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str = "Hello, Hello, World";

    // Find the last occurrence of "Hello"
    size_t pos1 = str.rfind("Hello");
    std::cout << "Last occurrence of \"Hello\" at position: " << pos1 << std::endl; // Output: 7

    // Find the last occurrence of "Hello" before position 6
    size_t pos2 = str.rfind("Hello", 6);
    std::cout << "Last occurrence of \"Hello\" before position 6 at position: " << pos2 << std::endl; // Output: 0

    // Find the last occurrence of 'l' (character) before position 11
    size_t pos3 = str.rfind('l', 11);
    std::cout << "Last occurrence of 'l' before position 11 at position: " << pos3 << std::endl; // Output: 10

    return 0;
}
```

3. `replace` 函数：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str = "Hello, World";

    // Replace the first occurrence of "Hello" with "Hi"
    str.replace(str.find("Hello"), 5, "Hi");
    std::cout << "After first replacement: " << str << std::endl; // Output: Hi, World

    // Replace all occurrences of "o" with "O"
    size_t pos = 0;
    while ((pos = str.find("o", pos)) != std::string::npos) {
        str.replace(pos, 1, "O");
        pos += 1;
    }
    std::cout << "After all replacements: " << str << std::endl; // Output: Hi, WOrld

    return 0;
}
```

在这些示例中，我们使用了 `find`、`rfind` 和 `replace` 成员函数的各种重载形式。这些函数可以帮助我们查找字符串中的子字符串，进行替换操作，使得字符串的处理更加灵活和方便。	



### 字符串比较：

~~~
字符串中的每个字符，比较ASCII值；
~~~

![image-20230730224357388](D:\typora笔记\c++_stl\image-20230730224357388.png)	

#### 游戏开发中的使用场景：

在游戏开发中，`std::string` 的 `compare` 函数有多种应用场景。其中一些常见的应用场景包括：

1. 检查字符串相等性：在游戏中，可能需要检查两个字符串是否相等，比如检查玩家输入的用户名是否与保存的用户名匹配。

2. 字符串排序：游戏中可能需要对字符串进行排序，比如排行榜按照玩家得分进行排序。

3. 字符串比较：在游戏中，可能需要根据字符串的大小来做一些判断，比如根据玩家名字的字母顺序分组或排名。

下面是一些示例代码来演示 `std::string` 的 `compare` 函数在游戏开发中的应用：

1. 检查字符串相等性：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string savedUsername = "Alice";
    std::string inputUsername;

    std::cout << "Enter your username: ";
    std::cin >> inputUsername;

    // 检查输入的用户名与保存的用户名是否相等
    if (inputUsername.compare(savedUsername) == 0) {
        std::cout << "Welcome, " << savedUsername << "!\n";
    } else {
        std::cout << "Invalid username.\n";
    }

    return 0;
}
```

2. 字符串排序：

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> players = { "Bob", "Alice", "Eve", "David" };

    // 对玩家名称进行排序
    std::sort(players.begin(), players.end());

    // 输出排序后的玩家名单
    std::cout << "Sorted player names:\n";
    for (const auto& player : players) {
        std::cout << player << "\n";
    }

    return 0;
}
```

3. 字符串比较：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string playerName = "Alice";
    std::string anotherPlayerName = "Bob";

    // 比较两个玩家名称的字母顺序
    int result = playerName.compare(anotherPlayerName);
    if (result < 0) {
        std::cout << playerName << " comes before " << anotherPlayerName << " in alphabetical order.\n";
    } else if (result > 0) {
        std::cout << playerName << " comes after " << anotherPlayerName << " in alphabetical order.\n";
    } else {
        std::cout << "Both names are the same.\n";
    }

    return 0;
}
```

以上示例代码展示了 `std::string` 的 `compare` 函数在游戏开发中的一些应用场景。这些函数可以帮助我们处理字符串的比较、排序和相等性检查等任务，提高代码的灵活性和可读性。



### 字符存取：

~~~
通过数组下标和at进行操作；
~~~

![image-20230730224847498](D:\typora笔记\c++_stl\image-20230730224847498.png)	

![image-20230730224935516](D:\typora笔记\c++_stl\image-20230730224935516.png)	

![image-20230730225022338](D:\typora笔记\c++_stl\image-20230730225022338.png)	进行写操作；



### 字符串插入和删除：

在 C++ 中，`std::string` 类提供了几种方法来插入和删除字符。

1. 插入字符：
   - `insert` 成员函数：用于在指定位置插入字符或字符串。
   - `+=` 运算符：用于将字符或字符串追加到字符串的末尾。

2. 删除字符：
   - `erase` 成员函数：用于从指定位置开始删除字符或一段子字符串。

下面详细说明并举例说明这些操作：

1. 插入字符：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str = "Hello World";

    // 使用 insert 函数在索引 5 处插入一个空格
    str.insert(5, " ");
    std::cout << "After insert: " << str << std::endl; // Output: Hello World

    // 使用 += 运算符在字符串末尾追加一个感叹号
    str += "!";
    std::cout << "After appending: " << str << std::endl; // Output: Hello World!

    return 0;
}
```

2. 删除字符：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str = "Hello World";

    // 使用 erase 函数删除索引 5 处的字符（索引从 0 开始计数）
    str.erase(5, 1);
    std::cout << "After erase: " << str << std::endl; // Output: HelloWorld

    return 0;
}
```

在上述示例中，我们使用 `insert` 成员函数在指定位置插入字符或字符串，使用 `+=` 运算符将字符或字符串追加到字符串的末尾，并使用 `erase` 成员函数从指定位置开始删除字符或一段子字符串。

需要注意的是，`insert` 和 `erase` 函数都会修改原始字符串，而 `+=` 运算符也会修改原始字符串。所以在使用这些方法时，要确保字符串有足够的空间来存储插入或删除后的内容。如果需要在不修改原始字符串的情况下进行插入或删除操作，可以使用 `substr` 函数来创建一个新的字符串。

总结起来，`std::string` 提供了方便的方法来插入和删除字符或子字符串。根据具体的需求，可以选择适合的方法来修改字符串。



### 获取子串：

![image-20230730225329940](D:\typora笔记\c++_stl\image-20230730225329940.png)	

在 C++ 中，`std::string` 类提供了获取子串的方法，即 `substr` 成员函数。`substr` 函数可以从原始字符串中提取一个子串，可以指定起始位置和子串的长度。其语法如下：

```cpp
std::string substr(size_t pos, size_t len = npos) const;
```

- `pos`：指定子串的起始位置，从 0 开始计数。
- `len`：指定子串的长度，默认值为 `npos`，表示提取从 `pos` 开始到字符串末尾的所有字符。

下面详细说明并举例说明如何使用 `substr` 函数：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str = "Hello, World!";

    // 获取从索引 0 开始的子串，即完整字符串
    std::string sub1 = str.substr(0);
    std::cout << "Substring 1: " << sub1 << std::endl; // Output: Hello, World!

    // 获取从索引 7 开始的子串，包含 "World!"
    std::string sub2 = str.substr(7);
    std::cout << "Substring 2: " << sub2 << std::endl; // Output: World!

    // 获取从索引 0 开始的子串，长度为 5
    std::string sub3 = str.substr(0, 5);
    std::cout << "Substring 3: " << sub3 << std::endl; // Output: Hello

    // 获取从索引 7 开始的子串，长度为 5
    std::string sub4 = str.substr(7, 5);
    std::cout << "Substring 4: " << sub4 << std::endl; // Output: World

    return 0;
}
```

在实战中，获取子串时需要注意以下几点：

1. 索引范围：`substr` 函数的起始位置 `pos` 应该在合法的索引范围内，即从 0 到字符串长度（不包括字符串长度）之间。
2. 长度限制：指定的子串长度 `len` 不应该超过从起始位置 `pos` 开始的剩余字符数量，否则将截断字符串。
3. `npos`：当 `len` 参数设置为 `npos` 时，将提取从 `pos` 开始到字符串末尾的所有字符。
4. 返回值：`substr` 函数返回一个新的 `std::string` 对象，包含提取的子串。原始字符串不会被修改。

总结起来，`std::string` 的 `substr` 函数是一种方便的方法，用于获取原始字符串的子串。在实际使用时，要确保指定的起始位置和长度在合法范围内，以及理解 `substr` 函数的返回值是一个新的 `std::string` 对象。	



#### 遗忘知识点：常量成员函数

在 `std::string` 类的成员函数声明中，`const` 关键字的位置位于函数参数列表的括号后面，表示该成员函数是一个**常量成员函数**（const member function）。常量成员函数有以下几个特点：

1. 常量成员函数在函数体内不会修改调用该函数的对象的成员变量。在常量成员函数内部，类的非静态成员变量都被视为常量，不能被修改。

2. 常量成员函数可以被常量对象调用，而非常量对象也可以调用。这意味着即使对象是常量对象（使用 `const` 修饰的对象），也可以调用常量成员函数。

3. 常量成员函数的使用使得对常量对象的操作更加安全，因为它们不会改变对象的状态。

在 `std::string` 的 `substr` 成员函数中，添加 `const` 关键字的目的是为了表示该函数在执行过程中不会修改原始字符串对象的内容，保证对字符串的操作不会对原始对象产生副作用。这样的设计是为了符合常量性和安全性的要求。

下面是一个示例，演示常量成员函数的使用：

```cpp
#include <iostream>
#include <string>

class MyClass {
public:
    void printMessage() const {
        std::cout << "This is a constant member function." << std::endl;
        // 【修改下面的代码会导致编译错误】
        // value = 42;
    }

    int getValue() const {
        return value;
    }

private:
    int value = 10;
};

int main() {
    const MyClass obj1; // 常量对象
    obj1.printMessage(); // 可以调用常量成员函数
    std::cout << "Value: " << obj1.getValue() << std::endl; // 可以调用常量成员函数

    MyClass obj2; // 非常量对象
    obj2.printMessage(); // 也可以调用常量成员函数
    std::cout << "Value: " << obj2.getValue() << std::endl; // 可以调用常量成员函数

    return 0;
}
```

在上述示例中，`printMessage` 和 `getValue` 都被声明为常量成员函数，并且可以在常量对象和非常量对象上调用。注意 `printMessage` 内的修改操作被注释掉了，因为在常量成员函数中无法修改成员变量。

------



## Deque：

![image-20230801235924972](D:\typora笔记\c++_stl\image-20230801235924972.png)	

![image-20230801235939603](D:\typora笔记\c++_stl\image-20230801235939603.png)	

### 中控器：

~~~
·像一片连续的内存空间；
·迭代器是支持随机访问的；
~~~

![image-20230802000033629](D:\typora笔记\c++_stl\image-20230802000033629.png)	

在 C++ 的标准库中，`deque` 的内部实现通常采用了一种双层结构，即分段连续内存的结构。这种结构由两层指针构成，第一层指针指向一系列内存块（也称为分段），每个内存块是一个连续的内存空间，第二层指针则指向每个内存块中的元素。

`deque` 的内部双层结构如下所示：

```
+----------+            +----------+
| Pointer  | ---------->|   Block  |    +--------+--------+--------+--------+
+----------+            +----------+    | Elem1  | Elem2  | Elem3  | Elem4  |
                                       +--------+--------+--------+--------+
                                       | Elem5  | Elem6  | Elem7  | Elem8  |
                                       +--------+--------+--------+--------+
                                        ...
                                       +--------+--------+--------+--------+
                                       | Elemy  | Elemz  |        |        |
                                       +--------+--------+--------+--------+
```

其中，`Pointer` 是一个指向内存块的指针数组，每个元素指向一个内存块。每个内存块中存储了若干个元素（可以是相同类型或不同类型的元素），并且元素是连续存储的。

对于 `deque` 的管理，首先会**有一个 `Pointer` 数组**，其中**每个元素指向一个内存块**。当需要在 `deque` 的队头或队尾插入或删除元素时，**只需要对相应的内存块进行操作，而不需要移动整个 `deque` 中的所有元素**。

当 `deque` 的元素数量增加时，如果**当前内存块已满，会分配一个新的内存块**，并将其链接到 `Pointer` 数组的相应位置。这样，`deque` 就可以继续在队头或队尾插入或删除元素，而不会涉及整个 `deque` 的重新分配和移动。

分段连续内存结构使得 `deque` 具有高效的插入和删除操作，并且支持随机访问。但是，由于分段结构的缘故，`deque` 的内存占用可能比较高，因为每个内存块都需要额外的指针空间。在实际使用中，需要根据具体的场景和性能要求来选择合适的容器类型。如果需要高效的随机访问，并且元素数量较大且连续插入和删除操作不频繁，可能更适合使用 `vector`；如果需要频繁在队头和队尾插入和删除元素，并且随机访问性能相对较低也可以接受，可以使用 `deque`。

### 构造函数：

![image-20230802000148052](D:\typora笔记\c++_stl\image-20230802000148052.png)	

`deque`（双端队列）是一种动态数组（数组列表）的数据结构，它允许在两端进行高效的插入和删除操作，即在队头和队尾进行操作的时间复杂度都是常数时间。`deque` 支持随机访问，并且在内存中是连续存储的。

在 C++ 中，`deque` 是标准库 `<deque>` 中定义的容器类。它的构造函数有多种形式，可以根据不同的需求创建 `deque` 对象。

以下是 `deque` 的主要构造函数形式：

1. 默认构造函数：创建一个空的 `deque`。

```cpp
#include <deque>

int main() {
    std::deque<int> myDeque; // 创建一个空的 deque

    return 0;
}
```

2. 带初始化列表的构造函数：创建一个包含初始化列表中元素的 `deque`。

```cpp
#include <deque>

int main() {
    std::deque<int> myDeque = {1, 2, 3}; // 创建一个包含 {1, 2, 3} 的 deque

    return 0;
}
```

3. 带大小和默认值的构造函数：创建一个指定大小并用默认值初始化的 `deque`。

```cpp
#include <deque>

int main() {
    std::deque<int> myDeque(5, 42); // 创建一个包含 5 个元素，每个元素都是 42 的 deque

    return 0;
}
```

4. 带迭代器范围的构造函数：创建一个包含迭代器范围内元素的 `deque`。

```cpp
#include <deque>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::deque<int> myDeque(vec.begin(), vec.end()); // 使用迭代器范围创建 deque

    return 0;
}
```

除了以上形式，`deque` 还支持其他多种构造函数，例如复制构造函数和移动构造函数。需要根据具体的需求选择合适的构造函数来创建 `deque` 对象。在实际使用中，可以根据元素的插入和删除需求来选择使用 `deque` 或其他容器，以满足性能和功能上的要求。	

### 和vector的区别：

`deque` 和 `vector` 都是 C++ 标准库中提供的动态数组（数组列表）容器，它们在某些方面有相似之处，但也有一些区别。以下是 `deque` 和 `vector` 的主要区别：

1. 内部实现：`vector` 内部使用单个连续的内存块来存储元素，因此在内存中是连续的。而 `deque` 内部采用了分段连续内存的结构，由多个连续内存块组成，每个内存块是一个固定大小的连续内存空间，通过指针进行链接。因此，`deque` 在内存中并不是完全连续的。

2. 插入和删除操作效率：由于 `deque` 内部采用了分段结构，它在队头和队尾进行插入和删除操作的效率较高，时间复杂度为 O(1)。而 `vector` 在队头和队尾进行插入和删除操作时需要移动其他元素，时间复杂度为 O(n)。所以对于频繁在队头和队尾插入和删除元素的场景，`deque` 可能更适合。

3. 随机访问效率：`vector` 内部元素在连续内存块中，因此可以通过指针和偏移量快速访问任意位置的元素，时间复杂度为 O(1)。而 `deque` 的分段结构导致在随机访问时可能会稍微慢一些，时间复杂度也是 O(1)，但由于有额外的指针开销，实际性能可能略低于 `vector`。

4. 内存占用：由于 `deque` 需要额外的指针来管理分段结构，所以在内存占用方面可能相对于 `vector` 稍微更高一些。

综上所述，`deque` 和 `vector` 在插入和删除操作的效率、随机访问性能和内存占用方面有所不同，因此在实际使用中需要根据具体的场景和性能要求来选择合适的容器类型。如果需要高效的随机访问，并且元素数量较大且连续插入和删除操作不频繁，可能更适合使用 `vector`；如果需要频繁在队头和队尾插入和删除元素，并且随机访问性能相对较低也可以接受，可以使用 `deque`。

### 赋值操作：

![image-20230802000940779](D:\typora笔记\c++_stl\image-20230802000940779.png)	

在 C++ 中，可以使用多种方式给 `deque` 容器赋值，具体取决于需求和情况。以下是常见的给 `deque` 容器赋值的方式：

1. 使用初始化列表赋值：可以通过初始化列表直接为 `deque` 容器赋初值。

```cpp
#include <deque>

int main() {
    std::deque<int> myDeque = {1, 2, 3, 4, 5}; // 使用初始化列表赋值

    return 0;
}
```

2. 使用赋值运算符 `=`：可以将一个 `deque` 容器的内容复制给另一个 `deque` 容器。

```cpp
#include <deque>

int main() {
    std::deque<int> deque1 = {1, 2, 3};
    std::deque<int> deque2;

    deque2 = deque1; // 将 deque1 的内容复制给 deque2

    return 0;
}
```

3. 使用 `assign` 成员函数：`deque` 提供了 `assign` 成员函数，可以用于将特定范围的元素赋值给 `deque`。

```cpp
#include <deque>
#include <vector>

int main() {
    std::deque<int> myDeque;

    // 使用 assign 将 vector 中的元素赋值给 deque
    std::vector<int> myVector = {10, 20, 30};
    myDeque.assign(myVector.begin(), myVector.end());

    return 0;
}
```

4. 使用 `resize` 成员函数：`resize` 函数用于改变 `deque` 容器的大小，并将新的元素赋予特定的值。

```cpp
#include <deque>

int main() {
    std::deque<int> myDeque;

    // 使用 resize 改变 deque 容器的大小并赋值
    myDeque.resize(5, 42); // 将 deque 的大小设置为 5，并用值 42 初始化新的元素

    return 0;
}
```

无论使用哪种方式，都可以将元素赋值给 `deque` 容器。在实际使用中，可以根据具体的需求和数据来源选择合适的方式来赋值。	



### deque大小，空：

![image-20230802001254193](D:\typora笔记\c++_stl\image-20230802001254193.png)	

在 C++ 中，可以使用 `size()` 成员函数来获取 `deque` 容器的大小，使用 `empty()` 成员函数来判断 `deque` 是否为空。

1. 获取 `deque` 的大小：

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> myDeque = {1, 2, 3, 4, 5};

    // 使用 size() 成员函数获取 deque 的大小
    std::cout << "Size of myDeque: " << myDeque.size() << std::endl;

    return 0;
}
```

输出结果：
```
Size of myDeque: 5
```

2. 判断 `deque` 是否为空：

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> myDeque;

    // 使用 empty() 成员函数判断 deque 是否为空
    if (myDeque.empty()) {
        std::cout << "myDeque is empty." << std::endl;
    } else {
        std::cout << "myDeque is not empty." << std::endl;
    }

    return 0;
}
```

输出结果：
```
myDeque is empty.
```

注意事项：
- `size()` 返回的是 `size_t` 类型的无符号整数，表示 `deque` 中的元素个数。
- `empty()` 返回一个布尔值，当 `deque` 为空时返回 `true`，否则返回 `false`。
- 在使用 `size()` 方法时要注意返回值类型**是无符号整数，不要与有符号整数混用**，避免出现潜在的类型转换问题。
- 在判断是否为空时，使用 `empty()` 方法比直接比较 `size()` 是否为 0 更加直观和语义化。



### 插入，删除操作：

![image-20230802001400957](D:\typora笔记\c++_stl\image-20230802001400957.png)	

`deque` 提供了多种插入和删除操作，允许在队头和队尾以及指定位置插入和删除元素。以下是 `deque` 的常用插入和删除操作的详细说明：

1. 在队头和队尾插入元素：

- `push_front(value)`：在 `deque` 的队头插入一个元素，将 `value` 添加到队头。

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> myDeque = {1, 2, 3};

    myDeque.push_front(0); // 在队头插入元素 0

    for (const auto& num : myDeque) {
        std::cout << num << " ";
    }

    return 0;
}
```

输出结果：
```
0 1 2 3
```

- `push_back(value)`：在 `deque` 的队尾插入一个元素，将 `value` 添加到队尾。

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> myDeque = {1, 2, 3};

    myDeque.push_back(4); // 在队尾插入元素 4

    for (const auto& num : myDeque) {
        std::cout << num << " ";
    }

    return 0;
}
```

输出结果：
```
1 2 3 4
```

2. 在指定位置插入元素：

- `insert(position, value)`：在指定位置 `position` 前插入元素 `value`。

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> myDeque = {1, 2, 3};

    auto it = myDeque.begin() + 1;
    myDeque.insert(it, 4); // 在位置 1 前插入元素 4

    for (const auto& num : myDeque) {
        std::cout << num << " ";
    }

    return 0;
}
```

输出结果：
```
1 4 2 3
```

3. 删除元素：

- `pop_front()`：删除 `deque` 的队头元素。

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> myDeque = {1, 2, 3};

    myDeque.pop_front(); // 删除队头元素

    for (const auto& num : myDeque) {
        std::cout << num << " ";
    }

    return 0;
}
```

输出结果：
```
2 3
```

- `pop_back()`：删除 `deque` 的队尾元素。

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> myDeque = {1, 2, 3};

    myDeque.pop_back(); // 删除队尾元素

    for (const auto& num : myDeque) {
        std::cout << num << " ";
    }

    return 0;
}
```

输出结果：
```
1 2
```

- `erase(position)`：删除指定位置 `position` 处的元素。

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> myDeque = {1, 2, 3};

    auto it = myDeque.begin() + 1;
    myDeque.erase(it); // 删除位置 1 处的元素

    for (const auto& num : myDeque) {
        std::cout << num << " ";
    }

    return 0;
}
```

输出结果：
```
1 3
```

- `erase(first, last)`：删除位于范围 `[first, last)` 内的元素。

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> myDeque = {1, 2, 3, 4, 5};

    auto first = myDeque.begin() + 1;
    auto last = myDeque.begin() + 3;
    myDeque.erase(first, last); // 删除位置 1 和 2 处的元素

    for (const auto& num : myDeque) {
        std::cout << num << " ";
    }

    return 0;
}
```

输出结果：
```
1 4 5
```

在实际使用中，可以根据具体的需求选择合适的插入和删除操作。需要注意的是，在使用迭代器对 `deque` 进行插入和删除操作时，要确保迭代器仍然有效，否则可能导致未定义行为。如果插入和删除操作频繁，并且需要在队头和队尾进行高效的操作，可以考虑使用 `deque` 容器。	



### 数据存取：

![image-20230802001652624](D:\typora笔记\c++_stl\image-20230802001652624.png)	



### deque排序：

在 C++ 中，可以使用 `<algorithm>` 头文件中的 `std::sort` 算法对 `deque` 容器进行排序。`std::sort` 是一种常用的排序算法，它采用的是快速排序（Quick Sort）或者是归并排序（Merge Sort）的变种。排序时，`std::sort` 会对元素进行比较并交换位置，直到整个 `deque` 容器中的元素按照升序或者降序排列。

使用 `std::sort` 对 `deque` 进行排序的示例代码如下：

```cpp
#include <iostream>
#include <deque>
#include <algorithm>

int main() {
    std::deque<int> myDeque = {5, 2, 8, 3, 1};

    // 使用 std::sort 对 deque 进行升序排序
    std::sort(myDeque.begin(), myDeque.end());

    for (const auto& num : myDeque) {
        std::cout << num << " ";
    }

    return 0;
}
```

输出结果：
```
1 2 3 5 8
```

在实际应用中，也可以通过自定义比较函数来实现对 `deque` 的排序方式。例如，可以使用 `std::sort` 的第三个参数传入自定义的比较函数，以实现降序排序。

```cpp
#include <iostream>
#include <deque>
#include <algorithm>

// 自定义比较函数，实现降序排序
bool descendingOrder(int a, int b) {
    return a > b;
}

int main() {
    std::deque<int> myDeque = {5, 2, 8, 3, 1};

    // 使用自定义比较函数 descendingOrder 对 deque 进行降序排序
    std::sort(myDeque.begin(), myDeque.end(), descendingOrder);

    for (const auto& num : myDeque) {
        std::cout << num << " ";
    }

    return 0;
}
```

输出结果：
```
8 5 3 2 1
```

`std::sort` 函数的时间复杂度为 O(N log N)，其中 N 是 `deque` 容器中的元素个数。在实际使用中，如果需要对 `deque` 容器进行排序，`std::sort` 是一个高效且方便的选择。

总结起来，使用 `std::sort` 可以对 `deque` 容器进行排序，实现升序或降序排列。排序算法的具体实现可能采用快速排序或归并排序的变种，使得排序效率较高。在实际应用中，可以通过自定义比较函数实现不同的排序方式。	

------



## stack容器：

~~~
先进后出；
~~~

![image-20230802002141601](D:\typora笔记\c++_stl\image-20230802002141601.png)	

### 构造函数：

在 C++ 中，`std::stack` 是标准库中的容器适配器，它基于其他容器（默认情况下是 `std::deque`）提供了栈（先进后出）的功能。`std::stack` 的构造函数有以下几种形式：

1. 默认构造函数：

```cpp
std::stack<T> myStack;
```

这将创建一个空的栈 `myStack`，其中 `T` 是栈中存储元素的数据类型。

2. 拷贝构造函数：

```cpp
std::stack<T> myStack(otherStack);
```

这将创建一个新的栈 `myStack`，并将 `otherStack` 中的元素拷贝到其中，其中 `T` 是栈中存储元素的数据类型。

3. 移动构造函数：

```cpp
std::stack<T> myStack(std::move(otherStack));
```

这将创建一个新的栈 `myStack`，并将 `otherStack` 中的元素移动到其中，其中 `T` 是栈中存储元素的数据类型。在移动构造后，`otherStack` 将不再包含元素。

4. 使用指定容器的构造函数：

```cpp
std::stack<T, Container> myStack;
```

这将创建一个空的栈 `myStack`，其中 `T` 是栈中存储元素的数据类型，`Container` 是用于存储元素的容器类型。默认情况下，`Container` 是 `std::deque`，也可以使用其他支持的容器，如 `std::vector` 或 `std::list`。

其中，`std::stack` 还支持使用默认拷贝和移动构造函数。如果不指定容器类型，则默认使用 `std::deque` 作为内部容器。

请注意，由于 `std::stack` 是容器适配器，它本身并不具有直接访问容器元素的能力，而是通过提供栈的操作接口来间接访问底层容器。如果需要直接访问底层容器的元素，可以考虑使用 `std::deque` 或其他支持随机访问的容器。	



### stack的元素操作：

~~~c
//`std::stack` 是容器适配器，提供了栈（先进后出）的功能，但本身并没有提供直接访问容器元素的方法。如果需要直接访问底层容器元素，可以使用指定容器类型的 `std::deque`、`std::vector`、`std::list` 等。

//`Container` 是底层容器的类型，可以是 `std::deque`、`std::vector`、`std::list` 等**支持尾部插入和删除的容器。如果不指定 `Container`，默认使用 `std::deque`。
~~~

使用 `std::stack<T, Container>` 的方式来创建栈对象时，需要指定存储元素的数据类型 `T` 和底层容器类型 `Container`。然后，可以使用栈提供的成员函数来操作栈，如入栈（push）、出栈（pop）、获取栈顶元素（top）、判断栈是否为空（empty）等。

下面是一个使用 `std::stack<int, std::deque<int>>` 创建栈对象并操作的示例代码：

```cpp
#include <iostream>
#include <stack>
#include <deque>

int main() {
    // 使用 std::stack<int, std::deque<int>> 创建一个栈对象
    std::stack<int, std::deque<int>> myStack;

    // 入栈操作
    myStack.push(1);
    myStack.push(2);
    myStack.push(3);

    // 获取栈顶元素
    std::cout << "Top element: " << myStack.top() << std::endl;

    // 出栈操作
    myStack.pop();

    // 再次获取栈顶元素
    std::cout << "Top element after pop: " << myStack.top() << std::endl;

    // 判断栈是否为空
    if (myStack.empty()) {
        std::cout << "Stack is empty." << std::endl;
    } else {
        std::cout << "Stack is not empty." << std::endl;
    }

    return 0;
}
```

输出结果：
```
Top element: 3
Top element after pop: 2
Stack is not empty.
```

在使用 `std::stack<T, Container>` 时，需要注意以下几点：
1. `T` 是存储在栈中的元素的数据类型，可以是任意合法的数据类型，如 `int`、`double`、`std::string` 等。
2. `Container` 是底层容器的类型，可以是 `std::deque`、`std::vector`、`std::list` 等**支持尾部插入和删除的容器。如果不指定 `Container`，默认使用 `std::deque`。**
3. 注意成员函数的使用，如 `push()`、`pop()`、`top()`、`empty()` 等。这些成员函数用于操作栈中的元素。
4. `std::stack` 是容器适配器，提供了栈（先进后出）的功能，但本身并没有提供直接访问容器元素的方法。如果需要直接访问底层容器元素，可以使用指定容器类型的 `std::deque`、`std::vector`、`std::list` 等。

------



## Queue容器：

~~~
先进先出
~~~

![image-20230802002635417](D:\typora笔记\c++_stl\image-20230802002635417.png)	

![image-20230802002706372](D:\typora笔记\c++_stl\image-20230802002706372.png)	

### 构造函数：

~~~c
//请注意，由于 `std::queue` 是容器适配器，它本身并不具有直接访问容器元素的能力，而是通过提供队列的操作接口来间接访问底层容器。如果需要直接访问底层容器的元素，可以考虑使用 `std::deque` 或其他支持随机访问的容器。	
~~~

在 C++ 中，`std::queue` 是标准库中的容器适配器，它基于其他容器（默认情况下是 `std::deque`）提供了队列（先进先出）的功能。`std::queue` 的构造函数有以下几种形式：

1. 默认构造函数：

```cpp
std::queue<T> myQueue;
```

这将创建一个空的队列 `myQueue`，其中 `T` 是队列中存储元素的数据类型。

2. 拷贝构造函数：

```cpp
std::queue<T> myQueue(otherQueue);
```

这将创建一个新的队列 `myQueue`，并将 `otherQueue` 中的元素拷贝到其中，其中 `T` 是队列中存储元素的数据类型。

3. 移动构造函数：

```cpp
std::queue<T> myQueue(std::move(otherQueue));
```

这将创建一个新的队列 `myQueue`，并将 `otherQueue` 中的元素移动到其中，其中 `T` 是队列中存储元素的数据类型。在移动构造后，`otherQueue` 将不再包含元素。

4. 使用指定容器的构造函数：

```cpp
std::queue<T, Container> myQueue;
```

这将创建一个空的队列 `myQueue`，其中 `T` 是队列中存储元素的数据类型，`Container` 是用于存储元素的容器类型。默认情况下，`Container` 是 `std::deque`，也可以使用其他支持的容器，如 `std::list`。

其中，`std::queue` 还支持使用默认拷贝和移动构造函数。如果不指定容器类型，则默认使用 `std::deque` 作为内部容器。

请注意，由于 `std::queue` 是容器适配器，它本身并不具有直接访问容器元素的能力，而是通过提供队列的操作接口来间接访问底层容器。如果需要直接访问底层容器的元素，可以考虑使用 `std::deque` 或其他支持随机访问的容器。	



### 遍历操作：

queue不支持直接遍历，只有头尾两个元素暴露在外面；

在 C++ 中，`std::queue` 是容器适配器，它本身不支持直接遍历操作。`std::queue` 提供的是队列（先进先出）的功能，它隐藏了底层容器的实现细节，并只暴露了一部分接口供用户操作，这些接口包括入队（push）、出队（pop）、获取队头元素（front）等。

如果需要遍历 `std::queue` 容器中的元素，通常可以通过如下的方式实现：

1. 使用辅助容器：将 `std::queue` 中的元素逐个出队，并同时入队到一个辅助容器中，然后对辅助容器进行遍历操作。

```cpp
#include <iostream>
#include <queue>

int main() {
    std::queue<int> myQueue;
    myQueue.push(1);
    myQueue.push(2);
    myQueue.push(3);

    // 使用辅助容器存储队列中的元素
    std::queue<int> tempQueue = myQueue;
    while (!tempQueue.empty()) {
        std::cout << tempQueue.front() << " ";
        tempQueue.pop();
    }

    return 0;
}
```

输出结果：
```
1 2 3
```

2. 不遍历，只使用队列的成员函数：在实际应用中，通常不需要遍历整个 `std::queue` 容器，而是根据队列的特性，使用 `front()` 获取队头元素或者通过 `pop()` 出队处理元素。

如果需要遍历整个队列，并且频繁地访问队列中的元素，可能需要考虑使用其他容器，如 `std::vector` 或 `std::deque`，它们支持随机访问，并且可以直接遍历操作。或者，可以在入队时同时将元素存储到其他容器中，以便随后进行遍历操作。

总结起来，`std::queue` 不支持直接遍历操作，但可以通过辅助容器或者使用队列的成员函数来实现对队列中元素的遍历。根据具体需求，可以选择适合的容器来处理数据。



### 存取操作：

1. 存取元素：
   - 入队操作：使用 `push()` 成员函数将元素添加到队列的尾部。
   - 出队操作：使用 `pop()` 成员函数将队列头部的元素移出队列。

```cpp
#include <iostream>
#include <queue>

int main() {
    std::queue<int> myQueue;

    // 入队操作
    myQueue.push(1);
    myQueue.push(2);
    myQueue.push(3);

    // 出队操作
    myQueue.pop();

    return 0;
}
```

2. 获取队列大小：
   - 使用 `size()` 成员函数可以获取队列中的元素个数。

```cpp
#include <iostream>
#include <queue>

int main() {
    std::queue<int> myQueue;

    myQueue.push(1);
    myQueue.push(2);
    myQueue.push(3);

    // 获取队列大小
    std::cout << "Queue size: " << myQueue.size() << std::endl;

    return 0;
}
```

输出结果：
```
Queue size: 3
```

3. 判断队列是否为空：
   - 使用 `empty()` 成员函数可以判断队列是否为空。如果队列为空，返回 `true`，否则返回 `false`。

```cpp
#include <iostream>
#include <queue>

int main() {
    std::queue<int> myQueue;

    // 判断队列是否为空
    if (myQueue.empty()) {
        std::cout << "Queue is empty." << std::endl;
    } else {
        std::cout << "Queue is not empty." << std::endl;
    }

    return 0;
}
```

输出结果：
```
Queue is empty.
```

总结：`std::queue` 提供了 `push()` 和 `pop()` 成员函数用于入队和出队操作，`size()` 成员函数用于获取队列大小，`empty()` 成员函数用于判断队列是否为空。使用这些成员函数可以对队列进行常见的存取操作。	

------



## List链表：

![image-20230802003254119](D:\typora笔记\c++_stl\image-20230802003254119.png)	

### 双向循环链表

![image-20230802003350075](D:\typora笔记\c++_stl\image-20230802003350075.png)	

~~~
迭代器只支持前移，后移，是双向迭代器；

链表，只能一个一个往下访问；
~~~

### 优缺点：

链表是一种常见的数据结构，它在游戏开发中有一些优点和缺点，这些特点对于不同的游戏场景和需求可能会产生不同的影响。

优点：
1. 动态内存分配：链表的节点可以在运行时动态创建和删除，这使得它适用于不确定大小的数据集合，可以根据需要动态地分配和释放内存。这对于游戏中动态生成和销毁游戏对象、管理游戏资源等非常有用。
2. 插入和删除效率高：在链表中插入和删除元素的时间复杂度是 O(1)，只需修改指针的指向即可。这对于频繁插入和删除元素的情况下非常高效，比如碰撞检测、动画管理等。
3. 不会造成内存碎片：由于链表动态地分配内存，不会像数组那样造成内存碎片的问题，这对于长时间运行的游戏很有优势。
4. 支持任意长度的数据：链表没有固定大小的限制，可以容纳任意长度的数据，这对于处理不同大小的数据结构很有用。

缺点：
1. 随机访问低效：链表是一种顺序存储结构，要访问链表中的某个元素，需要从头开始遍历直到找到目标元素，时间复杂度是 O(n)。这在需要频繁随机访问元素的情况下效率较低，如使用索引访问元素。
2. 内存占用较大：链表节点需要额外的指针来连接节点，这会增加额外的内存开销，相比于数组，链表可能会占用更多的内存空间。
3. 缓存效率低：链表的节点在内存中是不连续的，这可能导致对节点的访问不连续，影响缓存的效率。而数组的元素在内存中是连续存储的，对于 CPU 缓存的利用更加高效。
4. 不适合频繁排序：链表的插入和删除效率很高，但如果需要频繁对链表进行排序，效率会较低。相比之下，数组可以使用更高效的排序算法，如快速排序。

综上所述，链表在游戏开发中有其独特的优点和缺点，根据不同的场景和需求，可以选择合适的数据结构来满足游戏的性能和功能要求。链表在动态管理和频繁插入、删除元素的场景中表现出色，而在频繁随机访问和排序等场景中可能不是最佳选择。



### 构造函数：

![image-20230802003707066](D:\typora笔记\c++_stl\image-20230802003707066.png)	

1. 默认构造函数：

```cpp
std::list<T> myList;
```

这将创建一个空的链表 `myList`，其中 `T` 是链表中存储元素的数据类型。

2. 拷贝构造函数：

```cpp
std::list<T> myList(otherList);
```

这将创建一个新的链表 `myList`，并将 `otherList` 中的元素拷贝到其中，其中 `T` 是链表中存储元素的数据类型。

3. 移动构造函数：

```cpp
std::list<T> myList(std::move(otherList));
```

这将创建一个新的链表 `myList`，并将 `otherList` 中的元素移动到其中，其中 `T` 是链表中存储元素的数据类型。在移动构造后，`otherList` 将不再包含元素。

4. 指定大小和值的构造函数：

```cpp
std::list<T> myList(size_t count, const T& value = T());
```

这将创建一个包含 `count` 个元素的链表 `myList`，每个元素都被初始化为 `value`，其中 `T` 是链表中存储元素的数据类型。

5. 使用迭代器范围的构造函数：

```cpp
std::list<T> myList(InputIterator first, InputIterator last);
```

这将创建一个链表 `myList`，其中包含范围 `[first, last)` 中的元素，`InputIterator` 是输入迭代器的类型，用于遍历输入范围。

注意：`std::list` 还支持使用默认拷贝和移动构造函数。如果使用默认构造函数或者拷贝构造函数，将创建一个空链表。如果使用移动构造函数，将创建一个新链表并接管原链表的元素。



### 赋值，交换操作：

![image-20230802003819469](D:\typora笔记\c++_stl\image-20230802003819469.png)	

在 C++ 中，`std::list` 提供了两种方式来进行赋值和交换操作：

1. 赋值操作：
   - 使用 `operator=` 或 `assign()` 成员函数可以将一个 `std::list` 对象赋值给另一个 `std::list` 对象，从而完成两个链表之间的赋值。

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> list1 = {1, 2, 3};
    std::list<int> list2;

    // 使用 operator= 赋值
    list2 = list1;

    // 或者使用 assign() 成员函数赋值
    // list2.assign(list1.begin(), list1.end());

    // 输出 list2
    for (int num : list2) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

输出结果：
```
1 2 3
```

2. 交换操作：
   - 使用 `swap()` 成员函数可以交换两个 `std::list` 对象的内容，这在某些情况下可以帮助实现一些高效的算法。

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> list1 = {1, 2, 3};
    std::list<int> list2 = {4, 5, 6};

    // 交换两个 list 的内容
    list1.swap(list2);

    // 输出交换后的 list1
    for (int num : list1) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    // 输出交换后的 list2
    for (int num : list2) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

输出结果：
```
4 5 6
1 2 3
```

注意：在进行赋值和交换操作时，`std::list` 的元素会根据其拷贝或移动语义进行赋值或交换。对于较大的链表，赋值和交换可能会涉及大量的元素拷贝或移动，因此在性能敏感的场景下，需要谨慎考虑这些操作的影响。对于较大的链表，推荐使用移动语义或使用 `std::swap` 函数来实现交换，以避免不必要的元素拷贝。	

### 大小操作：

![image-20230802004001627](D:\typora笔记\c++_stl\image-20230802004001627.png)	



### 插入，删除操作：

![image-20230802004121311](D:\typora笔记\c++_stl\image-20230802004121311.png)	

在 C++ 中，`std::list` 是一个双向链表，提供了多种插入和删除操作。以下是 `std::list` 的插入和删除操作的详细说明：

1. 插入元素：

   a. `push_back()`：在链表尾部插入元素。
   ```cpp
   std::list<int> myList;
   myList.push_back(1); // 在尾部插入元素1
   ```

   b. `push_front()`：在链表头部插入元素。
   ```cpp
   std::list<int> myList;
   myList.push_front(1); // 在头部插入元素1
   ```

   c. `insert()`：在指定位置插入元素。
   ```cpp
   std::list<int> myList = {1, 2, 3};
   auto it = myList.begin(); // 获取指向第一个元素的迭代器
   myList.insert(it, 4); // 在第一个元素之前插入元素4
   ```

2. 删除元素：

   a. `pop_back()`：删除链表尾部的元素。
   ```cpp
   std::list<int> myList = {1, 2, 3};
   myList.pop_back(); // 删除尾部的元素3
   ```

   b. `pop_front()`：删除链表头部的元素。
   ```cpp
   std::list<int> myList = {1, 2, 3};
   myList.pop_front(); // 删除头部的元素1
   ```

   c. `erase()`：删除指定位置的元素。
   ```cpp
   std::list<int> myList = {1, 2, 3};
   auto it = myList.begin(); // 获取指向第一个元素的迭代器
   myList.erase(it); // 删除第一个元素
   ```

   d. `remove()`：删除指定值的所有元素。
   ```cpp
   std::list<int> myList = {1, 2, 3, 2, 4};
   myList.remove(2); // 删除所有值为2的元素
   ```

   e. `clear()`：删除所有元素，使链表为空。
   ```cpp
   std::list<int> myList = {1, 2, 3};
   myList.clear(); // 删除所有元素，使链表为空
   ```

3. 注意事项：
   - 在插入或删除元素后，原有的迭代器可能会失效，因为链表的元素会在内存中重新排列，所以需要注意在循环中进行插入或删除操作时，要避免对失效的迭代器进行访问。
   - `remove()` 函数是从头到尾遍历链表，删除值为指定值的所有元素。它的时间复杂度为 O(n)，其中 n 是链表中的元素个数。如果只需要删除指定位置的元素，推荐使用 `erase()` 函数，它的时间复杂度为 O(1)。

总结：`std::list` 提供了多种插入和删除操作，它是一个非常方便的容器，特别适用于频繁插入和删除元素的场景。在使用这些操作时，要注意避免使用失效的迭代器，并根据具体情况选择合适的操作。



### 数据存取：

~~~
没有at操作，这个是链表，不连续
~~~

![image-20230802004308733](D:\typora笔记\c++_stl\image-20230802004308733.png)	



### list反转，排序

在 C++ 中，`std::list` 提供了反转和排序操作，可以使用成员函数来完成这些操作。

1. 反转操作：
   - 使用 `reverse()` 成员函数可以将链表中的元素顺序反转。

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> myList = {1, 2, 3, 4, 5};

    // 反转链表
    myList.reverse();

    // 输出反转后的链表
    for (int num : myList) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

输出结果：
```
5 4 3 2 1
```

原理：`std::list` 内部使用双向链表数据结构，`reverse()` 成员函数会通过修改节点的指针来反转链表中元素的顺序。具体来说，它会将每个节点的 `prev` 指针和 `next` 指针交换，从而改变节点的链接关系，实现链表的反转。

2. 排序操作：
   - 使用 `sort()` 成员函数可以对链表中的元素进行排序，**默认按升序排序。**

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> myList = {5, 2, 1, 4, 3};

    // 对链表元素进行排序
    myList.sort();

    // 输出排序后的链表
    for (int num : myList) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

输出结果：
```
1 2 3 4 5
```

原理：`std::list` 的 `sort()` 成员函数使用类似归并排序或快速排序的排序算法对链表中的元素进行排序。这些排序算法在链表上实现较为高效，因为链表支持快速的插入和删除操作。具体排序算法可能因实现和编译器而异，但保证时间复杂度是 O(n log n)。

在排序操作中，可以使用自定义的比较函数或 lambda 表达式来指定排序规则。例如，如果希望按降序排序，可以传递一个比较函数给 `sort()` 成员函数。

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> myList = {5, 2, 1, 4, 3};

    // 按降序对链表元素进行排序
    myList.sort([](int a, int b) { return a > b; }); //lambda表达式

    // 输出排序后的链表
    for (int num : myList) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}

//************************************************************************************************
#include <iostream>
#include <list>

// 自定义比较函数，用于降序排序
bool compare(int a, int b) {
    return a > b;
}

int main() {
    std::list<int> myList = {5, 2, 1, 4, 3};

    // 对链表元素进行降序排序，使用自定义的比较函数
    myList.sort(compare);

    // 输出排序后的链表
    for (int num : myList) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

输出结果：
```
5 4 3 2 1
```

总结：`std::list` 提供了方便的 `reverse()` 和 `sort()` 成员函数来反转和排序链表中的元素。使用这些操作时，可以根据实际需求来选择默认的升序排序或自定义的排序规则。在链表较大时，排序操作可能会涉及大量元素的移动，因此在性能敏感的场景中，应谨慎使用排序操作。

------



## Set容器：

~~~
关联式：指存入数据之前会排序，各个数据之间存在关联；
~~~

![image-20230804191431449](D:\typora笔记\c++_stl\image-20230804191431449.png)	

### 构造方法：

在 C++ 中，`std::set` 是一个关联容器，用于存储一组不重复的元素，且按照一定的顺序进行排序。`std::set` 内部使用红黑树（一种平衡二叉搜索树）来实现这种有序的存储和快速的查找。

`std::set` 的构造函数有多种形式，以下是一些常见的构造方法示例：

1. 默认构造函数：
   - 创建一个空的 `std::set`。

```cpp
#include <iostream>
#include <set>

int main() {
    std::set<int> mySet; // 默认构造函数，创建一个空的 set

    return 0;
}
```

2. 带比较函数的构造函数：
   - 创建一个使用自定义比较函数进行排序的 `std::set`。

```cpp
#include <iostream>
#include <set>

bool compare(int a, int b) {
    return a > b; // 降序排序
}

int main() {
    std::set<int, decltype(compare)*> mySet(compare); // 使用自定义比较函数

    return 0;
}


/**
在表达式 `std::set<int, decltype(compare)*> mySet(compare);` 中，`decltype` 是 C++ 中的一个关键字，用于获取指定表达式的类型。在这个上下文中，它用于获取 `compare` 函数的类型。

让我们逐步解释这个表达式：

1. `decltype(compare)*`：这部分是一个指针类型的声明。`decltype(compare)` 获取了 `compare` 函数的类型，然后 `*` 表示这是一个指向该类型的指针。

2. `mySet(compare);`：这是在声明 `std::set` 容器的同时进行初始化的语法。它使用了上面声明的指针类型的构造函数。

   - `compare` 是一个自定义的比较函数。
   - `mySet(compare);` 使用 `compare` 函数作为比较函数来初始化 `mySet`。

这种方式的结果是，我们通过声明一个指向 `compare` 函数类型的指针来指定 `std::set` 的排序规则。这意味着 `mySet` 在插入元素时会根据 `compare` 函数的规则来进行排序。

注意：这种方式在一些情况下很有用，可以在创建 `std::set` 容器时灵活地指定排序规则。如果不需要自定义排序规则，可以使用默认的构造函数，或者使用默认的比较函数来创建 `std::set`。
**/
```

3. 使用范围构造函数：
   - 使用指定范围的迭代器构造 `std::set`。

```cpp
#include <iostream>
#include <set>
#include <vector>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};
    std::set<int> mySet(vec.begin(), vec.end());

    return 0;
}
```

4. 拷贝构造函数：
   - 使用另一个 `std::set` 的副本构造一个新的 `std::set`。

```cpp
#include <iostream>
#include <set>

int main() {
    std::set<int> originalSet = {1, 2, 3};
    std::set<int> mySet(originalSet); // 使用拷贝构造函数

    return 0;
}
```

5. 使用初始化列表的构造函数：
   - 使用初始化列表直接初始化 `std::set`。

```cpp
#include <iostream>
#include <set>

int main() {
    std::set<int> mySet = {5, 2, 8, 1, 3};

    return 0;
}
```

这些是一些常见的 `std::set` 构造函数的示例。在实际使用中，你可以根据需要选择合适的构造方法来创建 `std::set` 容器。	



### 容器中的元素操作：

![image-20230804192209832](D:\typora笔记\c++_stl\image-20230804192209832.png)	

在 C++ 中，`std::set` 容器提供了一些操作元素的方法，下面详细解释并举例说明这些操作：

1. 插入元素：

   a. `insert()`：插入单个元素或一组元素到集合中。
   
   ```cpp
   #include <iostream>
   #include <set>
   
   int main() {
       std::set<int> mySet;
   
       // 插入单个元素
       mySet.insert(5);
       
       // 插入一组元素
       mySet.insert({2, 4, 1});
   
       return 0;
   }
   ```

2. 删除元素：

   a. `erase()`：删除指定元素或范围内的元素。

   ```cpp
   #include <iostream>
   #include <set>
   
   int main() {
       std::set<int> mySet = {5, 2, 4, 1};
       
       // 删除指定元素
       mySet.erase(2);
       
       // 删除范围内的元素
       mySet.erase(mySet.begin(), mySet.find(4));
       
       mySet.erase(mySet.begin()); //删除首迭代器指向的元素
   
       return 0;
   }
   ```

3. 查找元素：

   a. `find()`：查找指定元素，返回元素的迭代器。找不到就返回mySet.end()
   
   ```cpp
   #include <iostream>
   #include <set>
   
   int main() {
       std::set<int> mySet = {5, 2, 4, 1};
       
       auto it = mySet.find(4);
       if (it != mySet.end()) {
           std::cout << "Element found: " << *it << std::endl;
       }
       
       return 0;
   }
   ```

4. 计数元素：

   a. `count()`：计算指定元素在集合中的个数。
   
   ```cpp
   #include <iostream>
   #include <set>
   
   int main() {
       std::set<int> mySet = {5, 2, 4, 1};
       
       int count = mySet.count(2);
       std::cout << "Count of 2: " << count << std::endl;
       
       return 0;
   }
   ```

5. 清空集合：

   a. `clear()`：清空集合中的所有元素。
   
   ```cpp
   #include <iostream>
   #include <set>
   
   int main() {
       std::set<int> mySet = {5, 2, 4, 1};
       
       mySet.clear();
       
       return 0;
   }
   ```

这些是 `std::set` 容器中常用的一些操作方法。注意，在插入元素时，`std::set` 会自动保持元素的有序性；在删除元素时，元素会被从集合中移除，不会留下任何残留。在查找元素时，可以使用迭代器进行访问。在计数元素时，可以确定某个元素在集合中的出现次数。总之，`std::set` 提供了丰富的操作方法来处理集合中的元素。



### 交换元素：

在 C++ 中，`std::set` 容器提供了方法来表示自己的大小（即元素个数）以及进行交换操作。下面是关于这两个操作的详细解释和示例：

1. 表示容器大小：

   a. `size()`：获取集合中的元素个数。
   
   ```cpp
   #include <iostream>
   #include <set>
   
   int main() {
       std::set<int> mySet = {5, 2, 4, 1};
       
       std::cout << "Size of set: " << mySet.size() << std::endl;
       
       return 0;
   }
   ```

2. 交换容器：

   a. `swap()`：交换两个集合的内容。
   
   ```cpp
   #include <iostream>
   #include <set>
   
   int main() {
       std::set<int> set1 = {1, 2, 3};
       std::set<int> set2 = {4, 5, 6};
       
       std::cout << "Before swapping:" << std::endl;
       std::cout << "Set1: ";
       for (int num : set1) {
           std::cout << num << " ";
       }
       std::cout << std::endl;
       
       std::cout << "Set2: ";
       for (int num : set2) {
           std::cout << num << " ";
       }
       std::cout << std::endl;
       
       set1.swap(set2);
       
       std::cout << "After swapping:" << std::endl;
       std::cout << "Set1: ";
       for (int num : set1) {
           std::cout << num << " ";
       }
       std::cout << std::endl;
       
       std::cout << "Set2: ";
       for (int num : set2) {
           std::cout << num << " ";
       }
       std::cout << std::endl;
       
       return 0;
   }
   ```

~~~c
注意，在交换操作中，`std::set` 容器的内容被互换，//但**容器本身的结构不会改变。这意味着元素的有序性仍然保持不变**。
~~~

总之，通过使用 `size()` 方法可以获取集合的大小，而使用 `swap()` 方法可以交换两个集合的内容。这些操作使得在处理集合时变得更加灵活和方便。	



### MultiSet 和Set的区别：

![image-20230804192527796](D:\typora笔记\c++_stl\image-20230804192527796.png)	

`std::set` 和 `std::multiset` 都是 C++ 标准库提供的关联容器，用于存储一组元素。它们之间的主要区别在于元素的唯一性和排序规则。让我详细解释并举例说明这两种容器的区别以及在实际应用中的注意事项。

1. **std::set**：

   - `std::set` 存储一组不重复的元素，每个元素只能出现一次。
   - 元素在 `std::set` 中是根据某种排序规则有序排列的，这个排序规则可以通过指定的比较函数来定义。

```cpp
#include <iostream>
#include <set>

int main() {
    std::set<int> mySet;

    mySet.insert(5);
    mySet.insert(2);
    mySet.insert(5); // 不会插入重复元素
    mySet.insert(1);

    for (int num : mySet) {
        std::cout << num << " ";
    }

    return 0;
}
```

2. **std::multiset**：

   - `std::multiset` 存储一组元素，允许元素重复出现。
   - 元素在 `std::multiset` 中也是根据某种排序规则有序排列的，同样可以通过指定的比较函数来定义。

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> myMultiset;

    myMultiset.insert(5);
    myMultiset.insert(2);
    myMultiset.insert(5); // 可以插入重复元素
    myMultiset.insert(1);

    for (int num : myMultiset) {
        std::cout << num << " ";
    }

    return 0;
}
```

**注意事项**：

- 使用 `std::set` 时，每个元素只能出现一次，因此在插入元素时会自动去重。
- 使用 `std::multiset` 时，允许元素重复出现，插入重复元素不会被自动去重。
- 在实际应用中，选择使用哪种容器取决于需要存储的数据是否需要去重。如果需要保留重复元素，可以使用 `std::multiset`。

总之，`std::set` 和 `std::multiset` 都是有序关联容器，主要区别在于元素的唯一性。在选择使用时，根据业务需求来决定是否需要保留重复元素。



### 排序：

![image-20230804193100508](D:\typora笔记\c++_stl\image-20230804193100508.png)	

#### 使用仿函数：

![image-20230804193242481](D:\typora笔记\c++_stl\image-20230804193242481.png)	![image-20230804193249698](D:\typora笔记\c++_stl\image-20230804193249698.png)	

### 仿函数：

在 C++ 中，仿函数（Functor）是一种可调用的对象，也就是重载了函数调用运算符 `operator()` 的类对象。仿函数可以像函数一样被调用，这使得我们可以将其用作函数指针的替代，用于自定义的排序、比较、转换等操作。

以下是仿函数的详细解释和示例：

1. **创建仿函数**：

   仿函数类需要重载函数调用运算符 `operator()`，并在其中实现所需的操作。它可以是普通的类，也可以是函数对象（没有成员变量，只有函数调用运算符）。

```cpp
// 示例1：使用普通类创建仿函数
class Adder {
public:
    int operator()(int a, int b) const {
        return a + b;
    }
};

// 示例2：使用函数对象创建仿函数
struct Multiplier {
    int operator()(int a, int b) const {
        return a * b;
    }
};
```

2. **使用仿函数**：

   仿函数可以像普通函数一样被调用，接收参数并返回结果。

```cpp
#include <iostream>

int main() {
    Adder add;
    Multiplier multiply;

    int sum = add(3, 4);        // 调用仿函数 Adder
    int product = multiply(3, 4); // 调用仿函数 Multiplier

    std::cout << "Sum: " << sum << std::endl;
    std::cout << "Product: " << product << std::endl;

    return 0;
}
```

3. **在标准库中使用仿函数**：

   C++ 标准库中的很多算法和容器，都可以接受用户自定义的仿函数来指定自定义的操作。比如在排序时可以使用自定义的比较函数。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

class Greater {
public:
    bool operator()(int a, int b) const {
        return a > b;
    }
};

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 9};
    
    // 使用仿函数 Greater 进行降序排序
    std::sort(numbers.begin(), numbers.end(), Greater());

    for (int num : numbers) {
        std::cout << num << " ";
    }

    return 0;
}
```

仿函数的优势在于它可以封装一些复杂的操作，并将其作为参数传递给算法或容器。这种灵活性使得代码更加模块化和可维护。

总之，仿函数是一种重载了函数调用运算符的类对象，可以像函数一样被调用，用于自定义的操作和算法。



### 运算符 `operator()`

函数调用运算符 `operator()` 是一个在 C++ 中用于定义仿函数（函数对象）的运算符。它允许类对象在像函数一样的语法下被调用，从而实现类似函数的行为。这个运算符在定义时可以带有参数列表，就像函数一样，用于接收参数并执行操作。

以下是关于函数调用运算符 `operator()` 的详细解释和示例：

1. **函数调用运算符的定义**：

   在一个类中，如果你想让对象可以像函数一样被调用，就可以重载函数调用运算符 `operator()`。

```cpp
class MyFunction {
public:
    ReturnType operator()(ParameterType1 arg1, ParameterType2 arg2, ...) {
        // 这里实现函数调用时的操作
    }
};
```

2. **使用函数调用运算符**：

   在对象后面使用圆括号，并提供与 `operator()` 参数列表匹配的参数，就可以调用仿函数对象。

```cpp
MyFunction func;
ReturnType result = func(arg1, arg2, ...);
```

3. **示例**：

   下面是一个示例，演示了如何定义一个简单的仿函数，然后通过调用函数调用运算符来使用它。

```cpp
#include <iostream>

class Incrementer {
public:
    int operator()(int x) {
        return x + 1;
    }
};

int main() {
    Incrementer inc;

    int value = 5;
    int result = inc(value); // 调用仿函数

    std::cout << "Original value: " << value << std::endl;
    std::cout << "Incremented value: " << result << std::endl;

    return 0;
}
```

在上面的示例中，`Incrementer` 类重载了函数调用运算符 `operator()`，并在其中执行了加一的操作。然后我们通过创建一个 `Incrementer` 对象 `inc`，并调用它来对一个整数进行递增操作。

总之，函数调用运算符 `operator()` 允许类对象像函数一样被调用，从而实现了仿函数的特性，使得类可以像函数一样接受参数并执行操作。这在很多情况下都可以提供更加灵活和模块化的代码设计。

------



## Pair对组创建：

~~~
不需要单独包含头文件
~~~

![image-20230804192809318](D:\typora笔记\c++_stl\image-20230804192809318.png)	

`std::pair` 是 C++ 标准库提供的一个模板类，用于将两个不同类型的值组合成一个对象。`std::pair` 可以在很多场景下用来表示一对值，例如函数返回值、容器元素等。

`std::pair` 的构造方法有多种形式，下面是一些常见的构造方法示例：

1. 默认构造函数：
   - 创建一个空的 `std::pair`，成员变量的值默认初始化。

```cpp
#include <iostream>
#include <utility>

int main() {
    std::pair<int, double> myPair; // 默认构造函数

    std::cout << "First: " << myPair.first << ", Second: " << myPair.second << std::endl;

    return 0;
}
```

2. 带值的构造函数：
   - 创建一个 `std::pair`，并初始化成员变量的值。

```cpp
#include <iostream>
#include <utility>

int main() {
    std::pair<int, double> myPair(5, 3.14);

    std::cout << "First: " << myPair.first << ", Second: " << myPair.second << std::endl;

    return 0;
}
```

3. 使用 `std::make_pair` 函数：
   - 使用 `std::make_pair` 函数创建一个 `std::pair`。

```cpp
#include <iostream>
#include <utility>

int main() {
    std::pair<int, double> myPair = std::make_pair(5, 3.14);

    std::cout << "First: " << myPair.first << ", Second: " << myPair.second << std::endl;

    return 0;
}
```

`std::pair` 的成员变量可以通过 `first` 和 `second` 来访问。注意，`std::pair` 通常在需要将两个不同类型的值进行组合时使用，以便在一个对象中保存这两个值。

总之，`std::pair` 是一个用于存储一对不同类型值的类模板，提供了多种构造方法来创建和初始化 `std::pair` 对象。

### 使用场景：

在游戏开发中，`std::pair` 可以有多种有用的使用场景，让我们来看一些示例：

1. **坐标表示**：在游戏中，经常需要表示一个点或坐标。`std::pair` 可以用来存储二维坐标，比如表示一个游戏中的位置。

```cpp
#include <iostream>
#include <utility>

int main() {
    std::pair<int, int> playerPosition = std::make_pair(10, 20);

    std::cout << "Player position: (" << playerPosition.first << ", " << playerPosition.second << ")" << std::endl;

    return 0;
}
```

2. **物品组合**：游戏中可能会有物品组合的情况，比如合成装备或合成药品。`std::pair` 可以用来表示两个物品的组合。

```cpp
#include <iostream>
#include <utility>
#include <string>

int main() {
    std::pair<std::string, std::string> itemCombination = std::make_pair("Sword", "Shield");

    std::cout << "Combine " << itemCombination.first << " with " << itemCombination.second << std::endl;

    return 0;
}
```

3. **角色属性**：游戏中的角色可能有各种属性，比如生命值、魔法值等。`std::pair` 可以用来表示角色的不同属性。

```cpp
#include <iostream>
#include <utility>

int main() {
    std::pair<int, int> playerAttributes = std::make_pair(100, 50);

    std::cout << "Player HP: " << playerAttributes.first << ", MP: " << playerAttributes.second << std::endl;

    return 0;
}
```

4. **碰撞检测**：在游戏中进行碰撞检测时，可能需要记录两个物体的信息。`std::pair` 可以用来存储碰撞的两个物体。

```cpp
#include <iostream>
#include <utility>
#include <string>

int main() {
    std::pair<std::string, std::string> collisionObjects = std::make_pair("Player", "Obstacle");

    std::cout << "Collision between " << collisionObjects.first << " and " << collisionObjects.second << std::endl;

    return 0;
}
```

这些示例展示了在游戏开发中如何使用 `std::pair` 来组合不同类型的值，以便在一个对象中存储相关信息。`std::pair` 可以帮助简化代码，提高可读性，并且适用于许多不同的场景。	

------



## map/multiMap容器：

![image-20230804193853880](D:\typora笔记\c++_stl\image-20230804193853880.png)	

### 构造方法：

`std::map` 容器的构造方法有多种形式，可以根据不同的需求选择适合的构造方式。以下是 `std::map` 容器的主要构造方法：

1. **默认构造函数**：

   默认构造函数创建一个空的 `std::map` 容器。

```cpp
std::map<Key, Value> myMap; // 创建一个空的 map
```

2. **范围构造函数**：

   范围构造函数接受两个迭代器，用来指定要复制的元素范围。它将复制给定范围内的元素到新的 `std::map`。

```cpp
std::map<Key, Value> myMap(otherMap.begin(), otherMap.end()); // 复制 otherMap 的元素到 myMap
```

3. **复制构造函数**：

   复制构造函数创建一个新的 `std::map` 容器，复制另一个 `std::map` 的所有元素。

```cpp
std::map<Key, Value> myMap(otherMap); // 复制 otherMap 的元素到 myMap
```

4. **移动构造函数**：

   移动构造函数创建一个新的 `std::map` 容器，通过移动另一个 `std::map` 的内容来构造。移动构造函数通常在性能优化方面很有用。

```cpp
std::map<Key, Value> myMap(std::move(otherMap)); // 移动 otherMap 的内容到 myMap
```

5. **初始化列表构造函数**：

   初始化列表构造函数允许你使用初始化列表来创建 `std::map`。

```cpp
std::map<Key, Value> myMap = {{key1, value1}, {key2, value2}, ...}; // 使用初始化列表创建 map
```

6. **自定义比较函数构造函数**：

   你可以使用自定义的比较函数来构造 `std::map`，从而改变元素的排序规则。

```cpp
std::map<Key, Value, Compare> myMap; // 使用自定义的比较函数 Compare 创建 map
```

------



### map操作容器中的元素：

![image-20230804194956619](D:\typora笔记\c++_stl\image-20230804194956619.png)	

![image-20230804195033147](D:\typora笔记\c++_stl\image-20230804195033147.png)	

~~~
map容器中key不允许重复，因此count只有0 1两个结果，

multimap才会有多重结果
~~~

`std::map` 容器中的元素是按照键（key）进行排序的键值对。你可以使用键来访问和操作容器中的元素。以下是一些操作 `std::map` 容器中元素的示例：

```cpp
#include <iostream>
#include <map>

int main() {
    // 创建一个 map 容器并添加元素
    std::map<int, std::string> myMap;
    myMap[3] = "apple";
    myMap[1] = "banana";
    myMap[2] = "cherry";

    // 使用键来访问和操作元素
    std::cout << "Value of key 1: " << myMap[1] << std::endl; // 输出 "banana"

    // 修改元素的值
    myMap[2] = "strawberry";

    // 查找元素并输出
    std::map<int, std::string>::iterator it = myMap.find(3);
    if (it != myMap.end()) {
        std::cout << "Value of key 3: " << it->second << std::endl; // 输出 "apple"
    } else {
        std::cout << "Key 3 not found" << std::endl;
    }

    // 删除元素
    myMap.erase(1);

    // 遍历 map 并输出所有键值对
    for (const auto& pair : myMap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    return 0;
}
```

在上面的示例中，我们创建了一个 `std::map` 容器，并通过键值对的方式添加了几个元素。然后，我们使用键来访问和操作元素，修改元素的值，查找元素，删除元素，以及遍历整个容器输出所有的键值对。

需要注意的是，通过键访问元素时，如果键不存在，会自动插入一个新的键值对，这可能不是你想要的行为。在使用 `operator[]` 访问元素时，要注意确保键是否存在。此外，`find` 方法可以用于在容器中查找特定的键，如果找到了就返回指向该元素的迭代器，否则返回 `end()`。

总之，通过键来访问和操作 `std::map` 容器中的元素是一种常见的操作方式，可以用于实现索引、字典等功能。	

------

在 `std::map` 容器中，你可以使用不同的方法来插入和取出元素。下面是详细说明和示例：

**插入元素**：

1. 使用 `insert` 方法：

```cpp
#include <iostream>
#include <map>

int main() {
    std::map<int, std::string> myMap;

    // 使用 insert 方法插入键值对
    myMap.insert(std::make_pair(3, "apple"));
    myMap.insert(std::make_pair(1, "banana"));

    // 或者使用简化的方式
    myMap.insert({2, "cherry"});

    // 使用下标操作符 [] 插入元素（注意，如果键已存在，会更新值）
    myMap[4] = "orange";

    // 输出所有键值对
    for (const auto& pair : myMap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    return 0;
}
```

**取出元素**：

使用键来访问元素：

```cpp
std::map<int, std::string> myMap;
myMap[3] = "apple";
myMap[1] = "banana";

// 使用键来访问元素的值
std::string fruit = myMap[3]; // "apple"
```

使用 `find` 方法来查找元素并访问值：

```cpp
std::map<int, std::string> myMap;
myMap[3] = "apple";
myMap[1] = "banana";

// 使用 find 方法查找元素
std::map<int, std::string>::iterator it = myMap.find(3);
if (it != myMap.end()) {
    std::string fruit = it->second; // "apple"
}
```

需要注意的是，在使用键来访问元素时，如果键不存在，`std::map` 会自动插入一个新的键值对，值会被默认初始化。因此，如果你只是想查找元素，最好使用 `find` 方法来避免不必要的插入。

总之，通过 `insert` 方法来插入元素，使用键来访问和取出元素的值，或者使用 `find` 方法来查找并访问元素，都是操作 `std::map` 容器中元素的常见方式。

------



### 大小和交换：

![image-20230804194648297](D:\typora笔记\c++_stl\image-20230804194648297.png)	

![image-20230804194704232](D:\typora笔记\c++_stl\image-20230804194704232.png)	

![image-20230804194925725](D:\typora笔记\c++_stl\image-20230804194925725.png)	

------

### 排序：

~~~
默认从小到大
~~~

#### 仿函数：

![image-20230804195218794](D:\typora笔记\c++_stl\image-20230804195218794.png)	![image-20230804195227024](D:\typora笔记\c++_stl\image-20230804195227024.png)	

![image-20230804195254727](D:\typora笔记\c++_stl\image-20230804195254727.png)	

------



### map何做到按照key排序的，又如何根据key快速找到对应的元素？

在 C++ 中，`std::map` 是标准库提供的关联容器之一，它提供了一种键值对的存储方式，其中的元素按照键（key）进行排序。`std::map` 使用红黑树（Red-Black Tree）这种数据结构来实现元素的有序存储和快速查找。

以下是关于 `std::map` 的详细解释和说明：

1. **`std::map` 的特点**：
   - `std::map` 中的每个元素是一个键值对，其中键是唯一的。
   - 元素按照键的排序顺序进行存储。默认情况下，键是按照从小到大的升序排列，但你可以通过提供自定义的比较函数来改变排序规则。
   - 在 `std::map` 中查找元素的时间复杂度为 O(log N)，其中 N 是元素的数量。这得益于红黑树的平衡性质。

**红黑树的排序原理**：

红黑树是一种自平衡二叉查找树，它的平衡性质保证了树的高度始终保持在一个较小的范围内。在 `std::map` 中，每个节点包含一个键值对，键被用来进行排序。通过维护红黑树的平衡性质，`std::map` 可以保证键值对始终按照键的顺序存储。

------



## 函数对象（仿函数）

![image-20230804195416744](D:\typora笔记\c++_stl\image-20230804195416744.png)	

![image-20230804200350327](D:\typora笔记\c++_stl\image-20230804200350327.png)	可以有返回值和参数

~~~
可以有自身的状态：
~~~

![image-20230804200426383](D:\typora笔记\c++_stl\image-20230804200426383.png)	

------



## 谓词：

![image-20230804200458259](D:\typora笔记\c++_stl\image-20230804200458259.png)	

### 一元：

![image-20230804200540626](D:\typora笔记\c++_stl\image-20230804200540626.png)	

~~~
定义仿函数
~~~

​	![image-20230804200606444](D:\typora笔记\c++_stl\image-20230804200606444.png)

~~~
将仿函数作为一元谓词
~~~

![image-20230804200617824](D:\typora笔记\c++_stl\image-20230804200617824.png)	

### find if源码

![image-20230804200725450](D:\typora笔记\c++_stl\image-20230804200725450.png)	

~~~
调用传入的谓词，在if中使用，符合则退出循环；
~~~

------



### 二元：

~~~
以list的sort为例
~~~

![image-20230804200906199](D:\typora笔记\c++_stl\image-20230804200906199.png)	

![image-20230804200945482](D:\typora笔记\c++_stl\image-20230804200945482.png)	两个参数

![image-20230804201004533](D:\typora笔记\c++_stl\image-20230804201004533.png)	

------



## 内建函数对象：

![image-20230805173202157](D:\typora笔记\c++_stl\image-20230805173202157.png)	

## 算数仿函数：

![image-20230805173347569](D:\typora笔记\c++_stl\image-20230805173347569.png)	

### 取反：（负数正数）

![image-20230805173546445](D:\typora笔记\c++_stl\image-20230805173546445.png)	

### plus：

![image-20230805173721068](D:\typora笔记\c++_stl\image-20230805173721068.png)	



## 关系仿函数：

![image-20230805173837812](D:\typora笔记\c++_stl\image-20230805173837812.png)	

### 大于：

![image-20230805173951027](D:\typora笔记\c++_stl\image-20230805173951027.png)	



## 逻辑仿函数：

~~~
用的少
~~~

![image-20230805174024121](D:\typora笔记\c++_stl\image-20230805174024121.png)	

![image-20230805174337647](D:\typora笔记\c++_stl\image-20230805174337647.png)		

~~~
这里transform四个参数：原容器的始末迭代器，要搬运的目标容器 起始迭代器，仿函数（搬运期间要做的事，这里全部取反）
~~~

------



# STL 常用算法：

![image-20230805174424357](D:\typora笔记\c++_stl\image-20230805174424357.png)	

## 遍历算法：

![image-20230805174715942](D:\typora笔记\c++_stl\image-20230805174715942.png)	

![image-20230805174744776](D:\typora笔记\c++_stl\image-20230805174744776.png)	

![image-20230805175421492](D:\typora笔记\c++_stl\image-20230805175421492.png)	



## 查找算法：

![image-20230805175454190](D:\typora笔记\c++_stl\image-20230805175454190.png)	

### Find（）

![image-20230805175556488](D:\typora笔记\c++_stl\image-20230805175556488.png)	

![image-20230805175632169](D:\typora笔记\c++_stl\image-20230805175632169.png)	**自定义数据类型需要承载 == 运算符；**



### Find-if（）

![image-20230805175717943](D:\typora笔记\c++_stl\image-20230805175717943.png)	

![image-20230805175735568](D:\typora笔记\c++_stl\image-20230805175735568.png)	

![image-20230805175803826](D:\typora笔记\c++_stl\image-20230805175803826.png)	

![image-20230805175818950](D:\typora笔记\c++_stl\image-20230805175818950.png)	**自定义数据类型  同样需要承载 ==** 



### adjacent-find：

~~~
用于寻找【相邻】的重复元素  必须相邻  且 重复
~~~

![image-20230805175921089](D:\typora笔记\c++_stl\image-20230805175921089.png)	

![image-20230805175945168](D:\typora笔记\c++_stl\image-20230805175945168.png)	



### binary-find（）

![image-20230805180114314](D:\typora笔记\c++_stl\image-20230805180114314.png)	



### count()：

![image-20230805180158485](D:\typora笔记\c++_stl\image-20230805180158485.png)	

~~~
自定义数据类型 同样重载 ==
~~~

![image-20230805180251721](D:\typora笔记\c++_stl\image-20230805180251721.png)	

![image-20230805180302911](D:\typora笔记\c++_stl\image-20230805180302911.png)	



### count-if（）：

![image-20230805180321981](D:\typora笔记\c++_stl\image-20230805180321981.png)	

如果是自定义数据类型，自定义一个谓词即可

------



## 常用的排序算法：

![image-20230805180504087](D:\typora笔记\c++_stl\image-20230805180504087.png)	

### sort（）：

![image-20230805180530990](D:\typora笔记\c++_stl\image-20230805180530990.png)	无谓词默认从小到大；



### random-shuffle（）：

![image-20230805180608455](D:\typora笔记\c++_stl\image-20230805180608455.png)	

~~~c
使用这个配合随机种子，让随机效果更好//（可以参考上面的笔记：【骰子问题】使用了这个）
~~~

​	![image-20230805180700541](D:\typora笔记\c++_stl\image-20230805180700541.png)	



### Merge（）：

![image-20230805181336647](https://gitee.com/TGGenius/notepad/raw/master/notepad/image/image-20230805181336647.png)	



### reverse（）：

![image-20230805181352265](D:\typora笔记\c++_stl\image-20230805181352265.png)	

------



## 常用拷贝和替换算法：

![image-20230805181421629](D:\typora笔记\c++_stl\image-20230805181421629.png)	

当使用上述算法并执行示例代码时，输出结果如下：

**1. `std::copy` 算法**：

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

int main() {
    std::vector<int> source = {1, 2, 3, 4, 5};
    std::vector<int> destination(source.size());

    std::copy(source.begin(), source.end(), destination.begin());

    for (int num : destination) {
        std::cout << num << " ";
    }

    return 0;
}
```

输出结果：
```
1 2 3 4 5
```

**2. `std::replace` 算法**：

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 3, 5};

    std::replace(numbers.begin(), numbers.end(), 3, 6);

    for (int num : numbers) {
        std::cout << num << " ";
    }

    return 0;
}
```

输出结果：
```
1 2 6 4 6 5
```

**3. `std::replace_if` 算法**：

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

bool isEven(int num) {
    return num % 2 == 0;
}

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    std::replace_if(numbers.begin(), numbers.end(), isEven, 0);

    for (int num : numbers) {
        std::cout << num << " ";
    }

    return 0;
}
```

输出结果：
```
1 0 3 0 5
```

**4. `std::swap` 算法**：

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

int main() {
    int a = 5, b = 10;
    std::swap(a, b);

    std::cout << "a: " << a << " b: " << b;

    return 0;
}
```

输出结果：
```
a: 10 b: 5
```

**参数说明**：

- `std::copy` 算法的参数：`std::copy` 函数接受三个参数，分别是源容器的起始迭代器，源容器的结束迭代器，以及目标容器的起始迭代器。用于将源容器中的元素拷贝到目标容器中。

- `std::replace` 算法的参数：`std::replace` 函数接受三个参数，分别是容器的起始迭代器，容器的结束迭代器，以及要被替换的旧值，用来将容器中的指定旧值替换为新值。

- `std::replace_if` 算法的参数：`std::replace_if` 函数接受四个参数，分别是容器的起始迭代器，容器的结束迭代器，一个可调用对象（可以是函数指针、函数对象或 Lambda 表达式），以及要替换的新值。它会根据提供的可调用对象对容器中的元素进行判断，并将满足条件的元素替换为新值。

- `std::swap` 算法的参数：`std::swap` 函数接受两个参数，分别是要交换的两个元素。它会将两个元素的值进行交换。

在使用这些算法时，需要确保容器中有足够的空间来存放拷贝或替换后的元素。而且 `std::replace` 和 `std::replace_if` 算法会对容器中的每个元素应用替换操作，所以请确保操作的确是你想要的。在使用 `std::replace_if` 和 `std::swap` 算法时，要提供一个合适的判定条件或交换逻辑。同时，这些算法的参数通常是迭代器，所以确保迭代器范围有效，不越界。	

------



## 常用的算数生成算法：

![image-20230805181801592](D:\typora笔记\c++_stl\image-20230805181801592.png)	

当使用 `std::accumulate` 和 `std::fill` 算法函数时，可以按照下面的方式使用。我将为每个函数提供详细说明和示例。

**1. `std::accumulate` 算法**：

`std::accumulate` 算法用于计算容器中一系列元素的累积值。

```cpp
#include <iostream>
#include <algorithm>
#include <numeric>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);

    std::cout << "Sum: " << sum;

    return 0;
}
```

**参数说明**：
- 第一个参数是容器的起始迭代器。
- 第二个参数是容器的结束迭代器。
- 第三个参数是初始累积值。

**输出结果**：
```
Sum: 15
```

**2. `std::fill` 算法**：

`std::fill` 算法用于将指定的值填充到容器的所有元素中。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

int main() {
    std::vector<int> numbers(5);

    std::fill(numbers.begin(), numbers.end(), 42);

    for (int num : numbers) {
        std::cout << num << " ";
    }

    return 0;
}
```

**参数说明**：
- 第一个参数是容器的起始迭代器。
- 第二个参数是容器的结束迭代器。
- 第三个参数是要填充的值。

**输出结果**：
```
42 42 42 42 42
```

在使用这些算法时，需要注意以下几点：

- 在使用 `std::accumulate` 时，确保提供合适的初始累积值，以便正确计算累积值。
- 在使用 `std::fill` 时，确保容器中有足够的空间来填充指定的值。
- 这些算法的参数通常是迭代器，所以要确保迭代器范围有效，不越界。

总之，`std::accumulate` 和 `std::fill` 算法函数可以用于计算累积值和填充容器中的元素。在使用时要注意提供正确的参数，确保操作的有效性。	

------



## 常用的集合算法：

~~~c
//这些算法要求输入的容器是有序的（按照比较函数的规则）
~~~

当使用 `std::set_intersection`、`std::set_union` 和 `std::set_difference` 算法函数时，以下是各个函数的参数说明、示例和运行结果：

**1. `std::set_intersection` 算法**：

```cpp
#include <iostream>
#include <algorithm>
#include <set>
#include <vector>

int main() {
    std::set<int> set1 = {1, 2, 3, 4, 5};
    std::set<int> set2 = {3, 4, 5, 6, 7};
    std::vector<int> intersection;

    std::set_intersection(
        set1.begin(), set1.end(),
        set2.begin(), set2.end(),
        std::back_inserter(intersection)
    );

    std::cout << "Intersection: ";
    for (int num : intersection) {
        std::cout << num << " ";
    }

    return 0;
}
```

**运行结果**：
```
Intersection: 3 4 5
```

**参数说明**：**（下面几个方法的参数都一样）**

- 第一个参数是第一个有序集合的起始迭代器。
- 第二个参数是第一个有序集合的结束迭代器。
- 第三个参数是第二个有序集合的起始迭代器。
- 第四个参数是第二个有序集合的结束迭代器。
- 第五个参数是输出结果的迭代器。



**2. `std::set_union` 算法**：

```cpp
#include <iostream>
#include <algorithm>
#include <set>
#include <vector>

int main() {
    std::set<int> set1 = {1, 2, 3, 4, 5};
    std::set<int> set2 = {3, 4, 5, 6, 7};
    std::vector<int> unionSet;

    std::set_union(
        set1.begin(), set1.end(),
        set2.begin(), set2.end(),
        std::back_inserter(unionSet)
    );

    std::cout << "Union: ";
    for (int num : unionSet) {
        std::cout << num << " ";
    }

    return 0;
}
```

**运行结果**：
```
Union: 1 2 3 4 5 6 7
```

**3. `std::set_difference` 算法**：

```cpp
#include <iostream>
#include <algorithm>
#include <set>
#include <vector>

int main() {
    std::set<int> set1 = {1, 2, 3, 4, 5};
    std::set<int> set2 = {3, 4, 5, 6, 7};
    std::vector<int> difference;

    std::set_difference(
        set1.begin(), set1.end(),
        set2.begin(), set2.end(),
        std::back_inserter(difference)
    );

    std::cout << "Difference: ";
    for (int num : difference) {
        std::cout << num << " ";
    }

    return 0;
}
```

**运行结果**：
```
Difference: 1 2
```

在使用这些算法时，需要注意以下几点：

- **这些算法要求输入的容器是有序的（按照比较函数的规则）**。
- 需要提供输出容器，以便存储结果。
- 使用 `std::back_inserter` 来在输出容器中动态插入元素。
- 确保容器中有足够的空间来存储结果。
- 这些算法的参数通常是迭代器，所以要确保迭代器范围有效，不越界。

总之，`std::set_intersection`、`std::set_union` 和 `std::set_difference` 算法函数可以用于获取有序集合的交集、并集和差集。在使用时要注意提供正确的参数，确保操作的有效性，并且可以通过输出结果验证运行的正确性。
